<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/electron-userland/electron-builder"

    >electron-builder (v17.0.1)</a>
</h1>
<h4>A complete solution to package and build a ready for distribution Electron app for MacOS, Windows and Linux with “auto update” support out of the box</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder">module electron-builder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.Packager">
            function <span class="apidocSignatureSpan">electron-builder.</span>Packager
            <span class="apidocSignatureSpan">(options, cancellationToken)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.Platform">
            function <span class="apidocSignatureSpan">electron-builder.</span>Platform
            <span class="apidocSignatureSpan">(name, buildConfigurationKey, nodeName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.Target">
            function <span class="apidocSignatureSpan">electron-builder.</span>Target
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.archFromString">
            function <span class="apidocSignatureSpan">electron-builder.</span>archFromString
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.build">
            function <span class="apidocSignatureSpan">electron-builder.</span>build
            <span class="apidocSignatureSpan">(_x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.buildForge">
            function <span class="apidocSignatureSpan">electron-builder.</span>buildForge
            <span class="apidocSignatureSpan">(appDir, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.createTargets">
            function <span class="apidocSignatureSpan">electron-builder.</span>createTargets
            <span class="apidocSignatureSpan">(platforms, type, arch)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.getArchSuffix">
            function <span class="apidocSignatureSpan">electron-builder.</span>getArchSuffix
            <span class="apidocSignatureSpan">(arch)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>Arch</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>ArchiveTarget</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>LinuxTargetHelper</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>PublishManager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>WebInstallerTarget</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>appImage</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>appInfo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>appx</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>asar</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>asarUtil</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>builder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>cliOptions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>codeSign</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>dmg</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>fileMatcher</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>fileTransformer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>filter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>forge_maker</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>fpm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>linuxPackager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>mac</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>macPackager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>nsis</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>packager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>pkg</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>platformPackager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>readInstalled</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>readPackageJson</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>repositoryInfo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>snap</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>targetFactory</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>winPackager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>windowsCodeSign</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>yarn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">electron-builder.</span>DIR_TARGET</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.ArchiveTarget">module electron-builder.ArchiveTarget</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.ArchiveTarget.ArchiveTarget">
            function <span class="apidocSignatureSpan">electron-builder.</span>ArchiveTarget
            <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.LinuxTargetHelper">module electron-builder.LinuxTargetHelper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.LinuxTargetHelper.LinuxTargetHelper">
            function <span class="apidocSignatureSpan">electron-builder.</span>LinuxTargetHelper
            <span class="apidocSignatureSpan">(packager)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">electron-builder.LinuxTargetHelper.</span>installPrefix</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.PublishManager">module electron-builder.PublishManager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.PublishManager.PublishManager">
            function <span class="apidocSignatureSpan">electron-builder.</span>PublishManager
            <span class="apidocSignatureSpan">(packager, publishOptions, cancellationToken)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.PublishManager.computeDownloadUrl">
            function <span class="apidocSignatureSpan">electron-builder.PublishManager.</span>computeDownloadUrl
            <span class="apidocSignatureSpan">(publishConfig, fileName, packager)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.PublishManager.createPublisher">
            function <span class="apidocSignatureSpan">electron-builder.PublishManager.</span>createPublisher
            <span class="apidocSignatureSpan">(context, version, publishConfig, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.PublishManager.getPublishConfigs">
            function <span class="apidocSignatureSpan">electron-builder.PublishManager.</span>getPublishConfigs
            <span class="apidocSignatureSpan">(_x12, _x13, _x14)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.PublishManager.getPublishConfigsForUpdateInfo">
            function <span class="apidocSignatureSpan">electron-builder.PublishManager.</span>getPublishConfigsForUpdateInfo
            <span class="apidocSignatureSpan">(_x2, _x3, _x4)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.WebInstallerTarget">module electron-builder.WebInstallerTarget</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.WebInstallerTarget.WebInstallerTarget">
            function <span class="apidocSignatureSpan">electron-builder.</span>WebInstallerTarget
            <span class="apidocSignatureSpan">(_nsis || _load_nsis()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.appImage">module electron-builder.appImage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.appImage.default">
            function <span class="apidocSignatureSpan">electron-builder.appImage.</span>default
            <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.appInfo">module electron-builder.appInfo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.appInfo.AppInfo">
            function <span class="apidocSignatureSpan">electron-builder.appInfo.</span>AppInfo
            <span class="apidocSignatureSpan">(metadata, info, buildVersion)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.appx">module electron-builder.appx</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.appx.default">
            function <span class="apidocSignatureSpan">electron-builder.appx.</span>default
            <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.asar">module electron-builder.asar</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.asar.AsarFilesystem">
            function <span class="apidocSignatureSpan">electron-builder.asar.</span>AsarFilesystem
            <span class="apidocSignatureSpan">(src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.asar.Node">
            function <span class="apidocSignatureSpan">electron-builder.asar.</span>Node
            <span class="apidocSignatureSpan">{{signature}}</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.asar.readAsar">
            function <span class="apidocSignatureSpan">electron-builder.asar.</span>readAsar
            <span class="apidocSignatureSpan">(_x5)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.asar.readAsarJson">
            function <span class="apidocSignatureSpan">electron-builder.asar.</span>readAsarJson
            <span class="apidocSignatureSpan">(_x6, _x7)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.asarUtil">module electron-builder.asarUtil</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.asarUtil.AsarPackager">
            function <span class="apidocSignatureSpan">electron-builder.asarUtil.</span>AsarPackager
            <span class="apidocSignatureSpan">(src, destination, options, unpackPattern, transformer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.asarUtil.checkFileInArchive">
            function <span class="apidocSignatureSpan">electron-builder.asarUtil.</span>checkFileInArchive
            <span class="apidocSignatureSpan">(_x2, _x3, _x4)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.builder">module electron-builder.builder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.builder.build">
            function <span class="apidocSignatureSpan">electron-builder.builder.</span>build
            <span class="apidocSignatureSpan">(_x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.builder.createTargets">
            function <span class="apidocSignatureSpan">electron-builder.builder.</span>createTargets
            <span class="apidocSignatureSpan">(platforms, type, arch)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.builder.normalizeOptions">
            function <span class="apidocSignatureSpan">electron-builder.builder.</span>normalizeOptions
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.cliOptions">module electron-builder.cliOptions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.cliOptions.createYargs">
            function <span class="apidocSignatureSpan">electron-builder.cliOptions.</span>createYargs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.codeSign">module electron-builder.codeSign</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.codeSign.createKeychain">
            function <span class="apidocSignatureSpan">electron-builder.codeSign.</span>createKeychain
            <span class="apidocSignatureSpan">(_x3, _x4, _x5, _x6, _x7)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.codeSign.downloadCertificate">
            function <span class="apidocSignatureSpan">electron-builder.codeSign.</span>downloadCertificate
            <span class="apidocSignatureSpan">(_x, _x2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.codeSign.findIdentity">
            function <span class="apidocSignatureSpan">electron-builder.codeSign.</span>findIdentity
            <span class="apidocSignatureSpan">(certType, qualifier, keychain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.codeSign.sign">
            function <span class="apidocSignatureSpan">electron-builder.codeSign.</span>sign
            <span class="apidocSignatureSpan">(path, name, keychain)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.codeSign.</span>appleCertificatePrefixes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.codeSign.</span>findIdentityRawResult</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.dmg">module electron-builder.dmg</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.dmg.DmgTarget">
            function <span class="apidocSignatureSpan">electron-builder.dmg.</span>DmgTarget
            <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.dmg.attachAndExecute">
            function <span class="apidocSignatureSpan">electron-builder.dmg.</span>attachAndExecute
            <span class="apidocSignatureSpan">(_x2, _x3, _x4)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.fileMatcher">module electron-builder.fileMatcher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.fileMatcher.FileMatcher">
            function <span class="apidocSignatureSpan">electron-builder.fileMatcher.</span>FileMatcher
            <span class="apidocSignatureSpan">(from, to, macroExpander, patterns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.fileMatcher.copyFiles">
            function <span class="apidocSignatureSpan">electron-builder.fileMatcher.</span>copyFiles
            <span class="apidocSignatureSpan">(patterns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.fileMatcher.createFileMatcher">
            function <span class="apidocSignatureSpan">electron-builder.fileMatcher.</span>createFileMatcher
            <span class="apidocSignatureSpan">(info, appDir, resourcesPath, macroExpander, platformSpecificBuildOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.fileMatcher.getFileMatchers">
            function <span class="apidocSignatureSpan">electron-builder.fileMatcher.</span>getFileMatchers
            <span class="apidocSignatureSpan">(config, name, defaultSrc, defaultDest, allowAdvancedMatching, macroExpander, customBuildOptions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.fileTransformer">module electron-builder.fileTransformer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.fileTransformer.createElectronCompilerHost">
            function <span class="apidocSignatureSpan">electron-builder.fileTransformer.</span>createElectronCompilerHost
            <span class="apidocSignatureSpan">(projectDir, cacheDir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.fileTransformer.createTransformer">
            function <span class="apidocSignatureSpan">electron-builder.fileTransformer.</span>createTransformer
            <span class="apidocSignatureSpan">(_x, _x2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.fileTransformer.isElectronCompileUsed">
            function <span class="apidocSignatureSpan">electron-builder.fileTransformer.</span>isElectronCompileUsed
            <span class="apidocSignatureSpan">(info)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.filter">module electron-builder.filter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.filter.createFilter">
            function <span class="apidocSignatureSpan">electron-builder.filter.</span>createFilter
            <span class="apidocSignatureSpan">(src, patterns, ignoreFiles, rawFilter, excludePatterns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.filter.hasMagic">
            function <span class="apidocSignatureSpan">electron-builder.filter.</span>hasMagic
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.forge_maker">module electron-builder.forge_maker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.forge_maker.buildForge">
            function <span class="apidocSignatureSpan">electron-builder.forge_maker.</span>buildForge
            <span class="apidocSignatureSpan">(appDir, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.fpm">module electron-builder.fpm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.fpm.default">
            function <span class="apidocSignatureSpan">electron-builder.fpm.</span>default
            <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.linuxPackager">module electron-builder.linuxPackager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.linuxPackager.LinuxPackager">
            function <span class="apidocSignatureSpan">electron-builder.linuxPackager.</span>LinuxPackager
            <span class="apidocSignatureSpan">(_platformPackager || _load_platformPackager()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.mac">module electron-builder.mac</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.mac.createApp">
            function <span class="apidocSignatureSpan">electron-builder.mac.</span>createApp
            <span class="apidocSignatureSpan">(_x, _x2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.mac.filterCFBundleIdentifier">
            function <span class="apidocSignatureSpan">electron-builder.mac.</span>filterCFBundleIdentifier
            <span class="apidocSignatureSpan">(identifier)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.macPackager">module electron-builder.macPackager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.macPackager.default">
            function <span class="apidocSignatureSpan">electron-builder.macPackager.</span>default
            <span class="apidocSignatureSpan">(_platformPackager || _load_platformPackager()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.nsis">module electron-builder.nsis</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.nsis.AppPackageHelper">
            function <span class="apidocSignatureSpan">electron-builder.nsis.</span>AppPackageHelper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.nsis.NsisTarget">
            function <span class="apidocSignatureSpan">electron-builder.nsis.</span>NsisTarget
            <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.packager">module electron-builder.packager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.packager.Packager">
            function <span class="apidocSignatureSpan">electron-builder.packager.</span>Packager
            <span class="apidocSignatureSpan">(options, cancellationToken)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.packager.checkWineVersion">
            function <span class="apidocSignatureSpan">electron-builder.packager.</span>checkWineVersion
            <span class="apidocSignatureSpan">(_x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.packager.normalizePlatforms">
            function <span class="apidocSignatureSpan">electron-builder.packager.</span>normalizePlatforms
            <span class="apidocSignatureSpan">(rawPlatforms)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.pkg">module electron-builder.pkg</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.pkg.PkgTarget">
            function <span class="apidocSignatureSpan">electron-builder.pkg.</span>PkgTarget
            <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.pkg.prepareProductBuildArgs">
            function <span class="apidocSignatureSpan">electron-builder.pkg.</span>prepareProductBuildArgs
            <span class="apidocSignatureSpan">(identity, keychain)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.platformPackager">module electron-builder.platformPackager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.platformPackager.PlatformPackager">
            function <span class="apidocSignatureSpan">electron-builder.platformPackager.</span>PlatformPackager
            <span class="apidocSignatureSpan">(info)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.platformPackager.normalizeExt">
            function <span class="apidocSignatureSpan">electron-builder.platformPackager.</span>normalizeExt
            <span class="apidocSignatureSpan">(ext)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.readInstalled">module electron-builder.readInstalled</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.readInstalled.readInstalled">
            function <span class="apidocSignatureSpan">electron-builder.</span>readInstalled
            <span class="apidocSignatureSpan">(_x)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.readPackageJson">module electron-builder.readPackageJson</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.readPackageJson.readPackageJson">
            function <span class="apidocSignatureSpan">electron-builder.</span>readPackageJson
            <span class="apidocSignatureSpan">(_x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.readPackageJson.doLoadConfig">
            function <span class="apidocSignatureSpan">electron-builder.readPackageJson.</span>doLoadConfig
            <span class="apidocSignatureSpan">(_x4, _x5)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.readPackageJson.getElectronVersion">
            function <span class="apidocSignatureSpan">electron-builder.readPackageJson.</span>getElectronVersion
            <span class="apidocSignatureSpan">(_x7, _x8, _x9)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.readPackageJson.loadConfig">
            function <span class="apidocSignatureSpan">electron-builder.readPackageJson.</span>loadConfig
            <span class="apidocSignatureSpan">(_x6)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.readPackageJson.validateConfig">
            function <span class="apidocSignatureSpan">electron-builder.readPackageJson.</span>validateConfig
            <span class="apidocSignatureSpan">(_x10)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.repositoryInfo">module electron-builder.repositoryInfo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.repositoryInfo.getRepositoryInfo">
            function <span class="apidocSignatureSpan">electron-builder.repositoryInfo.</span>getRepositoryInfo
            <span class="apidocSignatureSpan">(projectDir, metadata, devMetadata)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.snap">module electron-builder.snap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.snap.default">
            function <span class="apidocSignatureSpan">electron-builder.snap.</span>default
            <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.targetFactory">module electron-builder.targetFactory</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.targetFactory.NoOpTarget">
            function <span class="apidocSignatureSpan">electron-builder.targetFactory.</span>NoOpTarget
            <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.targetFactory.computeArchToTargetNamesMap">
            function <span class="apidocSignatureSpan">electron-builder.targetFactory.</span>computeArchToTargetNamesMap
            <span class="apidocSignatureSpan">(raw, options, platform)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.targetFactory.createCommonTarget">
            function <span class="apidocSignatureSpan">electron-builder.targetFactory.</span>createCommonTarget
            <span class="apidocSignatureSpan">(target, outDir, packager)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.targetFactory.createTargets">
            function <span class="apidocSignatureSpan">electron-builder.targetFactory.</span>createTargets
            <span class="apidocSignatureSpan">(nameToTarget, rawList, outDir, packager, cleanupTasks)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.winPackager">module electron-builder.winPackager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.winPackager.WinPackager">
            function <span class="apidocSignatureSpan">electron-builder.winPackager.</span>WinPackager
            <span class="apidocSignatureSpan">(_platformPackager || _load_platformPackager()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.windowsCodeSign">module electron-builder.windowsCodeSign</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.windowsCodeSign.getSignVendorPath">
            function <span class="apidocSignatureSpan">electron-builder.windowsCodeSign.</span>getSignVendorPath
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.windowsCodeSign.getToolPath">
            function <span class="apidocSignatureSpan">electron-builder.windowsCodeSign.</span>getToolPath
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.windowsCodeSign.sign">
            function <span class="apidocSignatureSpan">electron-builder.windowsCodeSign.</span>sign
            <span class="apidocSignatureSpan">(_x)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.yarn">module electron-builder.yarn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.yarn.getGypEnv">
            function <span class="apidocSignatureSpan">electron-builder.yarn.</span>getGypEnv
            <span class="apidocSignatureSpan">(frameworkInfo, platform, arch, buildFromSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.yarn.installOrRebuild">
            function <span class="apidocSignatureSpan">electron-builder.yarn.</span>installOrRebuild
            <span class="apidocSignatureSpan">(_x, _x2, _x3, _x4, _x5)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.yarn.rebuild">
            function <span class="apidocSignatureSpan">electron-builder.yarn.</span>rebuild
            <span class="apidocSignatureSpan">(_x9, _x10)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder" id="apidoc.module.electron-builder">module electron-builder</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.Packager" id="apidoc.element.electron-builder.Packager">
        function <span class="apidocSignatureSpan">electron-builder.</span>Packager
        <span class="apidocSignatureSpan">(options, cancellationToken)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Packager {
    //noinspection JSUnusedGlobalSymbols
    constructor(options, cancellationToken) {
        this.options = options;
        this.cancellationToken = cancellationToken;
        this.isTwoPackageJsonProjectLayoutUsed = true;
        this.eventEmitter = new (_events || _load_events()).EventEmitter();
        this.tempDirManager = new (_tmp || _load_tmp()).TmpDir();
        this._repositoryInfo = new (_electronBuilderUtil || _load_electronBuilderUtil()).Lazy(() =&#x3e; (0, (_repositoryInfo || _load_repositoryInfo
()).getRepositoryInfo)(this.projectDir, this.metadata, this.devMetadata));
        this.afterPackHandlers = [];
        this.projectDir = options.projectDir == null ? process.cwd() : _path.resolve(options.projectDir);
        this.prepackaged = options.prepackaged == null ? null : _path.resolve(this.projectDir, options.prepackaged);
    }
    get isPrepackedAppAsar() {
        return this._isPrepackedAppAsar;
    }
    get config() {
        return this._config;
    }
    get repositoryInfo() {
        return this._repositoryInfo.value;
    }
    addAfterPackHandler(handler) {
        this.afterPackHandlers.push(handler);
    }
    artifactCreated(handler) {
        addHandler(this.eventEmitter, &#x22;artifactCreated&#x22;, handler);
        return this;
    }
    dispatchArtifactCreated(event) {
        this.eventEmitter.emit(&#x22;artifactCreated&#x22;, event);
    }
    build() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            //noinspection JSDeprecatedSymbols
            const devMetadataFromOptions = _this.options.devMetadata;
            if (devMetadataFromOptions != null) {
                (0, (_log || _load_log()).warn)(&#x22;devMetadata is deprecated, please use config instead&#x22;);
            }
            let configPath = null;
            let configFromOptions = _this.options.config;
            if (typeof configFromOptions === &#x22;string&#x22;) {
                // it is a path to config file
                configPath = configFromOptions;
                configFromOptions = null;
            }
            if (devMetadataFromOptions != null) {
                if (configFromOptions != null) {
                    throw new Error(&#x22;devMetadata and config cannot be used in conjunction&#x22;);
                }
                configFromOptions = devMetadataFromOptions.build;
            }
            const projectDir = _this.projectDir;
            const fileOrPackageConfig = yield configPath == null ? (0, (_readPackageJson || _load_readPackageJson()).loadConfig)(
projectDir) : (0, (_readPackageJson || _load_readPackageJson()).doLoadConfig)(_path.resolve(projectDir, configPath), projectDir);
            const config = (0, (_deepAssign || _load_deepAssign()).deepAssign)({}, fileOrPackageConfig, configFromOptions);
            const extraMetadata = _this.options.extraMetadata;
            if (extraMetadata != null) {
                const extraBuildMetadata = extraMetadata.build;
                if (extraBuildMetadata != null) {
                    (0, (_deepAssign || _load_deepAssign()).deepAssign)(config, extraBuildMetadata);
                    delete extraMetadata.build;
                }
                if (extraMetadata.directories != null) {
                    (0, (_log || _load_log()).warn)(`--em.directories is deprecated, please specify as --em.build.directories&#x22;`);
                    (0, (_deepAssign || _load_deepAssign()).deepAssign)(config, { directories: extraMetadata.directories });
                    delete extraMetadata.directories;
                }
            }
            yield (0, (_readPackageJson || _load_readPackageJson()).validateConfig)(config);
            _this._config = config;
            _this.appDir = yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).computeDefaultAppDirectory)(projectDir
, (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(config.directories, function (it) {
                return it.app;
            }));
            _this.isTwoPackageJsonProjectLayoutUsed = _this.appDir !== projectD ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (options.draft === undefined &#x26;&#x26; !(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process
.env.EP_DRAFT)) {
    options.draft = process.env.EP_DRAFT.toLowerCase() === &#x22;true&#x22;;
}
if (options.prerelease === undefined &#x26;&#x26; !(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process
.env.EP_PRELEASE)) {
    options.prerelease = process.env.EP_PRELEASE.toLowerCase() === &#x22;true&#x22;;
}
const cancellationToken = new (_CancellationToken || _load_CancellationToken()).CancellationToken();
const packager = new (_packager || _load_packager()).<span class="apidocCodeKeywordSpan">Packager</span>(options, cancellationToken
);
// because artifact event maybe dispatched several times for different publish providers
const artifactPaths = new Set();
packager.artifactCreated(function (event) {
    if (event.file != null) {
        artifactPaths.add(event.file);
    }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.Platform" id="apidoc.element.electron-builder.Platform">
        function <span class="apidocSignatureSpan">electron-builder.</span>Platform
        <span class="apidocSignatureSpan">(name, buildConfigurationKey, nodeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Platform {
    constructor(name, buildConfigurationKey, nodeName) {
        this.name = name;
        this.buildConfigurationKey = buildConfigurationKey;
        this.nodeName = nodeName;
    }
    toString() {
        return this.name;
    }
    createTarget(type) {
        for (var _len = arguments.length, archs = Array(_len &#x3e; 1 ? _len - 1 : 0), _key = 1; _key &#x3c; _len; _key++) {
            archs[_key - 1] = arguments[_key];
        }

        if (type == null &#x26;&#x26; (archs == null || archs.length === 0)) {
            return new Map([[this, new Map()]]);
        }
        const archToType = new Map();
        if (this === Platform.MAC) {
            archs = [Arch.x64];
        }
        for (const arch of archs == null || archs.length === 0 ? [archFromString(process.arch)] : archs) {
            archToType.set(arch, type == null ? [] : Array.isArray(type) ? type : [type]);
        }
        return new Map([[this, archToType]]);
    }
    static current() {
        return Platform.fromString(process.platform);
    }
    static fromString(name) {
        name = name.toLowerCase();
        switch (name) {
            case Platform.MAC.nodeName:
            case Platform.MAC.name:
                return Platform.MAC;
            case Platform.WINDOWS.nodeName:
            case Platform.WINDOWS.name:
            case Platform.WINDOWS.buildConfigurationKey:
                return Platform.WINDOWS;
            case Platform.LINUX.nodeName:
                return Platform.LINUX;
            default:
                throw new Error(`Unknown platform: ${name}`);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.Target" id="apidoc.element.electron-builder.Target">
        function <span class="apidocSignatureSpan">electron-builder.</span>Target
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Target {
    constructor(name) {
        let isAsyncSupported = arguments.length &#x3e; 1 &#x26;&#x26; arguments[1] !== undefined ? arguments[1] : true;

        this.name = name;
        this.isAsyncSupported = isAsyncSupported;
    }
    finishBuild() {
        return Promise.resolve();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.archFromString" id="apidoc.element.electron-builder.archFromString">
        function <span class="apidocSignatureSpan">electron-builder.</span>archFromString
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function archFromString(name) {
    if (name === &#x22;x64&#x22;) {
        return Arch.x64;
    }
    if (name === &#x22;ia32&#x22;) {
        return Arch.ia32;
    }
    if (name === &#x22;armv7l&#x22;) {
        return Arch.armv7l;
    }
    throw new Error(`Unsupported arch ${name}`);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.build" id="apidoc.element.electron-builder.build">
        function <span class="apidocSignatureSpan">electron-builder.</span>build
        <span class="apidocSignatureSpan">(_x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function build(_x) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
&#x22;use strict&#x22;

const builder = require(&#x22;electron-builder&#x22;)
const Platform = builder.Platform

// Promise is returned
builder.<span class="apidocCodeKeywordSpan">build</span>({
targets: Platform.MAC.createTarget(),
config: {
 &#x22;//&#x22;: &#x22;build options, see https://goo.gl/ZhRfla&#x22;
}
})
.then(() =&#x3e; {
  // handle result
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.buildForge" id="apidoc.element.electron-builder.buildForge">
        function <span class="apidocSignatureSpan">electron-builder.</span>buildForge
        <span class="apidocSignatureSpan">(appDir, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buildForge(appDir, options) {
    return (0, (_builder || _load_builder()).build)(Object.assign({
        prepackaged: appDir,
        config: {
            directories: {
                // https://github.com/electron-userland/electron-forge/blob/master/src/makers/generic/zip.js
                output: _path.resolve(appDir, &#x22;..&#x22;, &#x22;make&#x22;)
            }
        }
    }, options));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.createTargets" id="apidoc.element.electron-builder.createTargets">
        function <span class="apidocSignatureSpan">electron-builder.</span>createTargets
        <span class="apidocSignatureSpan">(platforms, type, arch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTargets(platforms, type, arch) {
    const targets = new Map();
    for (const platform of platforms) {
        const archs = platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC ? [(_electronBuilderCore ||
_load_electronBuilderCore()).Arch.x64] : arch === &#x22;all&#x22; ? [(_electronBuilderCore || _load_electronBuilderCore()).Arch.x64, (_electronBuilderCore
 || _load_electronBuilderCore()).Arch.ia32] : [(0, (_electronBuilderCore || _load_electronBuilderCore()).archFromString)(arch ==
null ? process.arch : arch)];
        const archToType = new Map();
        targets.set(platform, archToType);
        for (const arch of archs) {
            archToType.set(arch, type == null ? [] : [type]);
        }
    }
    return targets;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (target == null) {
        target = factory(outDir);
        nameToTarget.set(name, target);
    }
    result.push(target);
};
const targets = normalizeTargets(rawList, packager.defaultTarget);
packager.<span class="apidocCodeKeywordSpan">createTargets</span>(targets, mapper, cleanupTasks);
return result;
}
function normalizeTargets(targets, defaultTarget) {
const list = [];
for (const t of targets) {
    const name = t.toLowerCase().trim();
    if (name === (_electronBuilderCore || _load_electronBuilderCore()).DEFAULT_TARGET) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.getArchSuffix" id="apidoc.element.electron-builder.getArchSuffix">
        function <span class="apidocSignatureSpan">electron-builder.</span>getArchSuffix
        <span class="apidocSignatureSpan">(arch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getArchSuffix(arch) {
    return arch === Arch.x64 ? &#x22;&#x22; : `-${Arch[arch]}`;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.ArchiveTarget" id="apidoc.module.electron-builder.ArchiveTarget">module electron-builder.ArchiveTarget</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.ArchiveTarget.ArchiveTarget" id="apidoc.element.electron-builder.ArchiveTarget.ArchiveTarget">
        function <span class="apidocSignatureSpan">electron-builder.</span>ArchiveTarget
        <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ArchiveTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
    constructor(name, outDir, packager) {
        super(name);
        this.outDir = outDir;
        this.packager = packager;
        this.options = this.packager.config[this.name];
    }
    build(appOutDir, arch) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = _this.packager;
            const isMac = packager.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC;
            const outDir = _this.outDir;
            const format = _this.name;
            (0, (_log || _load_log()).log)(`Building ${isMac ? &#x22;macOS &#x22; : &#x22;&#x22;}${format}`);
            // we use app name here - see https://github.com/electron-userland/electron-builder/pull/204
            const outFile = function () {
                switch (packager.platform) {
                    case (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC:
                        return _path.join(outDir, packager.expandArtifactNamePattern(_this.options, format, arch, &#x22;${productName
}-${version}-${os}.${ext}&#x22;));
                    case (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS:
                        return _path.join(outDir, packager.generateName(format, arch, false, &#x22;win&#x22;));
                    case (_electronBuilderCore || _load_electronBuilderCore()).Platform.LINUX:
                        return _path.join(outDir, packager.generateName(format, arch, true));
                    default:
                        throw new Error(`Unknown platform: ${packager.platform}`);
                }
            }();
            if (format.startsWith(&#x22;tar.&#x22;)) {
                yield (0, (_archive || _load_archive()).tar)(packager.config.compression, format, outFile, appOutDir, isMac);
            } else {
                yield (0, (_archive || _load_archive()).archive)(packager.config.compression, format, outFile, appOutDir);
            }
            packager.dispatchArtifactCreated(outFile, _this, (_electronBuilderCore || _load_electronBuilderCore()).Arch.x64, isMac
 ? packager.generateName2(format, &#x22;mac&#x22;, true) : packager.generateName(format, arch, true, packager.platform === (_electronBuilderCore
 || _load_electronBuilderCore()).Platform.WINDOWS ? &#x22;win&#x22; : null));
        })();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            list.push(name);
        }
    }
    return list;
}
function createCommonTarget(target, outDir, packager) {
    if (archiveTargets.has(target)) {
        return new (_ArchiveTarget || _load_ArchiveTarget()).<span class="apidocCodeKeywordSpan">ArchiveTarget</span>(target, outDir
, packager);
    } else if (target === (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET) {
        return new NoOpTarget((_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET);
    } else {
        throw new Error(`Unknown target: ${target}`);
    }
}
class NoOpTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.LinuxTargetHelper" id="apidoc.module.electron-builder.LinuxTargetHelper">module electron-builder.LinuxTargetHelper</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.LinuxTargetHelper.LinuxTargetHelper" id="apidoc.element.electron-builder.LinuxTargetHelper.LinuxTargetHelper">
        function <span class="apidocSignatureSpan">electron-builder.</span>LinuxTargetHelper
        <span class="apidocSignatureSpan">(packager)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class LinuxTargetHelper {
    constructor(packager) {
        this.packager = packager;
        this.maxIconPath = null;
        this.icons = this.computeDesktopIcons();
    }
    // must be name without spaces and other special characters, but not product name used
    computeDesktopIcons() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = _this.packager;
            let customIconSetDir = packager.platformSpecificBuildOptions.icon;
            if (customIconSetDir != null) {
                let iconDir = _path.resolve(packager.buildResourcesDir, customIconSetDir);
                const stat = yield (0, (_fs || _load_fs()).statOrNull)(iconDir);
                if (stat == null || !stat.isDirectory()) {
                    iconDir = _path.resolve(packager.projectDir, customIconSetDir);
                }
                try {
                    return yield _this.iconsFromDir(iconDir);
                } catch (e) {
                    if (e.code === &#x22;ENOENT&#x22;) {
                        throw new Error(`Icon set directory ${iconDir} doesn&#x27;t exist`);
                    } else if (e.code === &#x22;ENOTDIR&#x22;) {
                        throw new Error(`linux.icon must be set to an icon set directory, but ${iconDir} is not a directory. Please
 see https://github.com/electron-userland/electron-builder/wiki/Options#LinuxBuildOptions-icon`);
                    } else {
                        throw e;
                    }
                }
            }
            const resourceList = yield packager.resourceList;
            if (resourceList.indexOf(&#x22;icons&#x22;) !== -1) {
                return yield _this.iconsFromDir(_path.join(packager.buildResourcesDir, &#x22;icons&#x22;));
            } else {
                const iconDir = yield packager.getTempFile(&#x22;linux.iconset&#x22;);
                (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(iconDir);
                return yield _this.createFromIcns(iconDir);
            }
        })();
    }
    iconsFromDir(iconDir) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const mappings = [];
            let maxSize = 0;
            for (const file of yield (0, (_fsExtraP || _load_fsExtraP()).readdir)(iconDir)) {
                if (file.endsWith(&#x22;.png&#x22;) || file.endsWith(&#x22;.PNG&#x22;)) {
                    // If parseInt encounters a character that is not a numeral in the specified radix,
                    // it returns the integer value parsed up to that point
                    try {
                        let sizeString = file.match(/\d+/);
                        const size = sizeString == null ? 0 : parseInt(sizeString[0], 10);
                        if (size &#x3e; 0) {
                            const iconPath = `${iconDir}/${file}`;
                            mappings.push([iconPath, `${size}x${size}/apps/${_this2.packager.executableName}.png`]);
                            if (size &#x3e; maxSize) {
                                maxSize = size;
                                _this2.maxIconPath = iconPath;
                            }
                        }
                    } catch (e) {
                        console.error(e);
                    }
                }
            }
            if (mappings.length === 0) {
                throw new Error(`Icon set directory ${iconDir} doesn&#x27;t contain icons`);
            }
            return mappings;
        })();
    }
    getIcns() {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const build = _this3.packager.config;
            let iconPath = (build.mac || {}).icon || build.icon;
            if (iconPath != null &#x26;&#x26; !iconPath.endsWith(&#x22;.icns&#x22;)) {
                iconPath += &#x22;.icns&#x22;;
            }
            return iconPath == null ? yield _this3.packager.getDefaultIcon(&#x22;icns&#x22;) : _path.resolve(_this3.packager.projectDir, iconPath
);
        })();
    }
    getDescription(options) {
        return options.de ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
get defaultTarget() {
    return [&#x22;appimage&#x22;];
}
createTargets(targets, mapper, cleanupTasks) {
    let helper;
    const getHelper = () =&#x3e; {
        if (helper == null) {
            helper = new (_LinuxTargetHelper || _load_LinuxTargetHelper()).<span class="apidocCodeKeywordSpan">LinuxTargetHelper
</span>(this);
        }
        return helper;
    };
    for (const name of targets) {
        if (name === (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET) {
            continue;
        }
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.PublishManager" id="apidoc.module.electron-builder.PublishManager">module electron-builder.PublishManager</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.PublishManager.PublishManager" id="apidoc.element.electron-builder.PublishManager.PublishManager">
        function <span class="apidocSignatureSpan">electron-builder.</span>PublishManager
        <span class="apidocSignatureSpan">(packager, publishOptions, cancellationToken)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PublishManager {
    constructor(packager, publishOptions, cancellationToken) {
        this.publishOptions = publishOptions;
        this.cancellationToken = cancellationToken;
        this.nameToPublisher = new Map();
        this.publishTasks = [];
        this.errors = [];
        this.isPublish = false;
        this.progress = process.stdout.isTTY ? new (_multiProgress || _load_multiProgress()).MultiProgress() : null;
        if (!(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isPullRequest)()) {
            if (publishOptions.publish === undefined) {
                if (process.env.npm_lifecycle_event === &#x22;release&#x22;) {
                    publishOptions.publish = &#x22;always&#x22;;
                } else {
                    const tag = getCiTag();
                    if (tag != null) {
                        (0, (_log || _load_log()).log)(`Tag ${tag} is defined, so artifacts will be published`);
                        publishOptions.publish = &#x22;onTag&#x22;;
                    } else if ((_isCi || _load_isCi()).default) {
                        (0, (_log || _load_log()).log)(&#x22;CI detected, so artifacts will be published if draft release exists&#x22;);
                        publishOptions.publish = &#x22;onTagOrDraft&#x22;;
                    }
                }
            }
            if (publishOptions.publish != null &#x26;&#x26; publishOptions.publish !== &#x22;never&#x22;) {
                this.isPublish = publishOptions.publish !== &#x22;onTag&#x22; || getCiTag() != null;
            }
        } else if (publishOptions.publish !== &#x22;never&#x22;) {
            (0, (_log || _load_log()).log)(&#x22;Current build is a part of pull request, publishing will be skipped&#x22;);
        }
        packager.addAfterPackHandler((() =&#x3e; {
            var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (event) {
                const packager = event.packager;
                if (event.electronPlatformName === &#x22;darwin&#x22;) {
                    if (!event.targets.some(function (it) {
                        return it.name === &#x22;zip&#x22;;
                    })) {
                        return;
                    }
                } else if (packager.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS) {
                    if (!event.targets.some(function (it) {
                        return isSuitableWindowsTarget(it);
                    })) {
                        return;
                    }
                } else {
                    return;
                }
                const publishConfigs = yield getPublishConfigsForUpdateInfo(packager, (yield getPublishConfigs(packager, null, event
.arch)), event.arch);
                if (publishConfigs == null || publishConfigs.length === 0) {
                    return;
                }
                let publishConfig = publishConfigs[0];
                if (packager.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS) {
                    const publisherName = yield packager.computedPublisherName.value;
                    if (publisherName != null) {
                        publishConfig = Object.assign({ publisherName: publisherName }, publishConfig);
                    }
                }
                yield (0, (_fsExtraP || _load_fsExtraP()).writeFile)(_path.join(packager.getResourcesDir(event.appOutDir), &#x22;app-
update.yml&#x22;), (0, (_jsYaml || _load_jsYaml()).safeDump)(publishConfig));
            });

            return function (_x) {
                return _ref.apply(this, arguments);
            };
        })());
        packager.artifactCreated(event =&#x3e; this.addTask(this.artifactCreated(event)));
    }
    artifactCreated(event) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = event.packager;
            const target = event.target;
            const publishConfigs = event.publishConfig == null ? yield getPublishConfigs(packager, target == null ? null : target
.options, event.arch) : [event.publishConfig];
            const eventFile = ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// because artifact event maybe dispatched several times for different publish providers
const artifactPaths = new Set();
packager.artifactCreated(function (event) {
    if (event.file != null) {
        artifactPaths.add(event.file);
    }
});
const publishManager = new (_PublishManager || _load_PublishManager()).<span class="apidocCodeKeywordSpan">PublishManager</span>(
packager, options, cancellationToken);
const buildPromise = packager.build().then(function () {
    return Array.from(artifactPaths);
});
process.on(&#x22;SIGINT&#x22;, function () {
    (0, (_log || _load_log()).warn)(&#x22;Cancelled by SIGINT&#x22;);
    cancellationToken.cancel();
    publishManager.cancelTasks();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.PublishManager.computeDownloadUrl" id="apidoc.element.electron-builder.PublishManager.computeDownloadUrl">
        function <span class="apidocSignatureSpan">electron-builder.PublishManager.</span>computeDownloadUrl
        <span class="apidocSignatureSpan">(publishConfig, fileName, packager)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function computeDownloadUrl(publishConfig, fileName, packager) {
    if (publishConfig.provider === &#x22;generic&#x22;) {
        const baseUrlString = publishConfig.url;
        if (fileName == null) {
            return baseUrlString;
        }
        const baseUrl = (_url || _load_url()).parse(baseUrlString);
        return (_url || _load_url()).format(Object.assign({}, baseUrl, { pathname: _path.posix.resolve(baseUrl.pathname || &#x22;/&#x22;,
encodeURI(fileName)) }));
    }
    let baseUrl;
    if (publishConfig.provider === &#x22;s3&#x22;) {
        baseUrl = (0, (_publishOptions || _load_publishOptions()).s3Url)(publishConfig);
    } else {
        const gh = publishConfig;
        baseUrl = `${(0, (_publishOptions || _load_publishOptions()).githubUrl)(gh)}/${gh.owner}/${gh.repo}/releases/download/${
gh.vPrefixedTagName === false ? &#x22;&#x22; : &#x22;v&#x22;}${packager.appInfo.version}`;
    }
    if (fileName == null) {
        return baseUrl;
    }
    return `${baseUrl}/${encodeURI(fileName)}`;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.PublishManager.createPublisher" id="apidoc.element.electron-builder.PublishManager.createPublisher">
        function <span class="apidocSignatureSpan">electron-builder.PublishManager.</span>createPublisher
        <span class="apidocSignatureSpan">(context, version, publishConfig, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPublisher(context, version, publishConfig, options) {
    const provider = publishConfig.provider;
    switch (provider) {
        case &#x22;github&#x22;:
            return new (_gitHubPublisher || _load_gitHubPublisher()).GitHubPublisher(context, publishConfig, version, options);
        case &#x22;bintray&#x22;:
            return new (_BintrayPublisher || _load_BintrayPublisher()).BintrayPublisher(context, publishConfig, version, options
);
        case &#x22;generic&#x22;:
            return null;
        default:
            const clazz = requireProviderClass(provider);
            return clazz == null ? null : new clazz(context, publishConfig);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.PublishManager.getPublishConfigs" id="apidoc.element.electron-builder.PublishManager.getPublishConfigs">
        function <span class="apidocSignatureSpan">electron-builder.PublishManager.</span>getPublishConfigs
        <span class="apidocSignatureSpan">(_x12, _x13, _x14)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPublishConfigs(_x12, _x13, _x14) {
    return _ref5.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.PublishManager.getPublishConfigsForUpdateInfo" id="apidoc.element.electron-builder.PublishManager.getPublishConfigsForUpdateInfo">
        function <span class="apidocSignatureSpan">electron-builder.PublishManager.</span>getPublishConfigsForUpdateInfo
        <span class="apidocSignatureSpan">(_x2, _x3, _x4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPublishConfigsForUpdateInfo(_x2, _x3, _x4) {
    return _ref2.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.WebInstallerTarget" id="apidoc.module.electron-builder.WebInstallerTarget">module electron-builder.WebInstallerTarget</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.WebInstallerTarget.WebInstallerTarget" id="apidoc.element.electron-builder.WebInstallerTarget.WebInstallerTarget">
        function <span class="apidocSignatureSpan">electron-builder.</span>WebInstallerTarget
        <span class="apidocSignatureSpan">(_nsis || _load_nsis()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebInstallerTarget extends (_nsis || _load_nsis()).NsisTarget {
    constructor(packager, outDir, targetName, packageHelper) {
        super(packager, outDir, targetName, packageHelper);
    }
    get isWebInstaller() {
        return true;
    }
    configureDefines(oneClick, defines) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            //noinspection ES6MissingAwait
            yield (_nsis || _load_nsis()).NsisTarget.prototype.configureDefines.call(_this, oneClick, defines);
            const packager = _this.packager;
            const options = _this.options;
            let appPackageUrl = options.appPackageUrl;
            if (appPackageUrl == null) {
                const publishConfigs = yield (0, (_PublishManager || _load_PublishManager()).getPublishConfigsForUpdateInfo)(packager
, (yield (0, (_PublishManager || _load_PublishManager()).getPublishConfigs)(packager, _this.options, null)), null);
                if (publishConfigs == null || publishConfigs.length === 0) {
                    throw new Error(&#x22;Cannot compute app package download URL&#x22;);
                }
                appPackageUrl = (0, (_PublishManager || _load_PublishManager()).computeDownloadUrl)(publishConfigs[0], null, packager
);
                defines.APP_PACKAGE_URL_IS_INCOMLETE = null;
            }
            defines.APP_PACKAGE_URL = appPackageUrl;
        })();
    }
    get installerFilenamePattern() {
        return &#x22;${productName} Web Setup ${version}.${ext}&#x22;;
    }
    generateGitHubInstallerName() {
        const appInfo = this.packager.appInfo;
        const classifier = appInfo.name.toLowerCase() === appInfo.name ? &#x22;web-setup&#x22; : &#x22;WebSetup&#x22;;
        return `${appInfo.name}-${classifier}-${appInfo.version}.exe`;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        for (const name of targets) {
if (name === (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET) {
    continue;
}
if (name === &#x22;nsis&#x22; || name === &#x22;portable&#x22;) {
    mapper(name, outDir =&#x3e; new (_nsis || _load_nsis()).NsisTarget(this, outDir, name, getHelper()));
} else if (name === &#x22;nsis-web&#x22;) {
    mapper(name, outDir =&#x3e; new (_WebInstallerTarget || _load_WebInstallerTarget()).<span class="apidocCodeKeywordSpan">WebInstallerTarget
</span>(this, outDir, name, getHelper()));
} else {
    const targetClass = (() =&#x3e; {
        switch (name) {
            case &#x22;squirrel&#x22;:
                try {
                    return require(&#x22;electron-builder-squirrel-windows&#x22;).default;
                } catch (e) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.appImage" id="apidoc.module.electron-builder.appImage">module electron-builder.appImage</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.appImage.default" id="apidoc.element.electron-builder.appImage.default">
        function <span class="apidocSignatureSpan">electron-builder.appImage.</span>default
        <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AppImageTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
    constructor(ignored, packager, helper, outDir) {
        super(&#x22;appImage&#x22;);
        this.packager = packager;
        this.helper = helper;
        this.outDir = outDir;
        this.options = Object.assign({}, this.packager.platformSpecificBuildOptions, this.packager.config[this.name]);
        // we add X-AppImage-BuildId to ensure that new desktop file will be installed
        this.desktopEntry = (_bluebirdLst2 || _load_bluebirdLst2()).default.promisify((_uuid || _load_uuid()).v1)({ mac: false }).
then(uuid =&#x3e; helper.computeDesktopEntry(this.options, &#x22;AppRun&#x22;, null, {
            &#x22;X-AppImage-Version&#x22;: `${packager.appInfo.buildVersion}`,
            &#x22;X-AppImage-BuildId&#x22;: uuid
        }));
    }
    build(appOutDir, arch) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            (0, (_log || _load_log()).log)(`Building AppImage for arch ${(_electronBuilderCore || _load_electronBuilderCore()).Arch
[arch]}`);
            const packager = _this.packager;
            // avoid spaces in the file name
            const resultFile = _path.join(_this.outDir, packager.generateName(&#x22;AppImage&#x22;, arch, true));
            yield (0, (_fs || _load_fs()).unlinkIfExists)(resultFile);
            const appImagePath = yield appImagePathPromise;
            const desktopFile = yield _this.desktopEntry;
            const args = [&#x22;-joliet&#x22;, &#x22;on&#x22;, &#x22;-volid&#x22;, &#x22;AppImage&#x22;, &#x22;-dev&#x22;, resultFile, &#x22;-padding&#x22;, &#x22;0&#x22;, &#x22;-map&#x22;, appOutDir, &#x22;/usr/bin
&#x22;, &#x22;-map&#x22;, _path.join(__dirname, &#x22;..&#x22;, &#x22;..&#x22;, &#x22;templates&#x22;, &#x22;linux&#x22;, &#x22;AppRun.sh&#x22;), &#x22;/AppRun&#x22;,
            // we get executable name in the AppRun by desktop file name, so, must be named as executable
            &#x22;-map&#x22;, desktopFile, `/${_this.packager.executableName}.desktop`];
            for (const _ref of yield _this.helper.icons) {
                var _ref2 = _slicedToArray(_ref, 2);

                const from = _ref2[0];
                const to = _ref2[1];

                args.push(&#x22;-map&#x22;, from, `/usr/share/icons/default/${to}`);
            }
            // must be after this.helper.icons call
            if (_this.helper.maxIconPath == null) {
                throw new Error(&#x22;Icon is not provided&#x22;);
            }
            args.push(&#x22;-map&#x22;, _this.helper.maxIconPath, &#x22;/.DirIcon&#x22;);
            if (arch === (_electronBuilderCore || _load_electronBuilderCore()).Arch.x64) {
                const libDir = yield (0, (_binDownload || _load_binDownload()).getBin)(&#x22;AppImage-packages&#x22;, &#x22;10.03.17&#x22;, &#x22;https://
bintray.com/electron-userland/bin/download_file?file_path=AppImage-packages-10.03.17-x64.7z&#x22;, &#x22;172f9977fe9b24d35091d26ecbfebe2a14d96516a9c903e109e12b2a929042fe
&#x22;);
                args.push(&#x22;-map&#x22;, libDir, &#x22;/usr/lib&#x22;);
            }
            args.push(&#x22;-chown_r&#x22;, &#x22;0&#x22;, &#x22;/&#x22;, &#x22;--&#x22;);
            args.push(&#x22;-zisofs&#x22;, `level=${process.env.ELECTRON_BUILDER_COMPRESSION_LEVEL || (packager.config.compression === &#x22;store
&#x22; ? &#x22;0&#x22; : &#x22;9&#x22;)}:block_size=128k:by_magic=off`);
            args.push(&#x22;set_filter_r&#x22;, &#x22;--zisofs&#x22;, &#x22;/&#x22;);
            if (_this.packager.packagerOptions.effectiveOptionComputed != null &#x26;&#x26; (yield _this.packager.packagerOptions.effectiveOptionComputed
([args, desktopFile]))) {
                return;
            }
            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(process.arch !== &#x22;x64&#x22; || process.env.USE_SYSTEM_XORRISO
 === &#x22;true&#x22; || process.env.USE_SYSTEM_XORRISO === &#x22;&#x22; ? &#x22;xorriso&#x22; : _path.join(appImagePath, &#x22;xorriso&#x22;), args, {
                maxBuffer: 2 * 1024 * 1024
            });
            yield new (_bluebirdLst2 || _load_bluebirdLst2()).default(function (resolve, reject) {
                const rd = (0, (_fsExtraP || _load_fsExtraP()).createReadStream)(_path.join(appImagePath, arch === (_electronBuilderCore
 || _load_electronBuilderCore()).Arch.ia32 ? &#x22;32&#x22; : &#x22;64&#x22;, &#x22;runtime&#x22;));
                rd.on(&#x22;error&#x22;, reject);
                const wr = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(resultFi ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
headerPickle.writeString(JSON.stringify(this.fs.header));
const headerBuf = headerPickle.toBuffer();
const sizePickle = pickle.createEmpty();
sizePickle.writeUInt32(headerBuf.length);
const sizeBuf = sizePickle.toBuffer();
const transformedFiles = this.transformedFiles;
const writeStream = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(this.outFile);
return new (_bluebirdLst2 || _load_bluebirdLst2()).<span class="apidocCodeKeywordSpan">default</span>((resolve, reject) =&#x3e; {
    writeStream.on(&#x22;error&#x22;, reject);
    writeStream.on(&#x22;close&#x22;, resolve);
    writeStream.write(sizeBuf);
    const w = index =&#x3e; {
        let data;
        while (true) {
            if (index &#x3e;= files.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.appInfo" id="apidoc.module.electron-builder.appInfo">module electron-builder.appInfo</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.appInfo.AppInfo" id="apidoc.element.electron-builder.appInfo.AppInfo">
        function <span class="apidocSignatureSpan">electron-builder.appInfo.</span>AppInfo
        <span class="apidocSignatureSpan">(metadata, info, buildVersion)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AppInfo {
    constructor(metadata, info, buildVersion) {
        this.metadata = metadata;
        this.info = info;
        this.description = (0, (_electronBuilderUtil || _load_electronBuilderUtil()).smarten)(this.metadata.description || &#x22;&#x22;);
        this.version = metadata.version;
        this.buildNumber = this.config.buildVersion || process.env.TRAVIS_BUILD_NUMBER || process.env.APPVEYOR_BUILD_NUMBER || process
.env.CIRCLE_BUILD_NUM || process.env.BUILD_NUMBER;
        if ((0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(buildVersion)) {
            buildVersion = this.version;
            if (!(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(this.buildNumber)) {
                buildVersion += `.${this.buildNumber}`;
            }
            this.buildVersion = buildVersion;
        } else {
            this.buildVersion = buildVersion;
        }
        this.productName = this.config.productName || metadata.productName || metadata.name;
        this.productFilename = (0, (_sanitizeFilename || _load_sanitizeFilename()).default)(this.productName);
    }
    get config() {
        return this.info.config;
    }
    get versionInWeirdWindowsForm() {
        const parsedVersion = new (_semver || _load_semver()).SemVer(this.version);
        return `${parsedVersion.major}.${parsedVersion.minor}.${parsedVersion.patch}.${this.buildNumber || &#x22;0&#x22;}`;
    }
    get companyName() {
        return this.metadata.author.name;
    }
    get id() {
        let appId;
        if (this.config.appId != null) {
            appId = this.config.appId;
        }
        const generateDefaultAppId = () =&#x3e; {
            return `com.electron.${this.metadata.name.toLowerCase()}`;
        };
        if (appId != null &#x26;&#x26; (appId === &#x22;your.id&#x22; || (0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(
appId))) {
            const incorrectAppId = appId;
            appId = generateDefaultAppId();
            (0, (_log || _load_log()).warn)(`Do not use &#x22;${incorrectAppId}&#x22; as appId, &#x22;${appId}&#x22; will be used instead`);
        }
        return appId == null ? generateDefaultAppId() : appId;
    }
    get name() {
        return this.metadata.name;
    }
    get copyright() {
        const copyright = this.config.copyright;
        if (copyright != null) {
            return copyright;
        }
        return `Copyright © ${new Date().getFullYear()} ${this.metadata.author.name || this.productName}`;
    }
    computePackageUrl() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const url = _this.metadata.homepage;
            if (url != null) {
                return url;
            }
            const info = yield _this.info.repositoryInfo;
            return info == null || info.type !== &#x22;github&#x22; ? null : `https://${info.domain}/${info.user}/${info.project}`;
        })();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.codeSigningInfo = (0, (_codeSign || _load_codeSign()).createKeychain)(info.tempDirManager, this.packagerOptions.cscLink
, this.getCscPassword(), this.packagerOptions.cscInstallerLink, this.packagerOptions.cscInstallerKeyPassword);
}
    }
    get defaultTarget() {
return [&#x22;zip&#x22;, &#x22;dmg&#x22;];
    }
    prepareAppInfo(appInfo) {
return new (_appInfo || _load_appInfo()).<span class="apidocCodeKeywordSpan">AppInfo</span>(appInfo.metadata, this.info, this.platformSpecificBuildOptions
.bundleVersion);
    }
    getIconPath() {
var _this = this;

return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
    let iconPath = _this.platformSpecificBuildOptions.icon || _this.config.icon;
    if (iconPath != null &#x26;&#x26; !iconPath.endsWith(&#x22;.icns&#x22;)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.appx" id="apidoc.module.electron-builder.appx">module electron-builder.appx</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.appx.default" id="apidoc.element.electron-builder.appx.default">
        function <span class="apidocSignatureSpan">electron-builder.appx.</span>default
        <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AppXTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
    constructor(packager, outDir) {
        super(&#x22;appx&#x22;);
        this.packager = packager;
        this.outDir = outDir;
        this.options = Object.assign({}, this.packager.platformSpecificBuildOptions, this.packager.config.appx);
        const osVersion = (0, (_os || _load_os()).release)();
        if (process.platform !== &#x22;win32&#x22; || parseInt(osVersion.substring(0, osVersion.indexOf(&#x22;.&#x22;)), 10) &#x3c; 10) {
            throw new Error(&#x22;AppX is supported only on Windows 10&#x22;);
        }
    }
    // no flatten - use asar or npm 3 or yarn
    build(appOutDir, arch) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = _this.packager;
            if ((yield packager.cscInfo) == null) {
                throw new Error(&#x22;AppX package must be signed, but certificate is not set, please see https://github.com/electron
-userland/electron-builder/wiki/Code-Signing&#x22;);
            }
            let publisher = _this.options.publisher;
            if (publisher == null) {
                const computed = yield packager.computedPublisherName.value;
                if (computed != null) {
                    publisher = `CN=${computed[0]}`;
                }
                if (publisher == null) {
                    throw new Error(&#x22;Please specify appx.publisher&#x22;);
                }
            }
            const appInfo = packager.appInfo;
            const preAppx = _path.join(_this.outDir, `pre-appx-${(0, (_electronBuilderCore || _load_electronBuilderCore()).getArchSuffix
)(arch)}`);
            yield (0, (_fsExtraP || _load_fsExtraP()).emptyDir)(preAppx);
            const vendorPath = yield (0, (_windowsCodeSign || _load_windowsCodeSign()).getSignVendorPath)();
            const templatePath = _path.join(__dirname, &#x22;..&#x22;, &#x22;..&#x22;, &#x22;templates&#x22;, &#x22;appx&#x22;);
            const safeName = (0, (_sanitizeFilename || _load_sanitizeFilename()).default)(appInfo.name);
            const resourceList = yield packager.resourceList;
            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([(_bluebirdLst2 || _load_bluebirdLst2()).default.map([&#x22;44x44
&#x22;, &#x22;50x50&#x22;, &#x22;150x150&#x22;, &#x22;310x150&#x22;], function (size) {
                const target = _path.join(preAppx, &#x22;assets&#x22;, `${safeName}.${size}.png`);
                if (resourceList.indexOf(`${size}.png`) !== -1) {
                    return (0, (_fsExtraP || _load_fsExtraP()).copy)(_path.join(packager.buildResourcesDir, `${size}.png`), target
);
                }
                return (0, (_fsExtraP || _load_fsExtraP()).copy)(_path.join(vendorPath, &#x22;appxAssets&#x22;, `SampleAppx.${size}.png`),
target);
            }), (0, (_fs || _load_fs()).copyDir)(appOutDir, _path.join(preAppx, &#x22;app&#x22;)), _this.writeManifest(templatePath, preAppx
, safeName, arch, publisher)]);
            const destination = _path.join(_this.outDir, packager.generateName(&#x22;appx&#x22;, arch, false));
            const args = [&#x22;pack&#x22;, &#x22;/o&#x22;, &#x22;/d&#x22;, preAppx, &#x22;/p&#x22;, destination];
            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(_this.options.makeappxArgs, function (it) {
                return args.push.apply(args, _toConsumableArray(it));
            });
            // wine supports only ia32 binary in any case makeappx crashed on wine
            // await execWine(path.join(await getSignVendorPath(), &#x22;windows-10&#x22;, process.platform === &#x22;win32&#x22; ? process.arch : &#x22;
ia32&#x22;, &#x22;makeappx.exe&#x22;), args)
            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).spawn)(_path.join(vendorPath, &#x22;windows-10&#x22;, arch === (
_electronBuilderCore || _load_electronBuilderCore()).Arch.ia32 ? &#x22;ia32&#x22; : &#x22;x64&#x22;, &#x22;makeappx.exe&#x22;), args);
            yield packager.sign(destination);
            packager.dispatchArtifactCreated(destination, _this, arch, packager.generateName(&#x22;appx&#x22;, arch, true));
        })();
    }
    writeManifest(templatePath, preAppx, safeName, arch, publisher) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLs ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
headerPickle.writeString(JSON.stringify(this.fs.header));
const headerBuf = headerPickle.toBuffer();
const sizePickle = pickle.createEmpty();
sizePickle.writeUInt32(headerBuf.length);
const sizeBuf = sizePickle.toBuffer();
const transformedFiles = this.transformedFiles;
const writeStream = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(this.outFile);
return new (_bluebirdLst2 || _load_bluebirdLst2()).<span class="apidocCodeKeywordSpan">default</span>((resolve, reject) =&#x3e; {
    writeStream.on(&#x22;error&#x22;, reject);
    writeStream.on(&#x22;close&#x22;, resolve);
    writeStream.write(sizeBuf);
    const w = index =&#x3e; {
        let data;
        while (true) {
            if (index &#x3e;= files.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.asar" id="apidoc.module.electron-builder.asar">module electron-builder.asar</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.asar.AsarFilesystem" id="apidoc.element.electron-builder.asar.AsarFilesystem">
        function <span class="apidocSignatureSpan">electron-builder.asar.</span>AsarFilesystem
        <span class="apidocSignatureSpan">(src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AsarFilesystem {
    constructor(src) {
        let header = arguments.length &#x3e; 1 &#x26;&#x26; arguments[1] !== undefined ? arguments[1] : new Node();
        let headerSize = arguments.length &#x3e; 2 &#x26;&#x26; arguments[2] !== undefined ? arguments[2] : -1;

        this.src = src;
        this.header = header;
        this.headerSize = headerSize;
        this.offset = UINT64(0);
        if (this.header.files == null) {
            this.header.files = {};
        }
    }
    searchNodeFromDirectory(p) {
        let node = this.header;
        for (const dir of p.split(_path.sep)) {
            if (dir !== &#x22;.&#x22;) {
                node = node.files[dir];
            }
        }
        return node;
    }
    getOrCreateNode(p) {
        p = _path.relative(this.src, p);
        if (p == null || p.length === 0) {
            return this.header;
        }
        const name = _path.basename(p);
        const dirNode = this.searchNodeFromDirectory(_path.dirname(p));
        if (dirNode.files == null) {
            dirNode.files = {};
        }
        let result = dirNode.files[name];
        if (result == null) {
            result = new Node();
            dirNode.files[name] = result;
        }
        return result;
    }
    insertDirectory(p) {
        let unpacked = arguments.length &#x3e; 1 &#x26;&#x26; arguments[1] !== undefined ? arguments[1] : false;

        const node = this.getOrCreateNode(p);
        node.files = {};
        if (unpacked) {
            node.unpacked = unpacked;
        }
        return node.files;
    }
    insertFileNode(node, stat, file) {
        if (node.size &#x3e; 4294967295) {
            throw new Error(`${file}: file size can not be larger than 4.2GB`);
        }
        node.offset = this.offset.toString();
        if (process.platform !== &#x22;win32&#x22; &#x26;&#x26; stat.mode &#x26; 0o100) {
            node.executable = true;
        }
        this.offset.add(UINT64(node.size));
    }
    getNode(p) {
        const node = this.searchNodeFromDirectory(_path.dirname(p));
        return node.files[_path.basename(p)];
    }
    getFile(p) {
        let followLinks = arguments.length &#x3e; 1 &#x26;&#x26; arguments[1] !== undefined ? arguments[1] : true;

        const info = this.getNode(p);
        // if followLinks is false we don&#x27;t resolve symlinks
        return followLinks &#x26;&#x26; info.link != null ? this.getFile(info.link) : info;
    }
    readJson(file) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            return JSON.parse((yield _this.readFile(file)).toString());
        })();
    }
    readFile(file) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            return yield readFileFromAsar(_this2, file, _this2.getFile(file));
        })();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
class AsarPackager {
constructor(src, destination, options, unpackPattern, transformer) {
    this.src = src;
    this.options = options;
    this.unpackPattern = unpackPattern;
    this.transformer = transformer;
    this.fs = new (_asar || _load_asar()).<span class="apidocCodeKeywordSpan">AsarFilesystem</span>(this.src);
    this.metadata = new Map();
    this.outFile = _path.join(destination, &#x22;app.asar&#x22;);
}
// sort files to minimize file change (i.e. asar file is not changed dramatically on small change)
pack(filter, isElectronCompile) {
    var _this = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.asar.Node" id="apidoc.element.electron-builder.asar.Node">
        function <span class="apidocSignatureSpan">electron-builder.asar.</span>Node
        <span class="apidocSignatureSpan">{{signature}}</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Node {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.asar.readAsar" id="apidoc.element.electron-builder.asar.readAsar">
        function <span class="apidocSignatureSpan">electron-builder.asar.</span>readAsar
        <span class="apidocSignatureSpan">(_x5)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readAsar(_x5) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.asar.readAsarJson" id="apidoc.element.electron-builder.asar.readAsarJson">
        function <span class="apidocSignatureSpan">electron-builder.asar.</span>readAsarJson
        <span class="apidocSignatureSpan">(_x6, _x7)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readAsarJson(_x6, _x7) {
    return _ref2.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.asarUtil" id="apidoc.module.electron-builder.asarUtil">module electron-builder.asarUtil</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.asarUtil.AsarPackager" id="apidoc.element.electron-builder.asarUtil.AsarPackager">
        function <span class="apidocSignatureSpan">electron-builder.asarUtil.</span>AsarPackager
        <span class="apidocSignatureSpan">(src, destination, options, unpackPattern, transformer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AsarPackager {
    constructor(src, destination, options, unpackPattern, transformer) {
        this.src = src;
        this.options = options;
        this.unpackPattern = unpackPattern;
        this.transformer = transformer;
        this.fs = new (_asar || _load_asar()).AsarFilesystem(this.src);
        this.metadata = new Map();
        this.outFile = _path.join(destination, &#x22;app.asar&#x22;);
    }
    // sort files to minimize file change (i.e. asar file is not changed dramatically on small change)
    pack(filter, isElectronCompile) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const metadata = _this.metadata;
            let files = yield (0, (_fs || _load_fs()).walk)(_this.src, filter, function (file, fileStat) {
                metadata.set(file, fileStat);
                if (fileStat.isSymbolicLink()) {
                    return (0, (_fsExtraP || _load_fsExtraP()).readlink)(file).then(function (linkTarget) {
                        // http://unix.stackexchange.com/questions/105637/is-symlinks-target-relative-to-the-destinations-parent
-directory-and-if-so-wh
                        const resolved = _path.resolve(_path.dirname(file), linkTarget);
                        const link = _path.relative(_this.src, linkTarget);
                        if (link.startsWith(&#x22;..&#x22;)) {
                            // outside of project, linked module (https://github.com/electron-userland/electron-builder/issues/675
)
                            return (0, (_fsExtraP || _load_fsExtraP()).stat)(resolved).then(function (targetFileStat) {
                                metadata.set(file, targetFileStat);
                                return targetFileStat;
                            });
                        } else {
                            fileStat.relativeLink = link;
                        }
                        return null;
                    });
                }
                return null;
            });
            // transform before electron-compile to avoid filtering (cache files in any case should be not transformed)
            const transformer = _this.transformer;
            _this.transformedFiles = yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(files, function (it) {
                return metadata.get(it).isFile() ? transformer(it) : null;
            }, (_fs || _load_fs()).CONCURRENCY);
            if (isElectronCompile) {
                files = yield _this.compileUsingElectronCompile(files);
            }
            yield _this.createPackageFromFiles(_this.options.ordering == null ? files : yield _this.order(files));
        })();
    }
    compileUsingElectronCompile(files) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            (0, (_log || _load_log()).log)(&#x22;Compiling using electron-compile&#x22;);
            const metadata = _this2.metadata;
            const cacheDir = _path.join(_this2.src, &#x22;.cache&#x22;);
            // clear and create cache dir
            yield (0, (_fsExtraP || _load_fsExtraP()).emptyDir)(cacheDir);
            const compilerHost = yield (0, (_fileTransformer || _load_fileTransformer()).createElectronCompilerHost)(_this2.src,
cacheDir);
            const nextSlashIndex = _this2.src.length + 1;
            // pre-compute electron-compile to cache dir - we need to process only subdirectories, not direct files of app dir
            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(files, function (file) {
                if (file.indexOf(&#x22;/node_modules/&#x22;) !== -1 || file.indexOf(&#x22;/bower_components/&#x22;) !== -1 || !(file.indexOf(&#x22;/&#x22;, nextSlashIndex
) !== -1) // ignore not root files
                || !metadata.get(file).isFile()) {
                    return null;
                }
                return compilerHost.compile(file).then(function (it) {
                    return null;
                });
            }, (_fs || _load_fs()).CONCURRENCY);
            yield compilerHost.saveConfiguration(); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (_this2.info.isPrepackedAppAsar) {
    promise = (0, (_fs || _load_fs()).copyDir)(appDir, _path.join(resourcesPath), filter, transformer);
} else if (asarOptions == null) {
    promise = (0, (_fs || _load_fs()).copyDir)(appDir, _path.join(resourcesPath, &#x22;app&#x22;), filter, transformer);
} else {
    const unpackPattern = (0, (_fileMatcher || _load_fileMatcher()).getFileMatchers)(_this2.config, &#x22;asarUnpack&#x22;, appDir
, _path.join(resourcesPath, &#x22;app&#x22;), false, macroExpander, platformSpecificBuildOptions);
    const fileMatcher = unpackPattern == null ? null : unpackPattern[0];
    promise = new (_asarUtil || _load_asarUtil()).<span class="apidocCodeKeywordSpan">AsarPackager</span>(appDir, resourcesPath,
asarOptions, fileMatcher == null ? null : fileMatcher.createFilter(), transformer).pack(filter, isElectronCompile);
}
//noinspection ES6MissingAwait
const promises = [promise, (0, (_fs || _load_fs()).unlinkIfExists)(_path.join(resourcesPath, &#x22;default_app.asar&#x22;)), (0, (
_fs || _load_fs()).unlinkIfExists)(_path.join(appOutDir, &#x22;version&#x22;)), _this2.postInitApp(appOutDir)];
if (_this2.platform !== (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC) {
    promises.push((0, (_fsExtraP || _load_fsExtraP()).rename)(_path.join(appOutDir, &#x22;LICENSE&#x22;), _path.join(appOutDir, &#
x22;LICENSE.electron.txt&#x22;)).catch(function () {}));
}
yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all(promises);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.asarUtil.checkFileInArchive" id="apidoc.element.electron-builder.asarUtil.checkFileInArchive">
        function <span class="apidocSignatureSpan">electron-builder.asarUtil.</span>checkFileInArchive
        <span class="apidocSignatureSpan">(_x2, _x3, _x4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkFileInArchive(_x2, _x3, _x4) {
    return _ref2.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.builder" id="apidoc.module.electron-builder.builder">module electron-builder.builder</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.builder.build" id="apidoc.element.electron-builder.builder.build">
        function <span class="apidocSignatureSpan">electron-builder.builder.</span>build
        <span class="apidocSignatureSpan">(_x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function build(_x) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
&#x22;use strict&#x22;

const builder = require(&#x22;electron-builder&#x22;)
const Platform = builder.Platform

// Promise is returned
builder.<span class="apidocCodeKeywordSpan">build</span>({
targets: Platform.MAC.createTarget(),
config: {
 &#x22;//&#x22;: &#x22;build options, see https://goo.gl/ZhRfla&#x22;
}
})
.then(() =&#x3e; {
  // handle result
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.builder.createTargets" id="apidoc.element.electron-builder.builder.createTargets">
        function <span class="apidocSignatureSpan">electron-builder.builder.</span>createTargets
        <span class="apidocSignatureSpan">(platforms, type, arch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTargets(platforms, type, arch) {
    const targets = new Map();
    for (const platform of platforms) {
        const archs = platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC ? [(_electronBuilderCore ||
_load_electronBuilderCore()).Arch.x64] : arch === &#x22;all&#x22; ? [(_electronBuilderCore || _load_electronBuilderCore()).Arch.x64, (_electronBuilderCore
 || _load_electronBuilderCore()).Arch.ia32] : [(0, (_electronBuilderCore || _load_electronBuilderCore()).archFromString)(arch ==
null ? process.arch : arch)];
        const archToType = new Map();
        targets.set(platform, archToType);
        for (const arch of archs) {
            archToType.set(arch, type == null ? [] : [type]);
        }
    }
    return targets;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (target == null) {
        target = factory(outDir);
        nameToTarget.set(name, target);
    }
    result.push(target);
};
const targets = normalizeTargets(rawList, packager.defaultTarget);
packager.<span class="apidocCodeKeywordSpan">createTargets</span>(targets, mapper, cleanupTasks);
return result;
}
function normalizeTargets(targets, defaultTarget) {
const list = [];
for (const t of targets) {
    const name = t.toLowerCase().trim();
    if (name === (_electronBuilderCore || _load_electronBuilderCore()).DEFAULT_TARGET) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.builder.normalizeOptions" id="apidoc.element.electron-builder.builder.normalizeOptions">
        function <span class="apidocSignatureSpan">electron-builder.builder.</span>normalizeOptions
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalizeOptions(args) {
    if (args.targets != null) {
        return args;
    }
    let targets = new Map();
    function processTargets(platform, types) {
        function commonArch(currentIfNotSpecified) {
            if (platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC) {
                return args.x64 || currentIfNotSpecified ? [(_electronBuilderCore || _load_electronBuilderCore()).Arch.x64] : [];
            }
            const result = Array();
            if (args.x64) {
                result.push((_electronBuilderCore || _load_electronBuilderCore()).Arch.x64);
            }
            if (args.armv7l) {
                result.push((_electronBuilderCore || _load_electronBuilderCore()).Arch.armv7l);
            }
            if (args.ia32) {
                result.push((_electronBuilderCore || _load_electronBuilderCore()).Arch.ia32);
            }
            return result.length === 0 &#x26;&#x26; currentIfNotSpecified ? [(0, (_electronBuilderCore || _load_electronBuilderCore()).archFromString
)(process.arch)] : result;
        }
        if (args.platform != null) {
            throw new Error(`--platform cannot be used if --${platform.buildConfigurationKey} is passed`);
        }
        if (args.arch != null) {
            throw new Error(`--arch cannot be used if --${platform.buildConfigurationKey} is passed`);
        }
        let archToType = targets.get(platform);
        if (archToType == null) {
            archToType = new Map();
            targets.set(platform, archToType);
        }
        if (types.length === 0) {
            const defaultTargetValue = args.dir ? [(_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET] : [];
            for (const arch of commonArch(args.dir === true)) {
                archToType.set(arch, defaultTargetValue);
            }
            return;
        }
        for (const type of types) {
            const suffixPos = type.lastIndexOf(&#x22;:&#x22;);
            if (suffixPos &#x3e; 0) {
                (0, (_electronBuilderUtil || _load_electronBuilderUtil()).addValue)(archToType, (0, (_electronBuilderCore || _load_electronBuilderCore
()).archFromString)(type.substring(suffixPos + 1)), type.substring(0, suffixPos));
            } else {
                for (const arch of commonArch(true)) {
                    (0, (_electronBuilderUtil || _load_electronBuilderUtil()).addValue)(archToType, arch, type);
                }
            }
        }
    }
    if (args.mac != null) {
        processTargets((_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC, args.mac);
    }
    if (args.linux != null) {
        processTargets((_electronBuilderCore || _load_electronBuilderCore()).Platform.LINUX, args.linux);
    }
    if (args.win != null) {
        processTargets((_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS, args.win);
    }
    if (targets.size === 0) {
        if (args.platform == null &#x26;&#x26; args.arch == null) {
            processTargets((_electronBuilderCore || _load_electronBuilderCore()).Platform.current(), []);
        } else {
            targets = createTargets((0, (_packager || _load_packager()).normalizePlatforms)(args.platform), args.dir ? (_electronBuilderCore
 || _load_electronBuilderCore()).DIR_TARGET : null, args.arch);
        }
    }
    const result = Object.assign({}, args);
    result.targets = targets;
    delete result.dir;
    delete result.mac;
    delete result.linux;
    delete result.win;
    delete result.platform;
    delete result.arch;
    const r = result;
    delete r.em;
    delete r.m;
    delete r.o;
    delete r.l;
    delete r.w;
    delete r.windows;
    delete r.macos;
    delete r.$0;
    delete r._;
    delete r.version;
    delete r.help;
    delete result.ia32;
    delete result.x64;
    delete result.armv7l;
    if (result.project != null &#x26;&#x26; result.projectDir == null) {
        result.projectDir = result.project;
    }
    delete result.project;
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.cliOptions" id="apidoc.module.electron-builder.cliOptions">module electron-builder.cliOptions</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.cliOptions.createYargs" id="apidoc.element.electron-builder.cliOptions.createYargs">
        function <span class="apidocSignatureSpan">electron-builder.cliOptions.</span>createYargs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createYargs() {
    //noinspection ReservedWordAsName
    return (_yargs || _load_yargs()).default.example(&#x22;build -mwl&#x22;, &#x22;build for macOS, Windows and Linux&#x22;).example(&#x22;build --linux
deb tar.xz&#x22;, &#x22;build deb and tar.xz for Linux&#x22;).example(&#x22;build --win --ia32&#x22;, &#x22;build for Windows ia32&#x22;).example(&#x22;build --em.foo=bar
&#x22;, &#x22;set package.json property `foo` to `bar`&#x22;).example(&#x22;build --config.nsis.unicode=false&#x22;, &#x22;configure unicode options for NSIS&#x22;).
option(&#x22;mac&#x22;, {
        group: buildGroup,
        alias: [&#x22;m&#x22;, &#x22;o&#x22;, &#x22;macos&#x22;],
        describe: `Build for macOS, accepts target list (see ${(0, (_chalk || _load_chalk()).underline)(&#x22;https://goo.gl/HAnnq8&#x22;)}).`,
        type: &#x22;array&#x22;
    }).option(&#x22;linux&#x22;, {
        group: buildGroup,
        alias: &#x22;l&#x22;,
        describe: `Build for Linux, accepts target list (see ${(0, (_chalk || _load_chalk()).underline)(&#x22;https://goo.gl/O80IL2&#x22;)})`,
        type: &#x22;array&#x22;
    }).option(&#x22;win&#x22;, {
        group: buildGroup,
        alias: [&#x22;w&#x22;, &#x22;windows&#x22;],
        describe: `Build for Windows, accepts target list (see ${(0, (_chalk || _load_chalk()).underline)(&#x22;https://goo.gl/dL4i8i
&#x22;)})`,
        type: &#x22;array&#x22;
    }).option(&#x22;x64&#x22;, {
        group: buildGroup,
        describe: &#x22;Build for x64&#x22;,
        type: &#x22;boolean&#x22;
    }).option(&#x22;ia32&#x22;, {
        group: buildGroup,
        describe: &#x22;Build for ia32&#x22;,
        type: &#x22;boolean&#x22;
    }).option(&#x22;armv7l&#x22;, {
        group: buildGroup,
        describe: &#x22;Build for armv7l&#x22;,
        type: &#x22;boolean&#x22;
    }).option(&#x22;dir&#x22;, {
        group: buildGroup,
        describe: &#x22;Build unpacked dir. Useful to test.&#x22;,
        type: &#x22;boolean&#x22;
    }).option(&#x22;publish&#x22;, {
        group: publishGroup,
        alias: &#x22;p&#x22;,
        describe: `Publish artifacts (to GitHub Releases), see ${(0, (_chalk || _load_chalk()).underline)(&#x22;https://goo.gl/WMlr4n
&#x22;)}`,
        choices: [&#x22;onTag&#x22;, &#x22;onTagOrDraft&#x22;, &#x22;always&#x22;, &#x22;never&#x22;]
    }).option(&#x22;draft&#x22;, {
        group: publishGroup,
        describe: &#x22;Create a draft (unpublished) release&#x22;,
        type: &#x22;boolean&#x22;,
        default: undefined
    }).option(&#x22;prerelease&#x22;, {
        group: publishGroup,
        describe: &#x22;Identify the release as a prerelease&#x22;,
        type: &#x22;boolean&#x22;,
        default: undefined
    }).option(&#x22;platform&#x22;, {
        group: deprecated,
        describe: &#x22;The target platform (preferred to use --mac, --win or --linux)&#x22;,
        choices: [&#x22;mac&#x22;, &#x22;win&#x22;, &#x22;linux&#x22;, &#x22;darwin&#x22;, &#x22;win32&#x22;, &#x22;all&#x22;]
    }).option(&#x22;arch&#x22;, {
        group: deprecated,
        describe: &#x22;The target arch (preferred to use --x64 or --ia32)&#x22;,
        choices: [&#x22;ia32&#x22;, &#x22;x64&#x22;, &#x22;all&#x22;]
    }).option(&#x22;extraMetadata&#x22;, {
        alias: [&#x22;em&#x22;],
        group: buildGroup,
        describe: &#x22;Inject properties to package.json (asar only)&#x22;
    }).option(&#x22;prepackaged&#x22;, {
        alias: [&#x22;pd&#x22;],
        group: buildGroup,
        describe: &#x22;The path to prepackaged app (to pack in a distributable format)&#x22;
    }).option(&#x22;projectDir&#x22;, {
        alias: [&#x22;project&#x22;],
        group: buildGroup,
        describe: &#x22;The path to project directory. Defaults to current working directory.&#x22;
    }).option(&#x22;config&#x22;, {
        alias: [&#x22;c&#x22;],
        group: buildGroup,
        describe: &#x22;The path to an electron-builder config. Defaults to `electron-builder.yml` (or `json`, or `json5`), see &#x22; + (
0, (_chalk || _load_chalk()).underline)(&#x22;https://goo.gl/YFRJOM&#x22;)
    }).strict().group([&#x22;help&#x22;, &#x22;version&#x22;], &#x22;Other:&#x22;).help().version().epilog(`See the Wiki (${(0, (_chalk || _load_chalk()).underline
)(&#x22;https://github.com/electron-userland/electron-builder/wiki&#x22;)}) for more documentation.`);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.codeSign" id="apidoc.module.electron-builder.codeSign">module electron-builder.codeSign</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.codeSign.createKeychain" id="apidoc.element.electron-builder.codeSign.createKeychain">
        function <span class="apidocSignatureSpan">electron-builder.codeSign.</span>createKeychain
        <span class="apidocSignatureSpan">(_x3, _x4, _x5, _x6, _x7)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createKeychain(_x3, _x4, _x5, _x6, _x7) {
    return _ref3.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.codeSign.downloadCertificate" id="apidoc.element.electron-builder.codeSign.downloadCertificate">
        function <span class="apidocSignatureSpan">electron-builder.codeSign.</span>downloadCertificate
        <span class="apidocSignatureSpan">(_x, _x2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function downloadCertificate(_x, _x2) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.codeSign.findIdentity" id="apidoc.element.electron-builder.codeSign.findIdentity">
        function <span class="apidocSignatureSpan">electron-builder.codeSign.</span>findIdentity
        <span class="apidocSignatureSpan">(certType, qualifier, keychain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findIdentity(certType, qualifier, keychain) {
    let identity = qualifier || process.env.CSC_NAME;
    if ((0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(identity)) {
        if (keychain == null &#x26;&#x26; !(_isCi || _load_isCi()).default &#x26;&#x26; process.env.CSC_IDENTITY_AUTO_DISCOVERY === &#x22;false&#x22;) {
            return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(null);
        } else {
            return _findIdentity(certType, null, keychain);
        }
    } else {
        identity = identity.trim();
        for (const prefix of appleCertificatePrefixes) {
            checkPrefix(identity, prefix);
        }
        return _findIdentity(certType, identity, keychain);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.codeSign.sign" id="apidoc.element.electron-builder.codeSign.sign">
        function <span class="apidocSignatureSpan">electron-builder.codeSign.</span>sign
        <span class="apidocSignatureSpan">(path, name, keychain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sign(path, name, keychain) {
    const args = [&#x22;--deep&#x22;, &#x22;--force&#x22;, &#x22;--sign&#x22;, name, path];
    if (keychain != null) {
        args.push(&#x22;--keychain&#x22;, keychain);
    }
    return (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(&#x22;codesign&#x22;, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const hasMas = targets.length !== 0 &#x26;&#x26; targets.some(function (it) {
    return it.name === &#x22;mas&#x22; || it.name === &#x22;mas-dev&#x22;;
});
const prepackaged = _this2.info.prepackaged;
if (!hasMas || targets.length &#x3e; 1) {
    const appPath = prepackaged == null ? _path.join(_this2.computeAppOutDir(outDir, arch), `${_this2.appInfo.productFilename}.app
`) : prepackaged;
    nonMasPromise = (prepackaged ? (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve() : _this2.doPack(outDir, _path.dirname
(appPath), _this2.platform.nodeName, arch, _this2.platformSpecificBuildOptions, targets)).then(function () {
        return _this2.<span class="apidocCodeKeywordSpan">sign</span>(appPath, null, null);
    }).then(function () {
        return _this2.packageInDistributableFormat(appPath, (_electronBuilderCore || _load_electronBuilderCore()).Arch.x64, targets
, postAsyncTasks);
    });
}
for (const target of targets) {
    const targetName = target.name;
    if (!(targetName === &#x22;mas&#x22; || targetName === &#x22;mas-dev&#x22;)) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.dmg" id="apidoc.module.electron-builder.dmg">module electron-builder.dmg</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.dmg.DmgTarget" id="apidoc.element.electron-builder.dmg.DmgTarget">
        function <span class="apidocSignatureSpan">electron-builder.dmg.</span>DmgTarget
        <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class DmgTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
    constructor(packager, outDir) {
        super(&#x22;dmg&#x22;);
        this.packager = packager;
        this.outDir = outDir;
        this.options = this.packager.config.dmg;
        this.helperDir = _path.join(__dirname, &#x22;..&#x22;, &#x22;..&#x22;, &#x22;templates&#x22;, &#x22;dmg&#x22;);
    }
    build(appPath, arch) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = _this.packager;
            const appInfo = packager.appInfo;
            (0, (_log || _load_log()).log)(&#x22;Building DMG&#x22;);
            const specification = yield _this.computeDmgOptions();
            const tempDir = yield packager.getTempFile(&#x22;dmg&#x22;);
            const tempDmg = _path.join(tempDir, &#x22;temp.dmg&#x22;);
            const backgroundDir = _path.join(tempDir, &#x22;.background&#x22;);
            const backgroundFilename = specification.background == null ? null : _path.basename(specification.background);
            if (backgroundFilename != null) {
                yield (0, (_fsExtraP || _load_fsExtraP()).copy)(_path.resolve(packager.info.projectDir, specification.background
), _path.join(backgroundDir, backgroundFilename));
            }
            let preallocatedSize = 32 * 1024;
            if (specification.icon != null) {
                const stat = yield (0, (_fs || _load_fs()).statOrNull)(specification.icon);
                if (stat != null) {
                    preallocatedSize += stat.size;
                }
            }
            // allocate space for .DS_Store
            yield (0, (_fsExtraP || _load_fsExtraP()).outputFile)(_path.join(backgroundDir, &#x22;DSStorePlaceHolder&#x22;), new Buffer(preallocatedSize
));
            const volumeName = (0, (_sanitizeFilename || _load_sanitizeFilename()).default)(_this.computeVolumeName(specification
.title));
            //noinspection SpellCheckingInspection
            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).spawn)(&#x22;hdiutil&#x22;, addVerboseIfNeed([&#x22;create&#x22;, &#x22;-srcfolder
&#x22;, backgroundDir, &#x22;-srcfolder&#x22;, appPath, &#x22;-volname&#x22;, volumeName, &#x22;-anyowners&#x22;, &#x22;-nospotlight&#x22;, &#x22;-fs&#x22;, &#x22;HFS+&#x22;, &#x22;-fsargs&#x22;, &#x22;-c c=64
,a=16,e=16&#x22;, &#x22;-format&#x22;, &#x22;UDRW&#x22;]).concat(tempDmg));
            const volumePath = _path.join(&#x22;/Volumes&#x22;, volumeName);
            if (yield (0, (_fs || _load_fs()).exists)(volumePath)) {
                (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(&#x22;Unmounting previous disk image&#x22;);
                yield detach(volumePath);
            }
            const isContinue = yield attachAndExecute(tempDmg, true, (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function
* () {
                const promises = [specification.background == null ? (0, (_fsExtraP || _load_fsExtraP()).remove)(`${volumePath}/.
background`) : (0, (_fsExtraP || _load_fsExtraP()).unlink)(`${volumePath}/.background/DSStorePlaceHolder`)];
                let contents = specification.contents;
                if (contents == null) {
                    contents = [{
                        &#x22;x&#x22;: 130, &#x22;y&#x22;: 220
                    }, {
                        &#x22;x&#x22;: 410, &#x22;y&#x22;: 220, &#x22;type&#x22;: &#x22;link&#x22;, &#x22;path&#x22;: &#x22;/Applications&#x22;
                    }];
                }
                const window = specification.window;
                const env = Object.assign({}, process.env, {
                    volumePath: volumePath,
                    appFileName: `${packager.appInfo.productFilename}.app`,
                    iconSize: specification.iconSize || 80,
                    iconTextSize: specification.iconTextSize || 12,
                    windowX: window.x,
                    windowY: window.y,
                    VERSIONER_PERL_PREFER_32_BIT: &#x22;true&#x22;
                });
                if (specification.icon == null) {
                    delete env.volumeIcon;
                } else {
                    const volumeIcon = `${volumePath}/.VolumeIcon.icns`;
                    promises.push((0, (_fsExtraP || _load_fsExtraP()).copy)((yield packager.getResource(specification.icon)) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
createTargets(targets, mapper, cleanupTasks) {
    for (const name of targets) {
        switch (name) {
            case (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET:
                break;
            case &#x22;dmg&#x22;:
                mapper(&#x22;dmg&#x22;, outDir =&#x3e; new (_dmg || _load_dmg()).<span class="apidocCodeKeywordSpan">DmgTarget</
span>(this, outDir));
                break;
            case &#x22;pkg&#x22;:
                mapper(&#x22;pkg&#x22;, outDir =&#x3e; new (_pkg || _load_pkg()).PkgTarget(this, outDir));
                break;
            default:
                mapper(name, outDir =&#x3e; name === &#x22;mas&#x22; || name === &#x22;mas-dev&#x22; ? new (_targetFactory || _load_targetFactory
()).NoOpTarget(name) : (0, (_targetFactory || _load_targetFactory()).createCommonTarget)(name, outDir, this));
                break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.dmg.attachAndExecute" id="apidoc.element.electron-builder.dmg.attachAndExecute">
        function <span class="apidocSignatureSpan">electron-builder.dmg.</span>attachAndExecute
        <span class="apidocSignatureSpan">(_x2, _x3, _x4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attachAndExecute(_x2, _x3, _x4) {
    return _ref3.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.fileMatcher" id="apidoc.module.electron-builder.fileMatcher">module electron-builder.fileMatcher</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.fileMatcher.FileMatcher" id="apidoc.element.electron-builder.fileMatcher.FileMatcher">
        function <span class="apidocSignatureSpan">electron-builder.fileMatcher.</span>FileMatcher
        <span class="apidocSignatureSpan">(from, to, macroExpander, patterns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class FileMatcher {
    constructor(from, to, macroExpander, patterns) {
        this.macroExpander = macroExpander;
        this.from = macroExpander(from);
        this.to = macroExpander(to);
        this.patterns = (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(patterns).map(it =&#x3e; _path.posix.normalize
(macroExpander(it)));
    }
    addPattern(pattern) {
        this.patterns.push(_path.posix.normalize(this.macroExpander(pattern)));
    }
    addAllPattern() {
        // must be first, see minimatchAll implementation
        this.patterns.unshift(&#x22;**/*&#x22;);
    }
    isEmpty() {
        return this.patterns.length === 0;
    }
    containsOnlyIgnore() {
        return !this.isEmpty() &#x26;&#x26; this.patterns.find(it =&#x3e; !it.startsWith(&#x22;!&#x22;)) == null;
    }
    computeParsedPatterns(result, fromDir) {
        // https://github.com/electron-userland/electron-builder/issues/733
        const minimatchOptions = { dot: true };
        const relativeFrom = fromDir == null ? null : _path.relative(fromDir, this.from);
        if (this.patterns.length === 0 &#x26;&#x26; relativeFrom != null) {
            // file mappings, from here is a file
            result.push(new (_minimatch || _load_minimatch()).Minimatch(relativeFrom, minimatchOptions));
            return;
        }
        for (let pattern of this.patterns) {
            if (relativeFrom != null) {
                pattern = _path.join(relativeFrom, pattern);
            }
            const parsedPattern = new (_minimatch || _load_minimatch()).Minimatch(pattern, minimatchOptions);
            result.push(parsedPattern);
            if (!(0, (_filter || _load_filter()).hasMagic)(parsedPattern)) {
                // https://github.com/electron-userland/electron-builder/issues/545
                // add **/*
                result.push(new (_minimatch || _load_minimatch()).Minimatch(`${pattern}/**/*`, minimatchOptions));
            }
        }
    }
    createFilter(ignoreFiles, rawFilter, excludePatterns) {
        const parsedPatterns = [];
        this.computeParsedPatterns(parsedPatterns);
        return (0, (_filter || _load_filter()).createFilter)(this.from, parsedPatterns, ignoreFiles, rawFilter, excludePatterns);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.fileMatcher.copyFiles" id="apidoc.element.electron-builder.fileMatcher.copyFiles">
        function <span class="apidocSignatureSpan">electron-builder.fileMatcher.</span>copyFiles
        <span class="apidocSignatureSpan">(patterns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function copyFiles(patterns) {
    if (patterns == null || patterns.length === 0) {
        return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve();
    }
    return (_bluebirdLst2 || _load_bluebirdLst2()).default.map(patterns, (() =&#x3e; {
        var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (pattern) {
            const fromStat = yield (0, (_fs || _load_fs()).statOrNull)(pattern.from);
            if (fromStat == null) {
                (0, (_log || _load_log()).warn)(`File source ${pattern.from} doesn&#x27;t exist`);
                return;
            }
            if (fromStat.isFile()) {
                const toStat = yield (0, (_fs || _load_fs()).statOrNull)(pattern.to);
                // https://github.com/electron-userland/electron-builder/issues/1245
                if (toStat != null &#x26;&#x26; toStat.isDirectory()) {
                    return yield (0, (_fs || _load_fs()).copyFile)(pattern.from, _path.join(pattern.to, _path.basename(pattern.from
)), fromStat);
                }
                yield (0, (_fsExtraP || _load_fsExtraP()).mkdirs)(_path.dirname(pattern.to));
                return yield (0, (_fs || _load_fs()).copyFile)(pattern.from, pattern.to, fromStat);
            }
            if (pattern.isEmpty() || pattern.containsOnlyIgnore()) {
                pattern.addAllPattern();
            }
            return yield (0, (_fs || _load_fs()).copyDir)(pattern.from, pattern.to, pattern.createFilter());
        });

        return function (_x) {
            return _ref.apply(this, arguments);
        };
    })());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.fileMatcher.createFileMatcher" id="apidoc.element.electron-builder.fileMatcher.createFileMatcher">
        function <span class="apidocSignatureSpan">electron-builder.fileMatcher.</span>createFileMatcher
        <span class="apidocSignatureSpan">(info, appDir, resourcesPath, macroExpander, platformSpecificBuildOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFileMatcher(info, appDir, resourcesPath, macroExpander, platformSpecificBuildOptions) {
    const patterns = info.isPrepackedAppAsar ? null : getFileMatchers(info.config, &#x22;files&#x22;, appDir, _path.join(resourcesPath, &#x22;app
&#x22;), false, macroExpander, platformSpecificBuildOptions);
    const matcher = patterns == null ? new FileMatcher(appDir, _path.join(resourcesPath, &#x22;app&#x22;), macroExpander) : patterns[0];
    if (matcher.isEmpty() || matcher.containsOnlyIgnore()) {
        matcher.addAllPattern();
    } else {
        matcher.addPattern(&#x22;package.json&#x22;);
    }
    matcher.addPattern(&#x22;!**/node_modules/*/{CHANGELOG.md,ChangeLog,changelog.md,README.md,README,readme.md,readme,test,__tests__
,tests,powered-test,example,examples,*.d.ts}&#x22;);
    matcher.addPattern(&#x22;!**/node_modules/.bin&#x22;);
    matcher.addPattern(&#x22;!**/*.{o,hprof,orig,pyc,pyo,rbc,swp}&#x22;);
    matcher.addPattern(&#x22;!**/._*&#x22;);
    matcher.addPattern(&#x22;!*.iml&#x22;);
    //noinspection SpellCheckingInspection
    matcher.addPattern(&#x22;!**/{.git,.hg,.svn,CVS,RCS,SCCS,&#x22; + &#x22;__pycache__,.DS_Store,thumbs.db,.gitignore,.gitattributes,&#x22; + &#x22;.editorconfig
,.flowconfig,.jshintrc,.eslintrc,&#x22; + &#x22;.yarn-integrity,.yarn-metadata.json,yarn-error.log,yarn.lock,npm-debug.log,&#x22; + &#x22;.idea,&#x22; + &#x22;
appveyor.yml,.travis.yml,circle.yml,&#x22; + &#x22;.nyc_output}&#x22;);
    return matcher;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.fileMatcher.getFileMatchers" id="apidoc.element.electron-builder.fileMatcher.getFileMatchers">
        function <span class="apidocSignatureSpan">electron-builder.fileMatcher.</span>getFileMatchers
        <span class="apidocSignatureSpan">(config, name, defaultSrc, defaultDest, allowAdvancedMatching, macroExpander, customBuildOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFileMatchers(config, name, defaultSrc, defaultDest, allowAdvancedMatching, macroExpander, customBuildOptions) {
    const globalPatterns = config[name];
    const platformSpecificPatterns = customBuildOptions[name];
    const defaultMatcher = new FileMatcher(defaultSrc, defaultDest, macroExpander);
    const fileMatchers = [];
    function addPatterns(patterns) {
        if (patterns == null) {
            return;
        } else if (!Array.isArray(patterns)) {
            if (typeof patterns === &#x22;string&#x22;) {
                defaultMatcher.addPattern(patterns);
                return;
            }
            patterns = [patterns];
        }
        for (const pattern of patterns) {
            if (typeof pattern === &#x22;string&#x22;) {
                // use normalize to transform ./foo to foo
                defaultMatcher.addPattern(pattern);
            } else if (allowAdvancedMatching) {
                const from = pattern.from == null ? defaultSrc : _path.resolve(defaultSrc, pattern.from);
                const to = pattern.to == null ? defaultDest : _path.resolve(defaultDest, pattern.to);
                fileMatchers.push(new FileMatcher(from, to, macroExpander, pattern.filter));
            } else {
                throw new Error(`Advanced file copying not supported for &#x22;${name}&#x22;`);
            }
        }
    }
    addPatterns(globalPatterns);
    addPatterns(platformSpecificPatterns);
    if (!defaultMatcher.isEmpty()) {
        // default matcher should be first in the array
        fileMatchers.unshift(defaultMatcher);
    }
    return fileMatchers.length === 0 ? null : fileMatchers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.fileTransformer" id="apidoc.module.electron-builder.fileTransformer">module electron-builder.fileTransformer</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.fileTransformer.createElectronCompilerHost" id="apidoc.element.electron-builder.fileTransformer.createElectronCompilerHost">
        function <span class="apidocSignatureSpan">electron-builder.fileTransformer.</span>createElectronCompilerHost
        <span class="apidocSignatureSpan">(projectDir, cacheDir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createElectronCompilerHost(projectDir, cacheDir) {
    const electronCompilePath = _path.join(projectDir, &#x22;node_modules&#x22;, &#x22;electron-compile&#x22;, &#x22;lib&#x22;);
    return require(_path.join(electronCompilePath, &#x22;config-parser&#x22;)).createCompilerHostFromProjectRoot(projectDir, cacheDir);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.fileTransformer.createTransformer" id="apidoc.element.electron-builder.fileTransformer.createTransformer">
        function <span class="apidocSignatureSpan">electron-builder.fileTransformer.</span>createTransformer
        <span class="apidocSignatureSpan">(_x, _x2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTransformer(_x, _x2) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.fileTransformer.isElectronCompileUsed" id="apidoc.element.electron-builder.fileTransformer.isElectronCompileUsed">
        function <span class="apidocSignatureSpan">electron-builder.fileTransformer.</span>isElectronCompileUsed
        <span class="apidocSignatureSpan">(info)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isElectronCompileUsed(info) {
    if (info.config.electronCompile != null) {
        return info.config.electronCompile;
    }
    // if in devDependencies - it means that babel is used for precompilation or for some reason user decided to not use electron
-compile for production
    const deps = info.metadata.dependencies;
    return deps != null &#x26;&#x26; &#x22;electron-compile&#x22; in deps;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.filter" id="apidoc.module.electron-builder.filter">module electron-builder.filter</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.filter.createFilter" id="apidoc.element.electron-builder.filter.createFilter">
        function <span class="apidocSignatureSpan">electron-builder.filter.</span>createFilter
        <span class="apidocSignatureSpan">(src, patterns, ignoreFiles, rawFilter, excludePatterns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFilter(src, patterns, ignoreFiles, rawFilter, excludePatterns) {
    return function (it, stat) {
        if (src === it) {
            return true;
        }
        if (rawFilter != null &#x26;&#x26; !rawFilter(it)) {
            return false;
        }
        // yes, check before path sep normalization
        if (ignoreFiles != null &#x26;&#x26; ignoreFiles.has(it)) {
            return false;
        }
        let relative = it.substring(src.length + 1);
        if (_path.sep === &#x22;\\&#x22;) {
            relative = relative.replace(/\\/g, &#x22;/&#x22;);
        }
        return minimatchAll(relative, patterns, stat) &#x26;&#x26; (excludePatterns == null || !minimatchAll(relative, excludePatterns, stat
));
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                }
                yield (0, (_fsExtraP || _load_fsExtraP()).mkdirs)(_path.dirname(pattern.to));
                return yield (0, (_fs || _load_fs()).copyFile)(pattern.from, pattern.to, fromStat);
            }
            if (pattern.isEmpty() || pattern.containsOnlyIgnore()) {
                pattern.addAllPattern();
            }
            return yield (0, (_fs || _load_fs()).copyDir)(pattern.from, pattern.to, pattern.<span class="apidocCodeKeywordSpan">
createFilter</span>());
        });

        return function (_x) {
            return _ref.apply(this, arguments);
        };
    })());
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.filter.hasMagic" id="apidoc.element.electron-builder.filter.hasMagic">
        function <span class="apidocSignatureSpan">electron-builder.filter.</span>hasMagic
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasMagic(pattern) {
    const set = pattern.set;
    if (set.length &#x3e; 1) {
        return true;
    }
    for (const i of set[0]) {
        if (typeof i !== &#x22;string&#x22;) {
            return true;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.forge_maker" id="apidoc.module.electron-builder.forge_maker">module electron-builder.forge_maker</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.forge_maker.buildForge" id="apidoc.element.electron-builder.forge_maker.buildForge">
        function <span class="apidocSignatureSpan">electron-builder.forge_maker.</span>buildForge
        <span class="apidocSignatureSpan">(appDir, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buildForge(appDir, options) {
    return (0, (_builder || _load_builder()).build)(Object.assign({
        prepackaged: appDir,
        config: {
            directories: {
                // https://github.com/electron-userland/electron-forge/blob/master/src/makers/generic/zip.js
                output: _path.resolve(appDir, &#x22;..&#x22;, &#x22;make&#x22;)
            }
        }
    }, options));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.fpm" id="apidoc.module.electron-builder.fpm">module electron-builder.fpm</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.fpm.default" id="apidoc.element.electron-builder.fpm.default">
        function <span class="apidocSignatureSpan">electron-builder.fpm.</span>default
        <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class FpmTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
    constructor(name, packager, helper, outDir) {
        super(name, false);
        this.packager = packager;
        this.helper = helper;
        this.outDir = outDir;
        this.options = Object.assign({}, this.packager.platformSpecificBuildOptions, this.packager.config[this.name]);
        this.scriptFiles = this.createScripts();
    }
    createScripts() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const defaultTemplatesDir = _path.join(__dirname, &#x22;..&#x22;, &#x22;..&#x22;, &#x22;templates&#x22;, &#x22;linux&#x22;);
            const packager = _this.packager;
            const templateOptions = Object.assign({
                // old API compatibility
                executable: packager.executableName,
                productFilename: packager.appInfo.productFilename
            }, packager.platformSpecificBuildOptions);
            function getResource(value, defaultFile) {
                if (value == null) {
                    return _path.join(defaultTemplatesDir, defaultFile);
                }
                return _path.resolve(packager.projectDir, value);
            }
            //noinspection ES6MissingAwait
            return yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([writeConfigFile(packager.info.tempDirManager, getResource
(_this.options.afterInstall, &#x22;after-install.tpl&#x22;), templateOptions), writeConfigFile(packager.info.tempDirManager, getResource(_this
.options.afterRemove, &#x22;after-remove.tpl&#x22;), templateOptions)]);
        })();
    }
    build(appOutDir, arch) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const target = _this2.name;
            (0, (_log || _load_log()).log)(`Building ${target}`);
            const destination = _path.join(_this2.outDir, _this2.packager.generateName(target, arch, true /* on Linux we use safe
 name — without space */));
            yield (0, (_fs || _load_fs()).unlinkIfExists)(destination);
            if (_this2.packager.info.prepackaged != null) {
                yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(_this2.outDir);
            }
            const scripts = yield _this2.scriptFiles;
            const packager = _this2.packager;
            const appInfo = packager.appInfo;
            const projectUrl = yield appInfo.computePackageUrl();
            if (projectUrl == null) {
                throw new Error(&#x22;Please specify project homepage, see https://github.com/electron-userland/electron-builder/wiki
/Options#AppMetadata-homepage&#x22;);
            }
            const options = _this2.options;
            let author = options.maintainer;
            if (author == null) {
                const a = appInfo.metadata.author;
                if (a.email == null) {
                    throw new Error((_errorMessages || _load_errorMessages()).authorEmailIsMissed);
                }
                author = `${a.name} &#x3c;${a.email}&#x3e;`;
            }
            const synopsis = options.synopsis;
            const args = [&#x22;-s&#x22;, &#x22;dir&#x22;, &#x22;-t&#x22;, target, &#x22;--architecture&#x22;, target === &#x22;pacman&#x22; &#x26;&#x26; arch === (_electronBuilderCore ||
_load_electronBuilderCore()).Arch.ia32 ? &#x22;i686&#x22; : (0, (_electronBuilderCore || _load_electronBuilderCore()).toLinuxArchString)(arch
), &#x22;--name&#x22;, appInfo.name, &#x22;--force&#x22;, &#x22;--after-install&#x22;, scripts[0], &#x22;--after-remove&#x22;, scripts[1], &#x22;--description&#x22;, (0, (_electronBuilderUtil
 || _load_electronBuilderUtil()).smarten)(target === &#x22;rpm&#x22; ? _this2.helper.getDescription(options) : `${synopsis || &#x22;&#x22;}\n ${_this2.helper.getDescription(options)}`), &#x22;--maintainer&#x22;, author, &#x22;--vendor&#x22;, options.vendor || author, &#x22;--version&#x22;, appInfo.version, &#x22;--package&#x22;, destination, &#x22;--url&#x22;, projectUrl];
            const packageCategory = options.packageCategory;
            if (packageCategory != null &#x26;&#x26; packageCategory !== null) {
                args.push(&#x22;--category&#x22;, packageCategory);
            }
            if (target === &#x22;deb&#x22;) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
headerPickle.writeString(JSON.stringify(this.fs.header));
const headerBuf = headerPickle.toBuffer();
const sizePickle = pickle.createEmpty();
sizePickle.writeUInt32(headerBuf.length);
const sizeBuf = sizePickle.toBuffer();
const transformedFiles = this.transformedFiles;
const writeStream = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(this.outFile);
return new (_bluebirdLst2 || _load_bluebirdLst2()).<span class="apidocCodeKeywordSpan">default</span>((resolve, reject) =&#x3e; {
    writeStream.on(&#x22;error&#x22;, reject);
    writeStream.on(&#x22;close&#x22;, resolve);
    writeStream.write(sizeBuf);
    const w = index =&#x3e; {
        let data;
        while (true) {
            if (index &#x3e;= files.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.linuxPackager" id="apidoc.module.electron-builder.linuxPackager">module electron-builder.linuxPackager</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.linuxPackager.LinuxPackager" id="apidoc.element.electron-builder.linuxPackager.LinuxPackager">
        function <span class="apidocSignatureSpan">electron-builder.linuxPackager.</span>LinuxPackager
        <span class="apidocSignatureSpan">(_platformPackager || _load_platformPackager()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class LinuxPackager extends (_platformPackager || _load_platformPackager()).PlatformPackager {
    constructor(info) {
        super(info);
        const executableName = this.platformSpecificBuildOptions.executableName;
        this.executableName = (0, (_sanitizeFilename || _load_sanitizeFilename()).default)(executableName == null ? this.appInfo
.name.toLowerCase() : executableName);
    }
    get defaultTarget() {
        return [&#x22;appimage&#x22;];
    }
    createTargets(targets, mapper, cleanupTasks) {
        let helper;
        const getHelper = () =&#x3e; {
            if (helper == null) {
                helper = new (_LinuxTargetHelper || _load_LinuxTargetHelper()).LinuxTargetHelper(this);
            }
            return helper;
        };
        for (const name of targets) {
            if (name === (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET) {
                continue;
            }
            const targetClass = (() =&#x3e; {
                switch (name) {
                    case &#x22;appimage&#x22;:
                        return require(&#x22;./targets/appImage&#x22;).default;
                    case &#x22;snap&#x22;:
                        return require(&#x22;./targets/snap&#x22;).default;
                    case &#x22;deb&#x22;:
                    case &#x22;rpm&#x22;:
                    case &#x22;sh&#x22;:
                    case &#x22;freebsd&#x22;:
                    case &#x22;pacman&#x22;:
                    case &#x22;apk&#x22;:
                    case &#x22;p5p&#x22;:
                        return require(&#x22;./targets/fpm&#x22;).default;
                    default:
                        return null;
                }
            })();
            mapper(name, outDir =&#x3e; targetClass === null ? (0, (_targetFactory || _load_targetFactory()).createCommonTarget)(name
, outDir, this) : new targetClass(name, this, getHelper(), outDir));
        }
    }
    get platform() {
        return (_electronBuilderCore || _load_electronBuilderCore()).Platform.LINUX;
    }
    postInitApp(appOutDir) {
        return (0, (_fsExtraP || _load_fsExtraP()).rename)(_path.join(appOutDir, this.electronDistExecutableName), _path.join(appOutDir
, this.executableName));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.mac" id="apidoc.module.electron-builder.mac">module electron-builder.mac</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.mac.createApp" id="apidoc.element.electron-builder.mac.createApp">
        function <span class="apidocSignatureSpan">electron-builder.mac.</span>createApp
        <span class="apidocSignatureSpan">(_x, _x2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createApp(_x, _x2) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//noinspection ES6MissingAwait
const promises = [promise, (0, (_fs || _load_fs()).unlinkIfExists)(_path.join(resourcesPath, &#x22;default_app.asar&#x22;)), (0, (
_fs || _load_fs()).unlinkIfExists)(_path.join(appOutDir, &#x22;version&#x22;)), _this2.postInitApp(appOutDir)];
if (_this2.platform !== (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC) {
    promises.push((0, (_fsExtraP || _load_fsExtraP()).rename)(_path.join(appOutDir, &#x22;LICENSE&#x22;), _path.join(appOutDir, &#
x22;LICENSE.electron.txt&#x22;)).catch(function () {}));
}
yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all(promises);
if (platformName === &#x22;darwin&#x22; || platformName === &#x22;mas&#x22;) {
    yield require(&#x22;./packager/mac&#x22;).<span class="apidocCodeKeywordSpan">createApp</span>(_this2, appOutDir);
}
yield (0, (_fileMatcher || _load_fileMatcher()).copyFiles)(extraResourceMatchers);
yield (0, (_fileMatcher || _load_fileMatcher()).copyFiles)(extraFileMatchers);
if (_this2.info.cancellationToken.cancelled) {
    return;
}
yield _this2.info.afterPack({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.mac.filterCFBundleIdentifier" id="apidoc.element.electron-builder.mac.filterCFBundleIdentifier">
        function <span class="apidocSignatureSpan">electron-builder.mac.</span>filterCFBundleIdentifier
        <span class="apidocSignatureSpan">(identifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filterCFBundleIdentifier(identifier) {
    // Remove special characters and allow only alphanumeric (A-Z,a-z,0-9), hyphen (-), and period (.)
    // Apple documentation: https://developer.apple.com/library/mac/documentation/General/Reference/InfoPlistKeyReference/Articles
/CoreFoundationKeys.html#//apple_ref/doc/uid/20001431-102070
    return identifier.replace(/ /g, &#x22;-&#x22;).replace(/[^a-zA-Z0-9.-]/g, &#x22;&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.macPackager" id="apidoc.module.electron-builder.macPackager">module electron-builder.macPackager</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.macPackager.default" id="apidoc.element.electron-builder.macPackager.default">
        function <span class="apidocSignatureSpan">electron-builder.macPackager.</span>default
        <span class="apidocSignatureSpan">(_platformPackager || _load_platformPackager()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class MacPackager extends (_platformPackager || _load_platformPackager()).PlatformPackager {
    constructor(info) {
        super(info);
        if (this.packagerOptions.cscLink == null || process.platform !== &#x22;darwin&#x22;) {
            this.codeSigningInfo = (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(Object.create(null));
        } else {
            this.codeSigningInfo = (0, (_codeSign || _load_codeSign()).createKeychain)(info.tempDirManager, this.packagerOptions
.cscLink, this.getCscPassword(), this.packagerOptions.cscInstallerLink, this.packagerOptions.cscInstallerKeyPassword);
        }
    }
    get defaultTarget() {
        return [&#x22;zip&#x22;, &#x22;dmg&#x22;];
    }
    prepareAppInfo(appInfo) {
        return new (_appInfo || _load_appInfo()).AppInfo(appInfo.metadata, this.info, this.platformSpecificBuildOptions.bundleVersion
);
    }
    getIconPath() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            let iconPath = _this.platformSpecificBuildOptions.icon || _this.config.icon;
            if (iconPath != null &#x26;&#x26; !iconPath.endsWith(&#x22;.icns&#x22;)) {
                iconPath += &#x22;.icns&#x22;;
            }
            return iconPath == null ? yield _this.getDefaultIcon(&#x22;icns&#x22;) : yield _this.getResource(iconPath);
        })();
    }
    createTargets(targets, mapper, cleanupTasks) {
        for (const name of targets) {
            switch (name) {
                case (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET:
                    break;
                case &#x22;dmg&#x22;:
                    mapper(&#x22;dmg&#x22;, outDir =&#x3e; new (_dmg || _load_dmg()).DmgTarget(this, outDir));
                    break;
                case &#x22;pkg&#x22;:
                    mapper(&#x22;pkg&#x22;, outDir =&#x3e; new (_pkg || _load_pkg()).PkgTarget(this, outDir));
                    break;
                default:
                    mapper(name, outDir =&#x3e; name === &#x22;mas&#x22; || name === &#x22;mas-dev&#x22; ? new (_targetFactory || _load_targetFactory()).
NoOpTarget(name) : (0, (_targetFactory || _load_targetFactory()).createCommonTarget)(name, outDir, this));
                    break;
            }
        }
    }
    get platform() {
        return (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC;
    }
    pack(outDir, arch, targets, postAsyncTasks) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            let nonMasPromise = null;
            const hasMas = targets.length !== 0 &#x26;&#x26; targets.some(function (it) {
                return it.name === &#x22;mas&#x22; || it.name === &#x22;mas-dev&#x22;;
            });
            const prepackaged = _this2.info.prepackaged;
            if (!hasMas || targets.length &#x3e; 1) {
                const appPath = prepackaged == null ? _path.join(_this2.computeAppOutDir(outDir, arch), `${_this2.appInfo.productFilename
}.app`) : prepackaged;
                nonMasPromise = (prepackaged ? (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve() : _this2.doPack(outDir,
_path.dirname(appPath), _this2.platform.nodeName, arch, _this2.platformSpecificBuildOptions, targets)).then(function () {
                    return _this2.sign(appPath, null, null);
                }).then(function () {
                    return _this2.packageInDistributableFormat(appPath, (_electronBuilderCore || _load_electronBuilderCore()).Arch
.x64, targets, postAsyncTasks);
                });
            }
            for (const target of targets) {
                const targetName = target.name;
                if (!(targetName === &#x22;mas&#x22; || targetName === &#x22;mas-dev&#x22;)) {
                    continue;
                }
                const masBuildOptions = (0, (_deepAssign || _load_deepAssign()).deepAssign)({}, _this2.platformSpecificBuildOptions
, _this2.config.mas);
                if (targetName === &#x22;mas-dev&#x22;) {
                    (0, (_deepAssign || _load_deepAssign()).deepAssign)(masBuildOptions, _this2.config[targetName]);
                    masBuildOptions.type = &#x22;development&#x22;;
                }
                const target ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
headerPickle.writeString(JSON.stringify(this.fs.header));
const headerBuf = headerPickle.toBuffer();
const sizePickle = pickle.createEmpty();
sizePickle.writeUInt32(headerBuf.length);
const sizeBuf = sizePickle.toBuffer();
const transformedFiles = this.transformedFiles;
const writeStream = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(this.outFile);
return new (_bluebirdLst2 || _load_bluebirdLst2()).<span class="apidocCodeKeywordSpan">default</span>((resolve, reject) =&#x3e; {
    writeStream.on(&#x22;error&#x22;, reject);
    writeStream.on(&#x22;close&#x22;, resolve);
    writeStream.write(sizeBuf);
    const w = index =&#x3e; {
        let data;
        while (true) {
            if (index &#x3e;= files.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.nsis" id="apidoc.module.electron-builder.nsis">module electron-builder.nsis</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.nsis.AppPackageHelper" id="apidoc.element.electron-builder.nsis.AppPackageHelper">
        function <span class="apidocSignatureSpan">electron-builder.nsis.</span>AppPackageHelper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AppPackageHelper {
    constructor() {
        this.archToFileInfo = new Map();
        this.infoToIsDelete = new Map();
<span class="apidocCodeCommentSpan">        /** @private */
</span>        this.refCount = 0;
    }
    packArch(arch, target) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            let infoPromise = _this.archToFileInfo.get(arch);
            if (infoPromise == null) {
                infoPromise = (0, (_log || _load_log()).subTask)(`Packaging NSIS installer for arch ${(_electronBuilderCore || _load_electronBuilderCore
()).Arch[arch]}`, target.buildAppPackage(target.archs.get(arch), arch)).then(function (it) {
                    return { file: it };
                });
                _this.archToFileInfo.set(arch, infoPromise);
            }
            const info = yield infoPromise;
            if (target.isWebInstaller) {
                _this.infoToIsDelete.set(info, false);
            } else if (!_this.infoToIsDelete.has(info)) {
                _this.infoToIsDelete.set(info, true);
            }
            return info.file;
        })();
    }
    finishBuild() {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (--_this2.refCount &#x3e; 0) {
                return;
            }
            const filesToDelete = [];
            for (let _ref of _this2.infoToIsDelete.entries()) {
                var _ref2 = _slicedToArray(_ref, 2);

                let info = _ref2[0];
                let isDelete = _ref2[1];

                if (isDelete) {
                    filesToDelete.push(info.file);
                }
            }
            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(filesToDelete, function (it) {
                return (0, (_fsExtraP || _load_fsExtraP()).unlink)(it);
            });
        })();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
doGetCscPassword() {
    return this.platformSpecificBuildOptions.certificatePassword || process.env.WIN_CSC_KEY_PASSWORD || super.doGetCscPassword();
}
createTargets(targets, mapper, cleanupTasks) {
    let helper;
    const getHelper = () =&#x3e; {
        if (helper == null) {
            helper = new (_nsis || _load_nsis()).<span class="apidocCodeKeywordSpan">AppPackageHelper</span>();
        }
        return helper;
    };
    for (const name of targets) {
        if (name === (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET) {
            continue;
        }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.nsis.NsisTarget" id="apidoc.element.electron-builder.nsis.NsisTarget">
        function <span class="apidocSignatureSpan">electron-builder.nsis.</span>NsisTarget
        <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class NsisTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
    constructor(packager, outDir, targetName, packageHelper) {
        super(targetName);
        this.packager = packager;
        this.outDir = outDir;
        this.packageHelper = packageHelper;
<span class="apidocCodeCommentSpan">        /** @private */
</span>        this.archs = new Map();
        this.nsisTemplatesDir = _path.join(__dirname, &#x22;..&#x22;, &#x22;..&#x22;, &#x22;templates&#x22;, &#x22;nsis&#x22;);
        this.packageHelper.refCount++;
        let options = this.packager.config.nsis || Object.create(null);
        if (targetName !== &#x22;nsis&#x22;) {
            options = Object.assign(options, this.packager.config[targetName === &#x22;nsis-web&#x22; ? &#x22;nsisWeb&#x22; : targetName]);
        }
        this.options = options;
        const deps = packager.info.metadata.dependencies;
        if (deps != null &#x26;&#x26; deps[&#x22;electron-squirrel-startup&#x22;] != null) {
            (0, (_log || _load_log()).warn)(&#x27;&#x22;electron-squirrel-startup&#x22; dependency is not required for NSIS&#x27;);
        }
    }
    build(appOutDir, arch) {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            _this3.archs.set(arch, appOutDir);
        })();
    }
    /** @private */
    buildAppPackage(appOutDir, arch) {
        var _this4 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([(0, (_fs || _load_fs()).copyFile)(_path.join((yield nsisPathPromise
), &#x22;elevate.exe&#x22;), _path.join(appOutDir, &#x22;resources&#x22;, &#x22;elevate.exe&#x22;), null, false), (0, (_fs || _load_fs()).copyFile)(_path.join
((yield (0, (_windowsCodeSign || _load_windowsCodeSign()).getSignVendorPath)()), &#x22;windows-10&#x22;, (_electronBuilderCore || _load_electronBuilderCore
()).Arch[arch], &#x22;signtool.exe&#x22;), _path.join(appOutDir, &#x22;resources&#x22;, &#x22;signtool.exe&#x22;), null, false)]);
            const packager = _this4.packager;
            const format = _this4.options.useZip ? &#x22;zip&#x22; : &#x22;7z&#x22;;
            const archiveFile = _path.join(_this4.outDir, `${packager.appInfo.name}-${packager.appInfo.version}-${(_electronBuilderCore
 || _load_electronBuilderCore()).Arch[arch]}.nsis.${format}`);
            return yield (0, (_archive || _load_archive()).archive)(packager.config.compression, format, archiveFile, appOutDir,
true);
        })();
    }
    // noinspection JSUnusedGlobalSymbols
    finishBuild() {
        var _this5 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            (0, (_log || _load_log()).log)(&#x22;Building NSIS installer&#x22;);
            try {
                yield _this5.buildInstaller();
            } finally {
                yield _this5.packageHelper.finishBuild();
            }
        })();
    }
    get installerFilenamePattern() {
        return &#x22;${productName} &#x22; + (this.isPortable ? &#x22;&#x22; : &#x22;Setup &#x22;) + &#x22;${version}.${ext}&#x22;;
    }
    get isPortable() {
        return this.name === &#x22;portable&#x22;;
    }
    buildInstaller() {
        var _this6 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const isPortable = _this6.isPortable;
            const packager = _this6.packager;
            const appInfo = packager.appInfo;
            const version = appInfo.version;
            const options = _this6.options;
            const installerFilename = packager.expandArtifactNamePattern(options, &#x22;exe&#x22;, null, _this6.installerFilenamePattern);
            const iconPath = (isPortable ? null : yield packager.getResource(options.installerIcon, &#x22;installerIcon.ico&#x22;)) || (yield
 packager.getIconPath());
            const oneClick = options.oneClick !== false;
            const installerPath = _path.join(_this6.outDir, installerFilename);
            const guid = options.guid || (yield (_bluebirdLst2 || _load_bluebirdLst2()).default.promisify((_uuid || _load_uuid()).
v5)({ namespace: ELECTRON_BUILDER_NS_UUID, name: appInfo.id }));
            const defines = {
                APP_ID: appInfo.id,
                APP_GUID: guid,
                PRODUCT_N ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return helper;
};
for (const name of targets) {
    if (name === (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET) {
        continue;
    }
    if (name === &#x22;nsis&#x22; || name === &#x22;portable&#x22;) {
        mapper(name, outDir =&#x3e; new (_nsis || _load_nsis()).<span class="apidocCodeKeywordSpan">NsisTarget</span>(this, outDir
, name, getHelper()));
    } else if (name === &#x22;nsis-web&#x22;) {
        mapper(name, outDir =&#x3e; new (_WebInstallerTarget || _load_WebInstallerTarget()).WebInstallerTarget(this, outDir, name
, getHelper()));
    } else {
        const targetClass = (() =&#x3e; {
            switch (name) {
                case &#x22;squirrel&#x22;:
                    try {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.packager" id="apidoc.module.electron-builder.packager">module electron-builder.packager</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.packager.Packager" id="apidoc.element.electron-builder.packager.Packager">
        function <span class="apidocSignatureSpan">electron-builder.packager.</span>Packager
        <span class="apidocSignatureSpan">(options, cancellationToken)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Packager {
    //noinspection JSUnusedGlobalSymbols
    constructor(options, cancellationToken) {
        this.options = options;
        this.cancellationToken = cancellationToken;
        this.isTwoPackageJsonProjectLayoutUsed = true;
        this.eventEmitter = new (_events || _load_events()).EventEmitter();
        this.tempDirManager = new (_tmp || _load_tmp()).TmpDir();
        this._repositoryInfo = new (_electronBuilderUtil || _load_electronBuilderUtil()).Lazy(() =&#x3e; (0, (_repositoryInfo || _load_repositoryInfo
()).getRepositoryInfo)(this.projectDir, this.metadata, this.devMetadata));
        this.afterPackHandlers = [];
        this.projectDir = options.projectDir == null ? process.cwd() : _path.resolve(options.projectDir);
        this.prepackaged = options.prepackaged == null ? null : _path.resolve(this.projectDir, options.prepackaged);
    }
    get isPrepackedAppAsar() {
        return this._isPrepackedAppAsar;
    }
    get config() {
        return this._config;
    }
    get repositoryInfo() {
        return this._repositoryInfo.value;
    }
    addAfterPackHandler(handler) {
        this.afterPackHandlers.push(handler);
    }
    artifactCreated(handler) {
        addHandler(this.eventEmitter, &#x22;artifactCreated&#x22;, handler);
        return this;
    }
    dispatchArtifactCreated(event) {
        this.eventEmitter.emit(&#x22;artifactCreated&#x22;, event);
    }
    build() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            //noinspection JSDeprecatedSymbols
            const devMetadataFromOptions = _this.options.devMetadata;
            if (devMetadataFromOptions != null) {
                (0, (_log || _load_log()).warn)(&#x22;devMetadata is deprecated, please use config instead&#x22;);
            }
            let configPath = null;
            let configFromOptions = _this.options.config;
            if (typeof configFromOptions === &#x22;string&#x22;) {
                // it is a path to config file
                configPath = configFromOptions;
                configFromOptions = null;
            }
            if (devMetadataFromOptions != null) {
                if (configFromOptions != null) {
                    throw new Error(&#x22;devMetadata and config cannot be used in conjunction&#x22;);
                }
                configFromOptions = devMetadataFromOptions.build;
            }
            const projectDir = _this.projectDir;
            const fileOrPackageConfig = yield configPath == null ? (0, (_readPackageJson || _load_readPackageJson()).loadConfig)(
projectDir) : (0, (_readPackageJson || _load_readPackageJson()).doLoadConfig)(_path.resolve(projectDir, configPath), projectDir);
            const config = (0, (_deepAssign || _load_deepAssign()).deepAssign)({}, fileOrPackageConfig, configFromOptions);
            const extraMetadata = _this.options.extraMetadata;
            if (extraMetadata != null) {
                const extraBuildMetadata = extraMetadata.build;
                if (extraBuildMetadata != null) {
                    (0, (_deepAssign || _load_deepAssign()).deepAssign)(config, extraBuildMetadata);
                    delete extraMetadata.build;
                }
                if (extraMetadata.directories != null) {
                    (0, (_log || _load_log()).warn)(`--em.directories is deprecated, please specify as --em.build.directories&#x22;`);
                    (0, (_deepAssign || _load_deepAssign()).deepAssign)(config, { directories: extraMetadata.directories });
                    delete extraMetadata.directories;
                }
            }
            yield (0, (_readPackageJson || _load_readPackageJson()).validateConfig)(config);
            _this._config = config;
            _this.appDir = yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).computeDefaultAppDirectory)(projectDir
, (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(config.directories, function (it) {
                return it.app;
            }));
            _this.isTwoPackageJsonProjectLayoutUsed = _this.appDir !== projectD ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (options.draft === undefined &#x26;&#x26; !(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process
.env.EP_DRAFT)) {
    options.draft = process.env.EP_DRAFT.toLowerCase() === &#x22;true&#x22;;
}
if (options.prerelease === undefined &#x26;&#x26; !(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process
.env.EP_PRELEASE)) {
    options.prerelease = process.env.EP_PRELEASE.toLowerCase() === &#x22;true&#x22;;
}
const cancellationToken = new (_CancellationToken || _load_CancellationToken()).CancellationToken();
const packager = new (_packager || _load_packager()).<span class="apidocCodeKeywordSpan">Packager</span>(options, cancellationToken
);
// because artifact event maybe dispatched several times for different publish providers
const artifactPaths = new Set();
packager.artifactCreated(function (event) {
    if (event.file != null) {
        artifactPaths.add(event.file);
    }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.packager.checkWineVersion" id="apidoc.element.electron-builder.packager.checkWineVersion">
        function <span class="apidocSignatureSpan">electron-builder.packager.</span>checkWineVersion
        <span class="apidocSignatureSpan">(_x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkWineVersion(_x) {
    return _ref5.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.packager.normalizePlatforms" id="apidoc.element.electron-builder.packager.normalizePlatforms">
        function <span class="apidocSignatureSpan">electron-builder.packager.</span>normalizePlatforms
        <span class="apidocSignatureSpan">(rawPlatforms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalizePlatforms(rawPlatforms) {
    const platforms = rawPlatforms == null || Array.isArray(rawPlatforms) ? rawPlatforms : [rawPlatforms];
    if (platforms == null || platforms.length === 0) {
        return [(_electronBuilderCore || _load_electronBuilderCore()).Platform.fromString(process.platform)];
    } else if (platforms[0] === &#x22;all&#x22;) {
        if (process.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC.nodeName) {
            return [(_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC, (_electronBuilderCore || _load_electronBuilderCore
()).Platform.LINUX, (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS];
        } else if (process.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.LINUX.nodeName) {
            // macOS code sign works only on macOS
            return [(_electronBuilderCore || _load_electronBuilderCore()).Platform.LINUX, (_electronBuilderCore || _load_electronBuilderCore
()).Platform.WINDOWS];
        } else {
            return [(_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS];
        }
    } else {
        return platforms.map(it =&#x3e; it instanceof (_electronBuilderCore || _load_electronBuilderCore()).Platform ? it : (_electronBuilderCore
 || _load_electronBuilderCore()).Platform.fromString(it));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.pkg" id="apidoc.module.electron-builder.pkg">module electron-builder.pkg</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.pkg.PkgTarget" id="apidoc.element.electron-builder.pkg.PkgTarget">
        function <span class="apidocSignatureSpan">electron-builder.pkg.</span>PkgTarget
        <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PkgTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
    constructor(packager, outDir) {
        super(&#x22;pkg&#x22;);
        this.packager = packager;
        this.outDir = outDir;
        this.options = this.packager.config.pkg || Object.create(null);
        this.installLocation = this.options.installLocation || &#x22;/Applications&#x22;;
    }
    build(appPath, arch) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = _this.packager;
            const options = _this.options;
            const appInfo = packager.appInfo;
            const keychainName = (yield packager.codeSigningInfo).keychainName;
            const certType = &#x22;Developer ID Installer&#x22;;
            const identity = yield (0, (_codeSign || _load_codeSign()).findIdentity)(certType, options.identity || packager.platformSpecificBuildOptions
.identity, keychainName);
            if (identity == null &#x26;&#x26; packager.forceCodeSigning) {
                throw new Error(`Cannot find valid &#x22;${certType}&#x22; to sign standalone installer, please see https://github.com/electron
-userland/electron-builder/wiki/Code-Signing`);
            }
            const appOutDir = _this.outDir;
            const distInfo = _path.join(appOutDir, &#x22;distribution.xml&#x22;);
            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(&#x22;productbuild&#x22;, [&#x22;--synthesize&#x22;, &#x22;--component&#x22;,
appPath, _this.installLocation, distInfo], {
                cwd: appOutDir
            });
            // to use --scripts, we must build .app bundle separately using pkgbuild
            // productbuild --scripts doesn&#x27;t work (because scripts in this case not added to our package)
            // https://github.com/electron-userland/electron-osx-sign/issues/96#issuecomment-274986942
            const innerPackageFile = _path.join(appOutDir, `${(0, (_mac || _load_mac()).filterCFBundleIdentifier)(appInfo.id)}.pkg
`);
            yield _this.buildComponentPackage(appPath, innerPackageFile);
            const outFile = _path.join(appOutDir, packager.expandArtifactNamePattern(options, &#x22;pkg&#x22;));
            const args = prepareProductBuildArgs(identity, keychainName);
            args.push(&#x22;--distribution&#x22;, distInfo);
            args.push(outFile);
            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(options.productbuild, function (it) {
                return args.push.apply(args, _toConsumableArray(it));
            });
            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(&#x22;productbuild&#x22;, args, {
                cwd: appOutDir
            });
            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([(0, (_fsExtraP || _load_fsExtraP()).unlink)(innerPackageFile
), (0, (_fsExtraP || _load_fsExtraP()).unlink)(distInfo)]);
            packager.dispatchArtifactCreated(outFile, _this, arch, `${appInfo.name}-${appInfo.version}.pkg`);
        })();
    }
    buildComponentPackage(appPath, outFile) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const options = _this2.options;
            const args = [&#x22;--component&#x22;, appPath, &#x22;--install-location&#x22;, _this2.installLocation];
            if (options.scripts != null) {
                args.push(&#x22;--scripts&#x22;, _path.resolve(_this2.packager.buildResourcesDir, options.scripts));
            } else if (options.scripts !== null) {
                const dir = _path.join(_this2.packager.buildResourcesDir, &#x22;pkg-scripts&#x22;);
                const stat = yield (0, (_fs || _load_fs()).statOrNull)(dir);
                if (stat != null &#x26;&#x26; stat.isDirectory()) {
                    args.push(&#x22;--scripts&#x22;, dir);
                }
            }
            args.push(outFile);
            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(&#x22;pkgbuild&#x22;, args);
        })();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        switch (name) {
            case (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET:
                break;
            case &#x22;dmg&#x22;:
                mapper(&#x22;dmg&#x22;, outDir =&#x3e; new (_dmg || _load_dmg()).DmgTarget(this, outDir));
                break;
            case &#x22;pkg&#x22;:
                mapper(&#x22;pkg&#x22;, outDir =&#x3e; new (_pkg || _load_pkg()).<span class="apidocCodeKeywordSpan">PkgTarget</
span>(this, outDir));
                break;
            default:
                mapper(name, outDir =&#x3e; name === &#x22;mas&#x22; || name === &#x22;mas-dev&#x22; ? new (_targetFactory || _load_targetFactory
()).NoOpTarget(name) : (0, (_targetFactory || _load_targetFactory()).createCommonTarget)(name, outDir, this));
                break;
        }
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.pkg.prepareProductBuildArgs" id="apidoc.element.electron-builder.pkg.prepareProductBuildArgs">
        function <span class="apidocSignatureSpan">electron-builder.pkg.</span>prepareProductBuildArgs
        <span class="apidocSignatureSpan">(identity, keychain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prepareProductBuildArgs(identity, keychain) {
    const args = [];
    if (identity != null) {
        args.push(&#x22;--sign&#x22;, identity);
        if (keychain != null) {
            args.push(&#x22;--keychain&#x22;, keychain);
        }
    }
    return args;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.platformPackager" id="apidoc.module.electron-builder.platformPackager">module electron-builder.platformPackager</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.platformPackager.PlatformPackager" id="apidoc.element.electron-builder.platformPackager.PlatformPackager">
        function <span class="apidocSignatureSpan">electron-builder.platformPackager.</span>PlatformPackager
        <span class="apidocSignatureSpan">(info)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PlatformPackager {
    constructor(info) {
        this.info = info;
        this._resourceList = new (_electronBuilderUtil || _load_electronBuilderUtil()).Lazy(() =&#x3e; {
            return (0, (_fsExtraP || _load_fsExtraP()).readdir)(this.buildResourcesDir).catch(e =&#x3e; {
                if (e.code !== &#x22;ENOENT&#x22;) {
                    throw e;
                }
                return [];
            });
        });
        this.config = info.config;
        this.platformSpecificBuildOptions = PlatformPackager.normalizePlatformSpecificBuildOptions(this.config[this.platform.buildConfigurationKey
]);
        this.appInfo = this.prepareAppInfo(info.appInfo);
        this.packagerOptions = info.options;
        this.projectDir = info.projectDir;
        this.buildResourcesDir = _path.resolve(this.projectDir, this.relativeBuildResourcesDirname);
    }
    get resourceList() {
        return this._resourceList.value;
    }
    prepareAppInfo(appInfo) {
        return appInfo;
    }
    static normalizePlatformSpecificBuildOptions(options) {
        return options == null ? Object.create(null) : options;
    }
    getCscPassword() {
        const password = this.doGetCscPassword();
        if ((0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(password)) {
            (0, (_log || _load_log()).log)(&#x22;CSC_KEY_PASSWORD is not defined, empty password will be used&#x22;);
            return &#x22;&#x22;;
        } else {
            return password.trim();
        }
    }
    doGetCscPassword() {
        return this.packagerOptions.cscKeyPassword || process.env.CSC_KEY_PASSWORD;
    }
    get relativeBuildResourcesDirname() {
        return (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(this.config.directories, it =&#x3e; it.buildResources) || &#x22;
build&#x22;;
    }
    computeAppOutDir(outDir, arch) {
        return this.info.prepackaged || _path.join(outDir, `${this.platform.buildConfigurationKey}${(0, (_electronBuilderCore ||
_load_electronBuilderCore()).getArchSuffix)(arch)}${this.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform
.MAC ? &#x22;&#x22; : &#x22;-unpacked&#x22;}`);
    }
    dispatchArtifactCreated(file, target, arch, safeArtifactName) {
        this.info.dispatchArtifactCreated({
            file, safeArtifactName, target, arch,
            packager: this
        });
    }
    pack(outDir, arch, targets, postAsyncTasks) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const appOutDir = _this.computeAppOutDir(outDir, arch);
            yield _this.doPack(outDir, appOutDir, _this.platform.nodeName, arch, _this.platformSpecificBuildOptions, targets);
            _this.packageInDistributableFormat(appOutDir, arch, targets, postAsyncTasks);
        })();
    }
    packageInDistributableFormat(appOutDir, arch, targets, postAsyncTasks) {
        postAsyncTasks.push((_bluebirdLst2 || _load_bluebirdLst2()).default.map(targets, it =&#x3e; it.isAsyncSupported ? it.build(appOutDir
, arch) : null).then(() =&#x3e; (_bluebirdLst2 || _load_bluebirdLst2()).default.each(targets, it =&#x3e; it.isAsyncSupported ? null : it.build
(appOutDir, arch))));
    }
    getExtraFileMatchers(isResources, appOutDir, macroExpander, customBuildOptions) {
        const base = isResources ? this.getResourcesDir(appOutDir) : this.platform === (_electronBuilderCore || _load_electronBuilderCore
()).Platform.MAC ? _path.join(appOutDir, `${this.appInfo.productFilename}.app`, &#x22;Contents&#x22;) : appOutDir;
        return (0, (_fileMatcher || _load_fileMatcher()).getFileMatchers)(this.config, isResources ? &#x22;extraResources&#x22; : &#x22;extraFiles
&#x22;, this.projectDir, base, true, macroExpander, customBuildOptions);
    }
    get electronDistMacOsAppName() {
        return this.info.muonVersion == null ? &#x22;Electron.app&#x22; : &#x22;Brave.app&#x22;;
    }
    get electronDistExecutableName() {
        return this.info.muonVersion == null ? &#x22;electron&#x22; : &#x22;brave&#x22;;
    }
    get electronDistMacOsExecutableName() {
        return this.info.muonVersion == null ? &#x22;Electron&#x22; : &#x22;Brave&#x22;;
    }
    doPack(outDir, appOutDir, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.platformPackager.normalizeExt" id="apidoc.element.electron-builder.platformPackager.normalizeExt">
        function <span class="apidocSignatureSpan">electron-builder.platformPackager.</span>normalizeExt
        <span class="apidocSignatureSpan">(ext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalizeExt(ext) {
    return ext.startsWith(&#x22;.&#x22;) ? ext.substring(1) : ext;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.readInstalled" id="apidoc.module.electron-builder.readInstalled">module electron-builder.readInstalled</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.readInstalled.readInstalled" id="apidoc.element.electron-builder.readInstalled.readInstalled">
        function <span class="apidocSignatureSpan">electron-builder.</span>readInstalled
        <span class="apidocSignatureSpan">(_x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readInstalled(_x) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.readPackageJson" id="apidoc.module.electron-builder.readPackageJson">module electron-builder.readPackageJson</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.readPackageJson.readPackageJson" id="apidoc.element.electron-builder.readPackageJson.readPackageJson">
        function <span class="apidocSignatureSpan">electron-builder.</span>readPackageJson
        <span class="apidocSignatureSpan">(_x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readPackageJson(_x) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.readPackageJson.doLoadConfig" id="apidoc.element.electron-builder.readPackageJson.doLoadConfig">
        function <span class="apidocSignatureSpan">electron-builder.readPackageJson.</span>doLoadConfig
        <span class="apidocSignatureSpan">(_x4, _x5)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doLoadConfig(_x4, _x5) {
    return _ref3.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.readPackageJson.getElectronVersion" id="apidoc.element.electron-builder.readPackageJson.getElectronVersion">
        function <span class="apidocSignatureSpan">electron-builder.readPackageJson.</span>getElectronVersion
        <span class="apidocSignatureSpan">(_x7, _x8, _x9)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getElectronVersion(_x7, _x8, _x9) {
    return _ref5.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.readPackageJson.loadConfig" id="apidoc.element.electron-builder.readPackageJson.loadConfig">
        function <span class="apidocSignatureSpan">electron-builder.readPackageJson.</span>loadConfig
        <span class="apidocSignatureSpan">(_x6)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadConfig(_x6) {
    return _ref4.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.readPackageJson.validateConfig" id="apidoc.element.electron-builder.readPackageJson.validateConfig">
        function <span class="apidocSignatureSpan">electron-builder.readPackageJson.</span>validateConfig
        <span class="apidocSignatureSpan">(_x10)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateConfig(_x10) {
    return _ref7.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.repositoryInfo" id="apidoc.module.electron-builder.repositoryInfo">module electron-builder.repositoryInfo</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.repositoryInfo.getRepositoryInfo" id="apidoc.element.electron-builder.repositoryInfo.getRepositoryInfo">
        function <span class="apidocSignatureSpan">electron-builder.repositoryInfo.</span>getRepositoryInfo
        <span class="apidocSignatureSpan">(projectDir, metadata, devMetadata)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRepositoryInfo(projectDir, metadata, devMetadata) {
    return _getInfo(projectDir, (devMetadata == null ? null : devMetadata.repository) || (metadata == null ? null : metadata.repository
));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.snap" id="apidoc.module.electron-builder.snap">module electron-builder.snap</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.snap.default" id="apidoc.element.electron-builder.snap.default">
        function <span class="apidocSignatureSpan">electron-builder.snap.</span>default
        <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SnapTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
    constructor(name, packager, helper, outDir) {
        super(name);
        this.packager = packager;
        this.helper = helper;
        this.outDir = outDir;
        this.options = Object.assign({}, this.packager.platformSpecificBuildOptions, this.packager.config[this.name]);
    }
    build(appOutDir, arch) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            (0, (_log || _load_log()).log)(`Building Snap for arch ${(_electronBuilderCore || _load_electronBuilderCore()).Arch[
arch]}`);
            const packager = _this.packager;
            const appInfo = packager.appInfo;
            const options = _this.options;
            const stageDir = `${appOutDir}-snap`;
            const snapDir = _path.join(stageDir, &#x22;snap&#x22;);
            yield (0, (_fsExtraP || _load_fsExtraP()).emptyDir)(stageDir);
            const extraSnapSourceDir = _path.join(stageDir, &#x22;extra&#x22;);
            const isUseUbuntuPlatform = options.ubuntuAppPlatformContent != null;
            if (isUseUbuntuPlatform) {
                // ubuntu-app-platform requires empty directory
                yield (0, (_fsExtraP || _load_fsExtraP()).emptyDir)(_path.join(extraSnapSourceDir, &#x22;ubuntu-app-platform&#x22;));
            }
            const snap = {};
            snap.name = packager.executableName.toLowerCase();
            snap.version = appInfo.version;
            snap.summary = options.summary || appInfo.productName;
            snap.description = _this.helper.getDescription(options);
            snap.confinement = options.confinement || &#x22;strict&#x22;;
            snap.grade = options.grade || &#x22;stable&#x22;;
            yield _this.helper.icons;
            if (_this.helper.maxIconPath != null) {
                snap.icon = &#x22;snap/gui/icon.png&#x22;;
                yield (0, (_fsExtraP || _load_fsExtraP()).copy)(_this.helper.maxIconPath, _path.join(snapDir, &#x22;gui&#x22;, &#x22;icon.png&#x22;));
            }
            const desktopFile = yield _this.helper.computeDesktopEntry(_this.options, `${packager.executableName}`, _path.join(snapDir
, &#x22;gui&#x22;, `${snap.name}.desktop`), {
                &#x22;Icon&#x22;: &#x22;${SNAP}/meta/gui/icon.png&#x22;
            });
            if (options.assumes != null) {
                if (!Array.isArray(options.assumes)) {
                    throw new Error(&#x22;snap.assumes must be an array of strings&#x22;);
                }
                snap.assumes = options.assumes;
            }
            snap.apps = {
                [snap.name]: {
                    command: `env TMPDIR=$XDG_RUNTIME_DIR desktop-launch $SNAP/${packager.executableName}`,
                    plugs: (0, (_electronBuilderUtil || _load_electronBuilderUtil()).replaceDefault)(options.plugs, [&#x22;home&#x22;, &#x22;x11
&#x22;, &#x22;unity7&#x22;, &#x22;browser-support&#x22;, &#x22;network&#x22;, &#x22;gsettings&#x22;, &#x22;pulseaudio&#x22;, &#x22;opengl&#x22;])
                }
            };
            if (isUseUbuntuPlatform) {
                snap.apps[snap.name].plugs.push(&#x22;platform&#x22;);
                snap.plugs = {
                    platform: {
                        interface: &#x22;content&#x22;,
                        content: &#x22;ubuntu-app-platform1&#x22;,
                        target: &#x22;ubuntu-app-platform&#x22;,
                        &#x22;default-provider&#x22;: &#x22;ubuntu-app-platform&#x22;
                    }
                };
            }
            // libxss1, libasound2, gconf2 - was &#x22;error while loading shared libraries: libXss.so.1&#x22; on Xubuntu 16.04
            const isUseDocker = process.platform !== &#x22;linux&#x22;;
            const defaultStagePackages = isUseUbuntuPlatform ? [&#x22;libnss3&#x22;] : [&#x22;libnotify4&#x22;, &#x22;libappindicator1&#x22;, &#x22;libxtst6&#x22;, &#x22;libnss3
&#x22;, &#x22;libxss1&#x22;, &#x22;fontconfig-config&#x22;, &#x22;gconf2&#x22;, &#x22;libasound2&#x22;, &#x22;pulseaudio&#x22;];
            snap.parts = {
                app: {
                    plugin: &#x22;dump&#x22;,
                    &#x22;stage-packages&#x22;: (0, (_electronBuilderUtil || _load_electronBuilderUtil()).replaceDefault)(options.stagePackages
, defaultStagePackages),
                    source: isUseDocker ? `/out/${_path.basename(appOutDir)}` ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
headerPickle.writeString(JSON.stringify(this.fs.header));
const headerBuf = headerPickle.toBuffer();
const sizePickle = pickle.createEmpty();
sizePickle.writeUInt32(headerBuf.length);
const sizeBuf = sizePickle.toBuffer();
const transformedFiles = this.transformedFiles;
const writeStream = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(this.outFile);
return new (_bluebirdLst2 || _load_bluebirdLst2()).<span class="apidocCodeKeywordSpan">default</span>((resolve, reject) =&#x3e; {
    writeStream.on(&#x22;error&#x22;, reject);
    writeStream.on(&#x22;close&#x22;, resolve);
    writeStream.write(sizeBuf);
    const w = index =&#x3e; {
        let data;
        while (true) {
            if (index &#x3e;= files.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.targetFactory" id="apidoc.module.electron-builder.targetFactory">module electron-builder.targetFactory</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.targetFactory.NoOpTarget" id="apidoc.element.electron-builder.targetFactory.NoOpTarget">
        function <span class="apidocSignatureSpan">electron-builder.targetFactory.</span>NoOpTarget
        <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class NoOpTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
    constructor(name) {
        super(name);
        this.options = null;
    }
    get outDir() {
        throw new Error(&#x22;NoOpTarget&#x22;);
    }
    build(appOutDir, arch) {
        // no build

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {})();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            case &#x22;dmg&#x22;:
                mapper(&#x22;dmg&#x22;, outDir =&#x3e; new (_dmg || _load_dmg()).DmgTarget(this, outDir));
                break;
            case &#x22;pkg&#x22;:
                mapper(&#x22;pkg&#x22;, outDir =&#x3e; new (_pkg || _load_pkg()).PkgTarget(this, outDir));
                break;
            default:
                mapper(name, outDir =&#x3e; name === &#x22;mas&#x22; || name === &#x22;mas-dev&#x22; ? new (_targetFactory || _load_targetFactory
()).<span class="apidocCodeKeywordSpan">NoOpTarget</span>(name) : (0, (_targetFactory || _load_targetFactory()).createCommonTarget
)(name, outDir, this));
                break;
        }
    }
}
get platform() {
    return (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.targetFactory.computeArchToTargetNamesMap" id="apidoc.element.electron-builder.targetFactory.computeArchToTargetNamesMap">
        function <span class="apidocSignatureSpan">electron-builder.targetFactory.</span>computeArchToTargetNamesMap
        <span class="apidocSignatureSpan">(raw, options, platform)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function computeArchToTargetNamesMap(raw, options, platform) {
    for (const targetNames of raw.values()) {
        if (targetNames.length &#x3e; 0) {
            // https://github.com/electron-userland/electron-builder/issues/1355
            return raw;
        }
    }
    const defaultArchs = raw.size === 0 ? [platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC ? &#x22;x64
&#x22; : process.arch] : Array.from(raw.keys()).map(it =&#x3e; (_electronBuilderCore || _load_electronBuilderCore()).Arch[it]);
    const result = new Map(raw);
    for (const target of (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(options.target).map(it =&#x3e; typeof it === &#x22;
string&#x22; ? { target: it } : it)) {
        let name = target.target;
        let archs = target.arch;
        const suffixPos = name.lastIndexOf(&#x22;:&#x22;);
        if (suffixPos &#x3e; 0) {
            name = target.target.substring(0, suffixPos);
            if (archs == null) {
                archs = target.target.substring(suffixPos + 1);
            }
        }
        for (const arch of archs == null ? defaultArchs : (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(archs
)) {
            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).addValue)(result, (0, (_electronBuilderCore || _load_electronBuilderCore
()).archFromString)(arch), name);
        }
    }
    if (result.size === 0) {
        for (const arch of defaultArchs) {
            result.set((0, (_electronBuilderCore || _load_electronBuilderCore()).archFromString)(arch), []);
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.targetFactory.createCommonTarget" id="apidoc.element.electron-builder.targetFactory.createCommonTarget">
        function <span class="apidocSignatureSpan">electron-builder.targetFactory.</span>createCommonTarget
        <span class="apidocSignatureSpan">(target, outDir, packager)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createCommonTarget(target, outDir, packager) {
    if (archiveTargets.has(target)) {
        return new (_ArchiveTarget || _load_ArchiveTarget()).ArchiveTarget(target, outDir, packager);
    } else if (target === (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET) {
        return new NoOpTarget((_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET);
    } else {
        throw new Error(`Unknown target: ${target}`);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.targetFactory.createTargets" id="apidoc.element.electron-builder.targetFactory.createTargets">
        function <span class="apidocSignatureSpan">electron-builder.targetFactory.</span>createTargets
        <span class="apidocSignatureSpan">(nameToTarget, rawList, outDir, packager, cleanupTasks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTargets(nameToTarget, rawList, outDir, packager, cleanupTasks) {
    const result = [];
    const mapper = (name, factory) =&#x3e; {
        let target = nameToTarget.get(name);
        if (target == null) {
            target = factory(outDir);
            nameToTarget.set(name, target);
        }
        result.push(target);
    };
    const targets = normalizeTargets(rawList, packager.defaultTarget);
    packager.createTargets(targets, mapper, cleanupTasks);
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (target == null) {
        target = factory(outDir);
        nameToTarget.set(name, target);
    }
    result.push(target);
};
const targets = normalizeTargets(rawList, packager.defaultTarget);
packager.<span class="apidocCodeKeywordSpan">createTargets</span>(targets, mapper, cleanupTasks);
return result;
}
function normalizeTargets(targets, defaultTarget) {
const list = [];
for (const t of targets) {
    const name = t.toLowerCase().trim();
    if (name === (_electronBuilderCore || _load_electronBuilderCore()).DEFAULT_TARGET) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.winPackager" id="apidoc.module.electron-builder.winPackager">module electron-builder.winPackager</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.winPackager.WinPackager" id="apidoc.element.electron-builder.winPackager.WinPackager">
        function <span class="apidocSignatureSpan">electron-builder.winPackager.</span>WinPackager
        <span class="apidocSignatureSpan">(_platformPackager || _load_platformPackager()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WinPackager extends (_platformPackager || _load_platformPackager()).PlatformPackager {
    constructor(info) {
        var _this;

        _this = super(info);
        this.cscInfo = new (_electronBuilderUtil || _load_electronBuilderUtil()).Lazy(() =&#x3e; {
            const platformSpecificBuildOptions = this.platformSpecificBuildOptions;
            const subjectName = platformSpecificBuildOptions.certificateSubjectName;
            if (subjectName != null) {
                return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve({ subjectName });
            }
            const certificateSha1 = platformSpecificBuildOptions.certificateSha1;
            if (certificateSha1 != null) {
                return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve({ certificateSha1 });
            }
            const certificateFile = platformSpecificBuildOptions.certificateFile;
            if (certificateFile != null) {
                const certificatePassword = this.getCscPassword();
                return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve({
                    file: certificateFile,
                    password: certificatePassword == null ? null : certificatePassword.trim()
                });
            } else {
                const cscLink = process.env.WIN_CSC_LINK || this.packagerOptions.cscLink;
                if (cscLink != null) {
                    return (0, (_codeSign || _load_codeSign()).downloadCertificate)(cscLink, this.info.tempDirManager).then(path
 =&#x3e; {
                        return {
                            file: path,
                            password: this.getCscPassword()
                        };
                    });
                } else {
                    return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(null);
                }
            }
        });
        this.computedPublisherName = new (_electronBuilderUtil || _load_electronBuilderUtil()).Lazy((0, (_bluebirdLst || _load_bluebirdLst
()).coroutine)(function* () {
            let publisherName = _this.platformSpecificBuildOptions.publisherName;
            if (publisherName === null) {
                return null;
            }
            const cscInfo = yield _this.cscInfo.value;
            if (cscInfo == null) {
                return null;
            }
            if (publisherName == null &#x26;&#x26; cscInfo.file != null) {
                try {
                    // https://github.com/digitalbazaar/forge/issues/338#issuecomment-164831585
                    const p12Asn1 = (_nodeForge || _load_nodeForge()).asn1.fromDer((yield (0, (_fsExtraP || _load_fsExtraP()).readFile
)(cscInfo.file, &#x22;binary&#x22;)), false);
                    const p12 = (_nodeForge || _load_nodeForge()).pkcs12.pkcs12FromAsn1(p12Asn1, false, cscInfo.password);
                    const bagType = (_nodeForge || _load_nodeForge()).pki.oids.certBag;
                    publisherName = p12.getBags({ bagType: bagType })[bagType][0].cert.subject.getField(&#x22;CN&#x22;).value;
                } catch (e) {
                    throw new Error(`Cannot extract publisher name from code signing certificate, please file issue. As workaround
, set win.publisherName: ${e.stack || e}`);
                }
            }
            return publisherName == null ? null : (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(publisherName
);
        }));
    }
    get defaultTarget() {
        return [&#x22;nsis&#x22;];
    }
    doGetCscPassword() {
        return this.platformSpecificBuildOptions.certificatePassword || process.env.WIN_CSC_KEY_PASSWORD || super.doGetCscPassword
();
    }
    createTargets(targets, mapper, cleanupTasks) {
        let helper;
        const getHelper = () =&#x3e; {
            if (helper == null) {
                helper = new (_nsis || _load_nsis()).AppPackageHelper();
            }
            return helper;
        };
        for (const name of targets) {
            if (name === (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET) {
                continue;
            }
            if (name ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.windowsCodeSign" id="apidoc.module.electron-builder.windowsCodeSign">module electron-builder.windowsCodeSign</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.windowsCodeSign.getSignVendorPath" id="apidoc.element.electron-builder.windowsCodeSign.getSignVendorPath">
        function <span class="apidocSignatureSpan">electron-builder.windowsCodeSign.</span>getSignVendorPath
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSignVendorPath() {
    //noinspection SpellCheckingInspection
    return (0, (_binDownload || _load_binDownload()).getBinFromBintray)(&#x22;winCodeSign&#x22;, TOOLS_VERSION, &#x22;a34a60e74d02b81d0303e498f03c70ce0133f908b671f62ec32896db5cd0a716
&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.windowsCodeSign.getToolPath" id="apidoc.element.electron-builder.windowsCodeSign.getToolPath">
        function <span class="apidocSignatureSpan">electron-builder.windowsCodeSign.</span>getToolPath
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getToolPath() {
    return _ref3.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.windowsCodeSign.sign" id="apidoc.element.electron-builder.windowsCodeSign.sign">
        function <span class="apidocSignatureSpan">electron-builder.windowsCodeSign.</span>sign
        <span class="apidocSignatureSpan">(_x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sign(_x) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const hasMas = targets.length !== 0 &#x26;&#x26; targets.some(function (it) {
    return it.name === &#x22;mas&#x22; || it.name === &#x22;mas-dev&#x22;;
});
const prepackaged = _this2.info.prepackaged;
if (!hasMas || targets.length &#x3e; 1) {
    const appPath = prepackaged == null ? _path.join(_this2.computeAppOutDir(outDir, arch), `${_this2.appInfo.productFilename}.app
`) : prepackaged;
    nonMasPromise = (prepackaged ? (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve() : _this2.doPack(outDir, _path.dirname
(appPath), _this2.platform.nodeName, arch, _this2.platformSpecificBuildOptions, targets)).then(function () {
        return _this2.<span class="apidocCodeKeywordSpan">sign</span>(appPath, null, null);
    }).then(function () {
        return _this2.packageInDistributableFormat(appPath, (_electronBuilderCore || _load_electronBuilderCore()).Arch.x64, targets
, postAsyncTasks);
    });
}
for (const target of targets) {
    const targetName = target.name;
    if (!(targetName === &#x22;mas&#x22; || targetName === &#x22;mas-dev&#x22;)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.yarn" id="apidoc.module.electron-builder.yarn">module electron-builder.yarn</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.yarn.getGypEnv" id="apidoc.element.electron-builder.yarn.getGypEnv">
        function <span class="apidocSignatureSpan">electron-builder.yarn.</span>getGypEnv
        <span class="apidocSignatureSpan">(frameworkInfo, platform, arch, buildFromSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getGypEnv(frameworkInfo, platform, arch, buildFromSource) {
    if (!frameworkInfo.useCustomDist) {
        return Object.assign({}, process.env, {
            npm_config_arch: arch,
            npm_config_target_arch: arch,
            npm_config_platform: platform,
            npm_config_build_from_source: buildFromSource
        });
    }
    const gypHome = _path.join((0, (_os || _load_os()).homedir)(), &#x22;.electron-gyp&#x22;);
    return Object.assign({}, process.env, {
        npm_config_disturl: &#x22;https://atom.io/download/electron&#x22;,
        npm_config_target: frameworkInfo.version,
        npm_config_runtime: &#x22;electron&#x22;,
        npm_config_arch: arch,
        npm_config_target_arch: arch,
        npm_config_platform: platform,
        npm_config_build_from_source: buildFromSource,
        HOME: gypHome,
        USERPROFILE: gypHome
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.yarn.installOrRebuild" id="apidoc.element.electron-builder.yarn.installOrRebuild">
        function <span class="apidocSignatureSpan">electron-builder.yarn.</span>installOrRebuild
        <span class="apidocSignatureSpan">(_x, _x2, _x3, _x4, _x5)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function installOrRebuild(_x, _x2, _x3, _x4, _x5) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.yarn.rebuild" id="apidoc.element.electron-builder.yarn.rebuild">
        function <span class="apidocSignatureSpan">electron-builder.yarn.</span>rebuild
        <span class="apidocSignatureSpan">(_x9, _x10)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rebuild(_x9, _x10) {
    return _ref2.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
