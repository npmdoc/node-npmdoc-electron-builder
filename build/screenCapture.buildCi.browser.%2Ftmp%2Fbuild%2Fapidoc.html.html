<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/electron-userland/electron-builder">electron-builder (v17.0.1)</a>
</h1>
<h4>A complete solution to package and build a ready for distribution Electron app for MacOS, Windows and Linux with â€œauto updateâ€ support out of the box</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder">module electron-builder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.Packager">
            function <span class="apidocSignatureSpan">electron-builder.</span>Packager
            <span class="apidocSignatureSpan">(options, cancellationToken)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.Platform">
            function <span class="apidocSignatureSpan">electron-builder.</span>Platform
            <span class="apidocSignatureSpan">(name, buildConfigurationKey, nodeName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.Target">
            function <span class="apidocSignatureSpan">electron-builder.</span>Target
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.archFromString">
            function <span class="apidocSignatureSpan">electron-builder.</span>archFromString
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.build">
            function <span class="apidocSignatureSpan">electron-builder.</span>build
            <span class="apidocSignatureSpan">(_x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.buildForge">
            function <span class="apidocSignatureSpan">electron-builder.</span>buildForge
            <span class="apidocSignatureSpan">(appDir, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.createTargets">
            function <span class="apidocSignatureSpan">electron-builder.</span>createTargets
            <span class="apidocSignatureSpan">(platforms, type, arch)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.getArchSuffix">
            function <span class="apidocSignatureSpan">electron-builder.</span>getArchSuffix
            <span class="apidocSignatureSpan">(arch)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>Arch</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>ArchiveTarget</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>LinuxTargetHelper</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>PublishManager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>WebInstallerTarget</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>appImage</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>appInfo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>appx</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>asar</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>asarUtil</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>builder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>cliOptions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>codeSign</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>dmg</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>fileMatcher</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>fileTransformer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>filter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>forge_maker</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>fpm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>linuxPackager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>mac</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>macPackager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>nsis</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>packager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>pkg</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>platformPackager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>readInstalled</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>readPackageJson</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>repositoryInfo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>snap</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>targetFactory</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>winPackager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>windowsCodeSign</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.</span>yarn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">electron-builder.</span>DIR_TARGET</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.ArchiveTarget">module electron-builder.ArchiveTarget</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.ArchiveTarget.ArchiveTarget">
            function <span class="apidocSignatureSpan">electron-builder.</span>ArchiveTarget
            <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.LinuxTargetHelper">module electron-builder.LinuxTargetHelper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.LinuxTargetHelper.LinuxTargetHelper">
            function <span class="apidocSignatureSpan">electron-builder.</span>LinuxTargetHelper
            <span class="apidocSignatureSpan">(packager)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">electron-builder.LinuxTargetHelper.</span>installPrefix</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.PublishManager">module electron-builder.PublishManager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.PublishManager.PublishManager">
            function <span class="apidocSignatureSpan">electron-builder.</span>PublishManager
            <span class="apidocSignatureSpan">(packager, publishOptions, cancellationToken)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.PublishManager.computeDownloadUrl">
            function <span class="apidocSignatureSpan">electron-builder.PublishManager.</span>computeDownloadUrl
            <span class="apidocSignatureSpan">(publishConfig, fileName, packager)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.PublishManager.createPublisher">
            function <span class="apidocSignatureSpan">electron-builder.PublishManager.</span>createPublisher
            <span class="apidocSignatureSpan">(context, version, publishConfig, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.PublishManager.getPublishConfigs">
            function <span class="apidocSignatureSpan">electron-builder.PublishManager.</span>getPublishConfigs
            <span class="apidocSignatureSpan">(_x12, _x13, _x14)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.PublishManager.getPublishConfigsForUpdateInfo">
            function <span class="apidocSignatureSpan">electron-builder.PublishManager.</span>getPublishConfigsForUpdateInfo
            <span class="apidocSignatureSpan">(_x2, _x3, _x4)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.WebInstallerTarget">module electron-builder.WebInstallerTarget</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.WebInstallerTarget.WebInstallerTarget">
            function <span class="apidocSignatureSpan">electron-builder.</span>WebInstallerTarget
            <span class="apidocSignatureSpan">(_nsis || _load_nsis()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.appImage">module electron-builder.appImage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.appImage.default">
            function <span class="apidocSignatureSpan">electron-builder.appImage.</span>default
            <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.appInfo">module electron-builder.appInfo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.appInfo.AppInfo">
            function <span class="apidocSignatureSpan">electron-builder.appInfo.</span>AppInfo
            <span class="apidocSignatureSpan">(metadata, info, buildVersion)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.appx">module electron-builder.appx</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.appx.default">
            function <span class="apidocSignatureSpan">electron-builder.appx.</span>default
            <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.asar">module electron-builder.asar</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.asar.AsarFilesystem">
            function <span class="apidocSignatureSpan">electron-builder.asar.</span>AsarFilesystem
            <span class="apidocSignatureSpan">(src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.asar.Node">
            function <span class="apidocSignatureSpan">electron-builder.asar.</span>Node
            <span class="apidocSignatureSpan">{{signature}}</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.asar.readAsar">
            function <span class="apidocSignatureSpan">electron-builder.asar.</span>readAsar
            <span class="apidocSignatureSpan">(_x5)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.asar.readAsarJson">
            function <span class="apidocSignatureSpan">electron-builder.asar.</span>readAsarJson
            <span class="apidocSignatureSpan">(_x6, _x7)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.asarUtil">module electron-builder.asarUtil</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.asarUtil.AsarPackager">
            function <span class="apidocSignatureSpan">electron-builder.asarUtil.</span>AsarPackager
            <span class="apidocSignatureSpan">(src, destination, options, unpackPattern, transformer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.asarUtil.checkFileInArchive">
            function <span class="apidocSignatureSpan">electron-builder.asarUtil.</span>checkFileInArchive
            <span class="apidocSignatureSpan">(_x2, _x3, _x4)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.builder">module electron-builder.builder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.builder.build">
            function <span class="apidocSignatureSpan">electron-builder.builder.</span>build
            <span class="apidocSignatureSpan">(_x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.builder.createTargets">
            function <span class="apidocSignatureSpan">electron-builder.builder.</span>createTargets
            <span class="apidocSignatureSpan">(platforms, type, arch)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.builder.normalizeOptions">
            function <span class="apidocSignatureSpan">electron-builder.builder.</span>normalizeOptions
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.cliOptions">module electron-builder.cliOptions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.cliOptions.createYargs">
            function <span class="apidocSignatureSpan">electron-builder.cliOptions.</span>createYargs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.codeSign">module electron-builder.codeSign</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.codeSign.createKeychain">
            function <span class="apidocSignatureSpan">electron-builder.codeSign.</span>createKeychain
            <span class="apidocSignatureSpan">(_x3, _x4, _x5, _x6, _x7)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.codeSign.downloadCertificate">
            function <span class="apidocSignatureSpan">electron-builder.codeSign.</span>downloadCertificate
            <span class="apidocSignatureSpan">(_x, _x2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.codeSign.findIdentity">
            function <span class="apidocSignatureSpan">electron-builder.codeSign.</span>findIdentity
            <span class="apidocSignatureSpan">(certType, qualifier, keychain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.codeSign.sign">
            function <span class="apidocSignatureSpan">electron-builder.codeSign.</span>sign
            <span class="apidocSignatureSpan">(path, name, keychain)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.codeSign.</span>appleCertificatePrefixes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-builder.codeSign.</span>findIdentityRawResult</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.dmg">module electron-builder.dmg</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.dmg.DmgTarget">
            function <span class="apidocSignatureSpan">electron-builder.dmg.</span>DmgTarget
            <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.dmg.attachAndExecute">
            function <span class="apidocSignatureSpan">electron-builder.dmg.</span>attachAndExecute
            <span class="apidocSignatureSpan">(_x2, _x3, _x4)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.fileMatcher">module electron-builder.fileMatcher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.fileMatcher.FileMatcher">
            function <span class="apidocSignatureSpan">electron-builder.fileMatcher.</span>FileMatcher
            <span class="apidocSignatureSpan">(from, to, macroExpander, patterns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.fileMatcher.copyFiles">
            function <span class="apidocSignatureSpan">electron-builder.fileMatcher.</span>copyFiles
            <span class="apidocSignatureSpan">(patterns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.fileMatcher.createFileMatcher">
            function <span class="apidocSignatureSpan">electron-builder.fileMatcher.</span>createFileMatcher
            <span class="apidocSignatureSpan">(info, appDir, resourcesPath, macroExpander, platformSpecificBuildOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.fileMatcher.getFileMatchers">
            function <span class="apidocSignatureSpan">electron-builder.fileMatcher.</span>getFileMatchers
            <span class="apidocSignatureSpan">(config, name, defaultSrc, defaultDest, allowAdvancedMatching, macroExpander, customBuildOptions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.fileTransformer">module electron-builder.fileTransformer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.fileTransformer.createElectronCompilerHost">
            function <span class="apidocSignatureSpan">electron-builder.fileTransformer.</span>createElectronCompilerHost
            <span class="apidocSignatureSpan">(projectDir, cacheDir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.fileTransformer.createTransformer">
            function <span class="apidocSignatureSpan">electron-builder.fileTransformer.</span>createTransformer
            <span class="apidocSignatureSpan">(_x, _x2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.fileTransformer.isElectronCompileUsed">
            function <span class="apidocSignatureSpan">electron-builder.fileTransformer.</span>isElectronCompileUsed
            <span class="apidocSignatureSpan">(info)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.filter">module electron-builder.filter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.filter.createFilter">
            function <span class="apidocSignatureSpan">electron-builder.filter.</span>createFilter
            <span class="apidocSignatureSpan">(src, patterns, ignoreFiles, rawFilter, excludePatterns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.filter.hasMagic">
            function <span class="apidocSignatureSpan">electron-builder.filter.</span>hasMagic
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.forge_maker">module electron-builder.forge_maker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.forge_maker.buildForge">
            function <span class="apidocSignatureSpan">electron-builder.forge_maker.</span>buildForge
            <span class="apidocSignatureSpan">(appDir, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.fpm">module electron-builder.fpm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.fpm.default">
            function <span class="apidocSignatureSpan">electron-builder.fpm.</span>default
            <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.linuxPackager">module electron-builder.linuxPackager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.linuxPackager.LinuxPackager">
            function <span class="apidocSignatureSpan">electron-builder.linuxPackager.</span>LinuxPackager
            <span class="apidocSignatureSpan">(_platformPackager || _load_platformPackager()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.mac">module electron-builder.mac</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.mac.createApp">
            function <span class="apidocSignatureSpan">electron-builder.mac.</span>createApp
            <span class="apidocSignatureSpan">(_x, _x2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.mac.filterCFBundleIdentifier">
            function <span class="apidocSignatureSpan">electron-builder.mac.</span>filterCFBundleIdentifier
            <span class="apidocSignatureSpan">(identifier)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.macPackager">module electron-builder.macPackager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.macPackager.default">
            function <span class="apidocSignatureSpan">electron-builder.macPackager.</span>default
            <span class="apidocSignatureSpan">(_platformPackager || _load_platformPackager()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.nsis">module electron-builder.nsis</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.nsis.AppPackageHelper">
            function <span class="apidocSignatureSpan">electron-builder.nsis.</span>AppPackageHelper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.nsis.NsisTarget">
            function <span class="apidocSignatureSpan">electron-builder.nsis.</span>NsisTarget
            <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.packager">module electron-builder.packager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.packager.Packager">
            function <span class="apidocSignatureSpan">electron-builder.packager.</span>Packager
            <span class="apidocSignatureSpan">(options, cancellationToken)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.packager.checkWineVersion">
            function <span class="apidocSignatureSpan">electron-builder.packager.</span>checkWineVersion
            <span class="apidocSignatureSpan">(_x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.packager.normalizePlatforms">
            function <span class="apidocSignatureSpan">electron-builder.packager.</span>normalizePlatforms
            <span class="apidocSignatureSpan">(rawPlatforms)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.pkg">module electron-builder.pkg</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.pkg.PkgTarget">
            function <span class="apidocSignatureSpan">electron-builder.pkg.</span>PkgTarget
            <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.pkg.prepareProductBuildArgs">
            function <span class="apidocSignatureSpan">electron-builder.pkg.</span>prepareProductBuildArgs
            <span class="apidocSignatureSpan">(identity, keychain)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.platformPackager">module electron-builder.platformPackager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.platformPackager.PlatformPackager">
            function <span class="apidocSignatureSpan">electron-builder.platformPackager.</span>PlatformPackager
            <span class="apidocSignatureSpan">(info)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.platformPackager.normalizeExt">
            function <span class="apidocSignatureSpan">electron-builder.platformPackager.</span>normalizeExt
            <span class="apidocSignatureSpan">(ext)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.readInstalled">module electron-builder.readInstalled</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.readInstalled.readInstalled">
            function <span class="apidocSignatureSpan">electron-builder.</span>readInstalled
            <span class="apidocSignatureSpan">(_x)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.readPackageJson">module electron-builder.readPackageJson</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.readPackageJson.readPackageJson">
            function <span class="apidocSignatureSpan">electron-builder.</span>readPackageJson
            <span class="apidocSignatureSpan">(_x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.readPackageJson.doLoadConfig">
            function <span class="apidocSignatureSpan">electron-builder.readPackageJson.</span>doLoadConfig
            <span class="apidocSignatureSpan">(_x4, _x5)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.readPackageJson.getElectronVersion">
            function <span class="apidocSignatureSpan">electron-builder.readPackageJson.</span>getElectronVersion
            <span class="apidocSignatureSpan">(_x7, _x8, _x9)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.readPackageJson.loadConfig">
            function <span class="apidocSignatureSpan">electron-builder.readPackageJson.</span>loadConfig
            <span class="apidocSignatureSpan">(_x6)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.readPackageJson.validateConfig">
            function <span class="apidocSignatureSpan">electron-builder.readPackageJson.</span>validateConfig
            <span class="apidocSignatureSpan">(_x10)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.repositoryInfo">module electron-builder.repositoryInfo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.repositoryInfo.getRepositoryInfo">
            function <span class="apidocSignatureSpan">electron-builder.repositoryInfo.</span>getRepositoryInfo
            <span class="apidocSignatureSpan">(projectDir, metadata, devMetadata)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.snap">module electron-builder.snap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.snap.default">
            function <span class="apidocSignatureSpan">electron-builder.snap.</span>default
            <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.targetFactory">module electron-builder.targetFactory</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.targetFactory.NoOpTarget">
            function <span class="apidocSignatureSpan">electron-builder.targetFactory.</span>NoOpTarget
            <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.targetFactory.computeArchToTargetNamesMap">
            function <span class="apidocSignatureSpan">electron-builder.targetFactory.</span>computeArchToTargetNamesMap
            <span class="apidocSignatureSpan">(raw, options, platform)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.targetFactory.createCommonTarget">
            function <span class="apidocSignatureSpan">electron-builder.targetFactory.</span>createCommonTarget
            <span class="apidocSignatureSpan">(target, outDir, packager)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.targetFactory.createTargets">
            function <span class="apidocSignatureSpan">electron-builder.targetFactory.</span>createTargets
            <span class="apidocSignatureSpan">(nameToTarget, rawList, outDir, packager, cleanupTasks)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.winPackager">module electron-builder.winPackager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.winPackager.WinPackager">
            function <span class="apidocSignatureSpan">electron-builder.winPackager.</span>WinPackager
            <span class="apidocSignatureSpan">(_platformPackager || _load_platformPackager()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.windowsCodeSign">module electron-builder.windowsCodeSign</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.windowsCodeSign.getSignVendorPath">
            function <span class="apidocSignatureSpan">electron-builder.windowsCodeSign.</span>getSignVendorPath
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.windowsCodeSign.getToolPath">
            function <span class="apidocSignatureSpan">electron-builder.windowsCodeSign.</span>getToolPath
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.windowsCodeSign.sign">
            function <span class="apidocSignatureSpan">electron-builder.windowsCodeSign.</span>sign
            <span class="apidocSignatureSpan">(_x)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-builder.yarn">module electron-builder.yarn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.yarn.getGypEnv">
            function <span class="apidocSignatureSpan">electron-builder.yarn.</span>getGypEnv
            <span class="apidocSignatureSpan">(frameworkInfo, platform, arch, buildFromSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.yarn.installOrRebuild">
            function <span class="apidocSignatureSpan">electron-builder.yarn.</span>installOrRebuild
            <span class="apidocSignatureSpan">(_x, _x2, _x3, _x4, _x5)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-builder.yarn.rebuild">
            function <span class="apidocSignatureSpan">electron-builder.yarn.</span>rebuild
            <span class="apidocSignatureSpan">(_x9, _x10)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder" id="apidoc.module.electron-builder">module electron-builder</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.Packager" id="apidoc.element.electron-builder.Packager">
        function <span class="apidocSignatureSpan">electron-builder.</span>Packager
        <span class="apidocSignatureSpan">(options, cancellationToken)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Packager {
    //noinspection JSUnusedGlobalSymbols
    constructor(options, cancellationToken) {
        this.options = options;
        this.cancellationToken = cancellationToken;
        this.isTwoPackageJsonProjectLayoutUsed = true;
        this.eventEmitter = new (_events || _load_events()).EventEmitter();
        this.tempDirManager = new (_tmp || _load_tmp()).TmpDir();
        this._repositoryInfo = new (_electronBuilderUtil || _load_electronBuilderUtil()).Lazy(() =&gt; (0, (_repositoryInfo || _load_repositoryInfo
()).getRepositoryInfo)(this.projectDir, this.metadata, this.devMetadata));
        this.afterPackHandlers = [];
        this.projectDir = options.projectDir == null ? process.cwd() : _path.resolve(options.projectDir);
        this.prepackaged = options.prepackaged == null ? null : _path.resolve(this.projectDir, options.prepackaged);
    }
    get isPrepackedAppAsar() {
        return this._isPrepackedAppAsar;
    }
    get config() {
        return this._config;
    }
    get repositoryInfo() {
        return this._repositoryInfo.value;
    }
    addAfterPackHandler(handler) {
        this.afterPackHandlers.push(handler);
    }
    artifactCreated(handler) {
        addHandler(this.eventEmitter, "artifactCreated", handler);
        return this;
    }
    dispatchArtifactCreated(event) {
        this.eventEmitter.emit("artifactCreated", event);
    }
    build() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            //noinspection JSDeprecatedSymbols
            const devMetadataFromOptions = _this.options.devMetadata;
            if (devMetadataFromOptions != null) {
                (0, (_log || _load_log()).warn)("devMetadata is deprecated, please use config instead");
            }
            let configPath = null;
            let configFromOptions = _this.options.config;
            if (typeof configFromOptions === "string") {
                // it is a path to config file
                configPath = configFromOptions;
                configFromOptions = null;
            }
            if (devMetadataFromOptions != null) {
                if (configFromOptions != null) {
                    throw new Error("devMetadata and config cannot be used in conjunction");
                }
                configFromOptions = devMetadataFromOptions.build;
            }
            const projectDir = _this.projectDir;
            const fileOrPackageConfig = yield configPath == null ? (0, (_readPackageJson || _load_readPackageJson()).loadConfig)(
projectDir) : (0, (_readPackageJson || _load_readPackageJson()).doLoadConfig)(_path.resolve(projectDir, configPath), projectDir);
            const config = (0, (_deepAssign || _load_deepAssign()).deepAssign)({}, fileOrPackageConfig, configFromOptions);
            const extraMetadata = _this.options.extraMetadata;
            if (extraMetadata != null) {
                const extraBuildMetadata = extraMetadata.build;
                if (extraBuildMetadata != null) {
                    (0, (_deepAssign || _load_deepAssign()).deepAssign)(config, extraBuildMetadata);
                    delete extraMetadata.build;
                }
                if (extraMetadata.directories != null) {
                    (0, (_log || _load_log()).warn)(`--em.directories is deprecated, please specify as --em.build.directories"`);
                    (0, (_deepAssign || _load_deepAssign()).deepAssign)(config, { directories: extraMetadata.directories });
                    delete extraMetadata.directories;
                }
            }
            yield (0, (_readPackageJson || _load_readPackageJson()).validateConfig)(config);
            _this._config = config;
            _this.appDir = yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).computeDefaultAppDirectory)(projectDir
, (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(config.directories, function (it) {
                return it.app;
            }));
            _this.isTwoPackageJsonProjectLayoutUsed = _this.appDir !== projectD ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (options.draft === undefined &amp;&amp; !(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process
.env.EP_DRAFT)) {
    options.draft = process.env.EP_DRAFT.toLowerCase() === "true";
}
if (options.prerelease === undefined &amp;&amp; !(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process
.env.EP_PRELEASE)) {
    options.prerelease = process.env.EP_PRELEASE.toLowerCase() === "true";
}
const cancellationToken = new (_CancellationToken || _load_CancellationToken()).CancellationToken();
const packager = new (_packager || _load_packager()).<span class="apidocCodeKeywordSpan">Packager</span>(options, cancellationToken
);
// because artifact event maybe dispatched several times for different publish providers
const artifactPaths = new Set();
packager.artifactCreated(function (event) {
    if (event.file != null) {
        artifactPaths.add(event.file);
    }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.Platform" id="apidoc.element.electron-builder.Platform">
        function <span class="apidocSignatureSpan">electron-builder.</span>Platform
        <span class="apidocSignatureSpan">(name, buildConfigurationKey, nodeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Platform {
    constructor(name, buildConfigurationKey, nodeName) {
        this.name = name;
        this.buildConfigurationKey = buildConfigurationKey;
        this.nodeName = nodeName;
    }
    toString() {
        return this.name;
    }
    createTarget(type) {
        for (var _len = arguments.length, archs = Array(_len &gt; 1 ? _len - 1 : 0), _key = 1; _key &lt; _len; _key++) {
            archs[_key - 1] = arguments[_key];
        }

        if (type == null &amp;&amp; (archs == null || archs.length === 0)) {
            return new Map([[this, new Map()]]);
        }
        const archToType = new Map();
        if (this === Platform.MAC) {
            archs = [Arch.x64];
        }
        for (const arch of archs == null || archs.length === 0 ? [archFromString(process.arch)] : archs) {
            archToType.set(arch, type == null ? [] : Array.isArray(type) ? type : [type]);
        }
        return new Map([[this, archToType]]);
    }
    static current() {
        return Platform.fromString(process.platform);
    }
    static fromString(name) {
        name = name.toLowerCase();
        switch (name) {
            case Platform.MAC.nodeName:
            case Platform.MAC.name:
                return Platform.MAC;
            case Platform.WINDOWS.nodeName:
            case Platform.WINDOWS.name:
            case Platform.WINDOWS.buildConfigurationKey:
                return Platform.WINDOWS;
            case Platform.LINUX.nodeName:
                return Platform.LINUX;
            default:
                throw new Error(`Unknown platform: ${name}`);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.Target" id="apidoc.element.electron-builder.Target">
        function <span class="apidocSignatureSpan">electron-builder.</span>Target
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Target {
    constructor(name) {
        let isAsyncSupported = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : true;

        this.name = name;
        this.isAsyncSupported = isAsyncSupported;
    }
    finishBuild() {
        return Promise.resolve();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.archFromString" id="apidoc.element.electron-builder.archFromString">
        function <span class="apidocSignatureSpan">electron-builder.</span>archFromString
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function archFromString(name) {
    if (name === "x64") {
        return Arch.x64;
    }
    if (name === "ia32") {
        return Arch.ia32;
    }
    if (name === "armv7l") {
        return Arch.armv7l;
    }
    throw new Error(`Unsupported arch ${name}`);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.build" id="apidoc.element.electron-builder.build">
        function <span class="apidocSignatureSpan">electron-builder.</span>build
        <span class="apidocSignatureSpan">(_x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function build(_x) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
"use strict"

const builder = require("electron-builder")
const Platform = builder.Platform

// Promise is returned
builder.<span class="apidocCodeKeywordSpan">build</span>({
targets: Platform.MAC.createTarget(),
config: {
 "//": "build options, see https://goo.gl/ZhRfla"
}
})
.then(() =&gt; {
  // handle result
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.buildForge" id="apidoc.element.electron-builder.buildForge">
        function <span class="apidocSignatureSpan">electron-builder.</span>buildForge
        <span class="apidocSignatureSpan">(appDir, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buildForge(appDir, options) {
    return (0, (_builder || _load_builder()).build)(Object.assign({
        prepackaged: appDir,
        config: {
            directories: {
                // https://github.com/electron-userland/electron-forge/blob/master/src/makers/generic/zip.js
                output: _path.resolve(appDir, "..", "make")
            }
        }
    }, options));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.createTargets" id="apidoc.element.electron-builder.createTargets">
        function <span class="apidocSignatureSpan">electron-builder.</span>createTargets
        <span class="apidocSignatureSpan">(platforms, type, arch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTargets(platforms, type, arch) {
    const targets = new Map();
    for (const platform of platforms) {
        const archs = platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC ? [(_electronBuilderCore ||
_load_electronBuilderCore()).Arch.x64] : arch === "all" ? [(_electronBuilderCore || _load_electronBuilderCore()).Arch.x64, (_electronBuilderCore
 || _load_electronBuilderCore()).Arch.ia32] : [(0, (_electronBuilderCore || _load_electronBuilderCore()).archFromString)(arch ==
null ? process.arch : arch)];
        const archToType = new Map();
        targets.set(platform, archToType);
        for (const arch of archs) {
            archToType.set(arch, type == null ? [] : [type]);
        }
    }
    return targets;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (target == null) {
        target = factory(outDir);
        nameToTarget.set(name, target);
    }
    result.push(target);
};
const targets = normalizeTargets(rawList, packager.defaultTarget);
packager.<span class="apidocCodeKeywordSpan">createTargets</span>(targets, mapper, cleanupTasks);
return result;
}
function normalizeTargets(targets, defaultTarget) {
const list = [];
for (const t of targets) {
    const name = t.toLowerCase().trim();
    if (name === (_electronBuilderCore || _load_electronBuilderCore()).DEFAULT_TARGET) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.getArchSuffix" id="apidoc.element.electron-builder.getArchSuffix">
        function <span class="apidocSignatureSpan">electron-builder.</span>getArchSuffix
        <span class="apidocSignatureSpan">(arch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getArchSuffix(arch) {
    return arch === Arch.x64 ? "" : `-${Arch[arch]}`;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.ArchiveTarget" id="apidoc.module.electron-builder.ArchiveTarget">module electron-builder.ArchiveTarget</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.ArchiveTarget.ArchiveTarget" id="apidoc.element.electron-builder.ArchiveTarget.ArchiveTarget">
        function <span class="apidocSignatureSpan">electron-builder.</span>ArchiveTarget
        <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ArchiveTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
    constructor(name, outDir, packager) {
        super(name);
        this.outDir = outDir;
        this.packager = packager;
        this.options = this.packager.config[this.name];
    }
    build(appOutDir, arch) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = _this.packager;
            const isMac = packager.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC;
            const outDir = _this.outDir;
            const format = _this.name;
            (0, (_log || _load_log()).log)(`Building ${isMac ? "macOS " : ""}${format}`);
            // we use app name here - see https://github.com/electron-userland/electron-builder/pull/204
            const outFile = function () {
                switch (packager.platform) {
                    case (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC:
                        return _path.join(outDir, packager.expandArtifactNamePattern(_this.options, format, arch, "${productName
}-${version}-${os}.${ext}"));
                    case (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS:
                        return _path.join(outDir, packager.generateName(format, arch, false, "win"));
                    case (_electronBuilderCore || _load_electronBuilderCore()).Platform.LINUX:
                        return _path.join(outDir, packager.generateName(format, arch, true));
                    default:
                        throw new Error(`Unknown platform: ${packager.platform}`);
                }
            }();
            if (format.startsWith("tar.")) {
                yield (0, (_archive || _load_archive()).tar)(packager.config.compression, format, outFile, appOutDir, isMac);
            } else {
                yield (0, (_archive || _load_archive()).archive)(packager.config.compression, format, outFile, appOutDir);
            }
            packager.dispatchArtifactCreated(outFile, _this, (_electronBuilderCore || _load_electronBuilderCore()).Arch.x64, isMac
 ? packager.generateName2(format, "mac", true) : packager.generateName(format, arch, true, packager.platform === (_electronBuilderCore
 || _load_electronBuilderCore()).Platform.WINDOWS ? "win" : null));
        })();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            list.push(name);
        }
    }
    return list;
}
function createCommonTarget(target, outDir, packager) {
    if (archiveTargets.has(target)) {
        return new (_ArchiveTarget || _load_ArchiveTarget()).<span class="apidocCodeKeywordSpan">ArchiveTarget</span>(target, outDir
, packager);
    } else if (target === (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET) {
        return new NoOpTarget((_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET);
    } else {
        throw new Error(`Unknown target: ${target}`);
    }
}
class NoOpTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.LinuxTargetHelper" id="apidoc.module.electron-builder.LinuxTargetHelper">module electron-builder.LinuxTargetHelper</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.LinuxTargetHelper.LinuxTargetHelper" id="apidoc.element.electron-builder.LinuxTargetHelper.LinuxTargetHelper">
        function <span class="apidocSignatureSpan">electron-builder.</span>LinuxTargetHelper
        <span class="apidocSignatureSpan">(packager)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class LinuxTargetHelper {
    constructor(packager) {
        this.packager = packager;
        this.maxIconPath = null;
        this.icons = this.computeDesktopIcons();
    }
    // must be name without spaces and other special characters, but not product name used
    computeDesktopIcons() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = _this.packager;
            let customIconSetDir = packager.platformSpecificBuildOptions.icon;
            if (customIconSetDir != null) {
                let iconDir = _path.resolve(packager.buildResourcesDir, customIconSetDir);
                const stat = yield (0, (_fs || _load_fs()).statOrNull)(iconDir);
                if (stat == null || !stat.isDirectory()) {
                    iconDir = _path.resolve(packager.projectDir, customIconSetDir);
                }
                try {
                    return yield _this.iconsFromDir(iconDir);
                } catch (e) {
                    if (e.code === "ENOENT") {
                        throw new Error(`Icon set directory ${iconDir} doesn't exist`);
                    } else if (e.code === "ENOTDIR") {
                        throw new Error(`linux.icon must be set to an icon set directory, but ${iconDir} is not a directory. Please
 see https://github.com/electron-userland/electron-builder/wiki/Options#LinuxBuildOptions-icon`);
                    } else {
                        throw e;
                    }
                }
            }
            const resourceList = yield packager.resourceList;
            if (resourceList.indexOf("icons") !== -1) {
                return yield _this.iconsFromDir(_path.join(packager.buildResourcesDir, "icons"));
            } else {
                const iconDir = yield packager.getTempFile("linux.iconset");
                (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(iconDir);
                return yield _this.createFromIcns(iconDir);
            }
        })();
    }
    iconsFromDir(iconDir) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const mappings = [];
            let maxSize = 0;
            for (const file of yield (0, (_fsExtraP || _load_fsExtraP()).readdir)(iconDir)) {
                if (file.endsWith(".png") || file.endsWith(".PNG")) {
                    // If parseInt encounters a character that is not a numeral in the specified radix,
                    // it returns the integer value parsed up to that point
                    try {
                        let sizeString = file.match(/\d+/);
                        const size = sizeString == null ? 0 : parseInt(sizeString[0], 10);
                        if (size &gt; 0) {
                            const iconPath = `${iconDir}/${file}`;
                            mappings.push([iconPath, `${size}x${size}/apps/${_this2.packager.executableName}.png`]);
                            if (size &gt; maxSize) {
                                maxSize = size;
                                _this2.maxIconPath = iconPath;
                            }
                        }
                    } catch (e) {
                        console.error(e);
                    }
                }
            }
            if (mappings.length === 0) {
                throw new Error(`Icon set directory ${iconDir} doesn't contain icons`);
            }
            return mappings;
        })();
    }
    getIcns() {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const build = _this3.packager.config;
            let iconPath = (build.mac || {}).icon || build.icon;
            if (iconPath != null &amp;&amp; !iconPath.endsWith(".icns")) {
                iconPath += ".icns";
            }
            return iconPath == null ? yield _this3.packager.getDefaultIcon("icns") : _path.resolve(_this3.packager.projectDir, iconPath
);
        })();
    }
    getDescription(options) {
        return options.de ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
get defaultTarget() {
    return ["appimage"];
}
createTargets(targets, mapper, cleanupTasks) {
    let helper;
    const getHelper = () =&gt; {
        if (helper == null) {
            helper = new (_LinuxTargetHelper || _load_LinuxTargetHelper()).<span class="apidocCodeKeywordSpan">LinuxTargetHelper
</span>(this);
        }
        return helper;
    };
    for (const name of targets) {
        if (name === (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET) {
            continue;
        }
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.PublishManager" id="apidoc.module.electron-builder.PublishManager">module electron-builder.PublishManager</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.PublishManager.PublishManager" id="apidoc.element.electron-builder.PublishManager.PublishManager">
        function <span class="apidocSignatureSpan">electron-builder.</span>PublishManager
        <span class="apidocSignatureSpan">(packager, publishOptions, cancellationToken)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PublishManager {
    constructor(packager, publishOptions, cancellationToken) {
        this.publishOptions = publishOptions;
        this.cancellationToken = cancellationToken;
        this.nameToPublisher = new Map();
        this.publishTasks = [];
        this.errors = [];
        this.isPublish = false;
        this.progress = process.stdout.isTTY ? new (_multiProgress || _load_multiProgress()).MultiProgress() : null;
        if (!(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isPullRequest)()) {
            if (publishOptions.publish === undefined) {
                if (process.env.npm_lifecycle_event === "release") {
                    publishOptions.publish = "always";
                } else {
                    const tag = getCiTag();
                    if (tag != null) {
                        (0, (_log || _load_log()).log)(`Tag ${tag} is defined, so artifacts will be published`);
                        publishOptions.publish = "onTag";
                    } else if ((_isCi || _load_isCi()).default) {
                        (0, (_log || _load_log()).log)("CI detected, so artifacts will be published if draft release exists");
                        publishOptions.publish = "onTagOrDraft";
                    }
                }
            }
            if (publishOptions.publish != null &amp;&amp; publishOptions.publish !== "never") {
                this.isPublish = publishOptions.publish !== "onTag" || getCiTag() != null;
            }
        } else if (publishOptions.publish !== "never") {
            (0, (_log || _load_log()).log)("Current build is a part of pull request, publishing will be skipped");
        }
        packager.addAfterPackHandler((() =&gt; {
            var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (event) {
                const packager = event.packager;
                if (event.electronPlatformName === "darwin") {
                    if (!event.targets.some(function (it) {
                        return it.name === "zip";
                    })) {
                        return;
                    }
                } else if (packager.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS) {
                    if (!event.targets.some(function (it) {
                        return isSuitableWindowsTarget(it);
                    })) {
                        return;
                    }
                } else {
                    return;
                }
                const publishConfigs = yield getPublishConfigsForUpdateInfo(packager, (yield getPublishConfigs(packager, null, event
.arch)), event.arch);
                if (publishConfigs == null || publishConfigs.length === 0) {
                    return;
                }
                let publishConfig = publishConfigs[0];
                if (packager.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS) {
                    const publisherName = yield packager.computedPublisherName.value;
                    if (publisherName != null) {
                        publishConfig = Object.assign({ publisherName: publisherName }, publishConfig);
                    }
                }
                yield (0, (_fsExtraP || _load_fsExtraP()).writeFile)(_path.join(packager.getResourcesDir(event.appOutDir), "app-
update.yml"), (0, (_jsYaml || _load_jsYaml()).safeDump)(publishConfig));
            });

            return function (_x) {
                return _ref.apply(this, arguments);
            };
        })());
        packager.artifactCreated(event =&gt; this.addTask(this.artifactCreated(event)));
    }
    artifactCreated(event) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = event.packager;
            const target = event.target;
            const publishConfigs = event.publishConfig == null ? yield getPublishConfigs(packager, target == null ? null : target
.options, event.arch) : [event.publishConfig];
            const eventFile = ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// because artifact event maybe dispatched several times for different publish providers
const artifactPaths = new Set();
packager.artifactCreated(function (event) {
    if (event.file != null) {
        artifactPaths.add(event.file);
    }
});
const publishManager = new (_PublishManager || _load_PublishManager()).<span class="apidocCodeKeywordSpan">PublishManager</span>(
packager, options, cancellationToken);
const buildPromise = packager.build().then(function () {
    return Array.from(artifactPaths);
});
process.on("SIGINT", function () {
    (0, (_log || _load_log()).warn)("Cancelled by SIGINT");
    cancellationToken.cancel();
    publishManager.cancelTasks();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.PublishManager.computeDownloadUrl" id="apidoc.element.electron-builder.PublishManager.computeDownloadUrl">
        function <span class="apidocSignatureSpan">electron-builder.PublishManager.</span>computeDownloadUrl
        <span class="apidocSignatureSpan">(publishConfig, fileName, packager)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function computeDownloadUrl(publishConfig, fileName, packager) {
    if (publishConfig.provider === "generic") {
        const baseUrlString = publishConfig.url;
        if (fileName == null) {
            return baseUrlString;
        }
        const baseUrl = (_url || _load_url()).parse(baseUrlString);
        return (_url || _load_url()).format(Object.assign({}, baseUrl, { pathname: _path.posix.resolve(baseUrl.pathname || "/",
encodeURI(fileName)) }));
    }
    let baseUrl;
    if (publishConfig.provider === "s3") {
        baseUrl = (0, (_publishOptions || _load_publishOptions()).s3Url)(publishConfig);
    } else {
        const gh = publishConfig;
        baseUrl = `${(0, (_publishOptions || _load_publishOptions()).githubUrl)(gh)}/${gh.owner}/${gh.repo}/releases/download/${
gh.vPrefixedTagName === false ? "" : "v"}${packager.appInfo.version}`;
    }
    if (fileName == null) {
        return baseUrl;
    }
    return `${baseUrl}/${encodeURI(fileName)}`;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.PublishManager.createPublisher" id="apidoc.element.electron-builder.PublishManager.createPublisher">
        function <span class="apidocSignatureSpan">electron-builder.PublishManager.</span>createPublisher
        <span class="apidocSignatureSpan">(context, version, publishConfig, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPublisher(context, version, publishConfig, options) {
    const provider = publishConfig.provider;
    switch (provider) {
        case "github":
            return new (_gitHubPublisher || _load_gitHubPublisher()).GitHubPublisher(context, publishConfig, version, options);
        case "bintray":
            return new (_BintrayPublisher || _load_BintrayPublisher()).BintrayPublisher(context, publishConfig, version, options
);
        case "generic":
            return null;
        default:
            const clazz = requireProviderClass(provider);
            return clazz == null ? null : new clazz(context, publishConfig);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.PublishManager.getPublishConfigs" id="apidoc.element.electron-builder.PublishManager.getPublishConfigs">
        function <span class="apidocSignatureSpan">electron-builder.PublishManager.</span>getPublishConfigs
        <span class="apidocSignatureSpan">(_x12, _x13, _x14)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPublishConfigs(_x12, _x13, _x14) {
    return _ref5.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.PublishManager.getPublishConfigsForUpdateInfo" id="apidoc.element.electron-builder.PublishManager.getPublishConfigsForUpdateInfo">
        function <span class="apidocSignatureSpan">electron-builder.PublishManager.</span>getPublishConfigsForUpdateInfo
        <span class="apidocSignatureSpan">(_x2, _x3, _x4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPublishConfigsForUpdateInfo(_x2, _x3, _x4) {
    return _ref2.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.WebInstallerTarget" id="apidoc.module.electron-builder.WebInstallerTarget">module electron-builder.WebInstallerTarget</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.WebInstallerTarget.WebInstallerTarget" id="apidoc.element.electron-builder.WebInstallerTarget.WebInstallerTarget">
        function <span class="apidocSignatureSpan">electron-builder.</span>WebInstallerTarget
        <span class="apidocSignatureSpan">(_nsis || _load_nsis()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebInstallerTarget extends (_nsis || _load_nsis()).NsisTarget {
    constructor(packager, outDir, targetName, packageHelper) {
        super(packager, outDir, targetName, packageHelper);
    }
    get isWebInstaller() {
        return true;
    }
    configureDefines(oneClick, defines) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            //noinspection ES6MissingAwait
            yield (_nsis || _load_nsis()).NsisTarget.prototype.configureDefines.call(_this, oneClick, defines);
            const packager = _this.packager;
            const options = _this.options;
            let appPackageUrl = options.appPackageUrl;
            if (appPackageUrl == null) {
                const publishConfigs = yield (0, (_PublishManager || _load_PublishManager()).getPublishConfigsForUpdateInfo)(packager
, (yield (0, (_PublishManager || _load_PublishManager()).getPublishConfigs)(packager, _this.options, null)), null);
                if (publishConfigs == null || publishConfigs.length === 0) {
                    throw new Error("Cannot compute app package download URL");
                }
                appPackageUrl = (0, (_PublishManager || _load_PublishManager()).computeDownloadUrl)(publishConfigs[0], null, packager
);
                defines.APP_PACKAGE_URL_IS_INCOMLETE = null;
            }
            defines.APP_PACKAGE_URL = appPackageUrl;
        })();
    }
    get installerFilenamePattern() {
        return "${productName} Web Setup ${version}.${ext}";
    }
    generateGitHubInstallerName() {
        const appInfo = this.packager.appInfo;
        const classifier = appInfo.name.toLowerCase() === appInfo.name ? "web-setup" : "WebSetup";
        return `${appInfo.name}-${classifier}-${appInfo.version}.exe`;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        for (const name of targets) {
if (name === (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET) {
    continue;
}
if (name === "nsis" || name === "portable") {
    mapper(name, outDir =&gt; new (_nsis || _load_nsis()).NsisTarget(this, outDir, name, getHelper()));
} else if (name === "nsis-web") {
    mapper(name, outDir =&gt; new (_WebInstallerTarget || _load_WebInstallerTarget()).<span class="apidocCodeKeywordSpan">WebInstallerTarget
</span>(this, outDir, name, getHelper()));
} else {
    const targetClass = (() =&gt; {
        switch (name) {
            case "squirrel":
                try {
                    return require("electron-builder-squirrel-windows").default;
                } catch (e) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.appImage" id="apidoc.module.electron-builder.appImage">module electron-builder.appImage</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.appImage.default" id="apidoc.element.electron-builder.appImage.default">
        function <span class="apidocSignatureSpan">electron-builder.appImage.</span>default
        <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AppImageTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
    constructor(ignored, packager, helper, outDir) {
        super("appImage");
        this.packager = packager;
        this.helper = helper;
        this.outDir = outDir;
        this.options = Object.assign({}, this.packager.platformSpecificBuildOptions, this.packager.config[this.name]);
        // we add X-AppImage-BuildId to ensure that new desktop file will be installed
        this.desktopEntry = (_bluebirdLst2 || _load_bluebirdLst2()).default.promisify((_uuid || _load_uuid()).v1)({ mac: false }).
then(uuid =&gt; helper.computeDesktopEntry(this.options, "AppRun", null, {
            "X-AppImage-Version": `${packager.appInfo.buildVersion}`,
            "X-AppImage-BuildId": uuid
        }));
    }
    build(appOutDir, arch) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            (0, (_log || _load_log()).log)(`Building AppImage for arch ${(_electronBuilderCore || _load_electronBuilderCore()).Arch
[arch]}`);
            const packager = _this.packager;
            // avoid spaces in the file name
            const resultFile = _path.join(_this.outDir, packager.generateName("AppImage", arch, true));
            yield (0, (_fs || _load_fs()).unlinkIfExists)(resultFile);
            const appImagePath = yield appImagePathPromise;
            const desktopFile = yield _this.desktopEntry;
            const args = ["-joliet", "on", "-volid", "AppImage", "-dev", resultFile, "-padding", "0", "-map", appOutDir, "/usr/bin
", "-map", _path.join(__dirname, "..", "..", "templates", "linux", "AppRun.sh"), "/AppRun",
            // we get executable name in the AppRun by desktop file name, so, must be named as executable
            "-map", desktopFile, `/${_this.packager.executableName}.desktop`];
            for (const _ref of yield _this.helper.icons) {
                var _ref2 = _slicedToArray(_ref, 2);

                const from = _ref2[0];
                const to = _ref2[1];

                args.push("-map", from, `/usr/share/icons/default/${to}`);
            }
            // must be after this.helper.icons call
            if (_this.helper.maxIconPath == null) {
                throw new Error("Icon is not provided");
            }
            args.push("-map", _this.helper.maxIconPath, "/.DirIcon");
            if (arch === (_electronBuilderCore || _load_electronBuilderCore()).Arch.x64) {
                const libDir = yield (0, (_binDownload || _load_binDownload()).getBin)("AppImage-packages", "10.03.17", "https://
bintray.com/electron-userland/bin/download_file?file_path=AppImage-packages-10.03.17-x64.7z", "172f9977fe9b24d35091d26ecbfebe2a14d96516a9c903e109e12b2a929042fe
");
                args.push("-map", libDir, "/usr/lib");
            }
            args.push("-chown_r", "0", "/", "--");
            args.push("-zisofs", `level=${process.env.ELECTRON_BUILDER_COMPRESSION_LEVEL || (packager.config.compression === "store
" ? "0" : "9")}:block_size=128k:by_magic=off`);
            args.push("set_filter_r", "--zisofs", "/");
            if (_this.packager.packagerOptions.effectiveOptionComputed != null &amp;&amp; (yield _this.packager.packagerOptions.effectiveOptionComputed
([args, desktopFile]))) {
                return;
            }
            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(process.arch !== "x64" || process.env.USE_SYSTEM_XORRISO
 === "true" || process.env.USE_SYSTEM_XORRISO === "" ? "xorriso" : _path.join(appImagePath, "xorriso"), args, {
                maxBuffer: 2 * 1024 * 1024
            });
            yield new (_bluebirdLst2 || _load_bluebirdLst2()).default(function (resolve, reject) {
                const rd = (0, (_fsExtraP || _load_fsExtraP()).createReadStream)(_path.join(appImagePath, arch === (_electronBuilderCore
 || _load_electronBuilderCore()).Arch.ia32 ? "32" : "64", "runtime"));
                rd.on("error", reject);
                const wr = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(resultFi ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
headerPickle.writeString(JSON.stringify(this.fs.header));
const headerBuf = headerPickle.toBuffer();
const sizePickle = pickle.createEmpty();
sizePickle.writeUInt32(headerBuf.length);
const sizeBuf = sizePickle.toBuffer();
const transformedFiles = this.transformedFiles;
const writeStream = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(this.outFile);
return new (_bluebirdLst2 || _load_bluebirdLst2()).<span class="apidocCodeKeywordSpan">default</span>((resolve, reject) =&gt; {
    writeStream.on("error", reject);
    writeStream.on("close", resolve);
    writeStream.write(sizeBuf);
    const w = index =&gt; {
        let data;
        while (true) {
            if (index &gt;= files.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.appInfo" id="apidoc.module.electron-builder.appInfo">module electron-builder.appInfo</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.appInfo.AppInfo" id="apidoc.element.electron-builder.appInfo.AppInfo">
        function <span class="apidocSignatureSpan">electron-builder.appInfo.</span>AppInfo
        <span class="apidocSignatureSpan">(metadata, info, buildVersion)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AppInfo {
    constructor(metadata, info, buildVersion) {
        this.metadata = metadata;
        this.info = info;
        this.description = (0, (_electronBuilderUtil || _load_electronBuilderUtil()).smarten)(this.metadata.description || "");
        this.version = metadata.version;
        this.buildNumber = this.config.buildVersion || process.env.TRAVIS_BUILD_NUMBER || process.env.APPVEYOR_BUILD_NUMBER || process
.env.CIRCLE_BUILD_NUM || process.env.BUILD_NUMBER;
        if ((0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(buildVersion)) {
            buildVersion = this.version;
            if (!(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(this.buildNumber)) {
                buildVersion += `.${this.buildNumber}`;
            }
            this.buildVersion = buildVersion;
        } else {
            this.buildVersion = buildVersion;
        }
        this.productName = this.config.productName || metadata.productName || metadata.name;
        this.productFilename = (0, (_sanitizeFilename || _load_sanitizeFilename()).default)(this.productName);
    }
    get config() {
        return this.info.config;
    }
    get versionInWeirdWindowsForm() {
        const parsedVersion = new (_semver || _load_semver()).SemVer(this.version);
        return `${parsedVersion.major}.${parsedVersion.minor}.${parsedVersion.patch}.${this.buildNumber || "0"}`;
    }
    get companyName() {
        return this.metadata.author.name;
    }
    get id() {
        let appId;
        if (this.config.appId != null) {
            appId = this.config.appId;
        }
        const generateDefaultAppId = () =&gt; {
            return `com.electron.${this.metadata.name.toLowerCase()}`;
        };
        if (appId != null &amp;&amp; (appId === "your.id" || (0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(
appId))) {
            const incorrectAppId = appId;
            appId = generateDefaultAppId();
            (0, (_log || _load_log()).warn)(`Do not use "${incorrectAppId}" as appId, "${appId}" will be used instead`);
        }
        return appId == null ? generateDefaultAppId() : appId;
    }
    get name() {
        return this.metadata.name;
    }
    get copyright() {
        const copyright = this.config.copyright;
        if (copyright != null) {
            return copyright;
        }
        return `Copyright Â© ${new Date().getFullYear()} ${this.metadata.author.name || this.productName}`;
    }
    computePackageUrl() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const url = _this.metadata.homepage;
            if (url != null) {
                return url;
            }
            const info = yield _this.info.repositoryInfo;
            return info == null || info.type !== "github" ? null : `https://${info.domain}/${info.user}/${info.project}`;
        })();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.codeSigningInfo = (0, (_codeSign || _load_codeSign()).createKeychain)(info.tempDirManager, this.packagerOptions.cscLink
, this.getCscPassword(), this.packagerOptions.cscInstallerLink, this.packagerOptions.cscInstallerKeyPassword);
}
    }
    get defaultTarget() {
return ["zip", "dmg"];
    }
    prepareAppInfo(appInfo) {
return new (_appInfo || _load_appInfo()).<span class="apidocCodeKeywordSpan">AppInfo</span>(appInfo.metadata, this.info, this.platformSpecificBuildOptions
.bundleVersion);
    }
    getIconPath() {
var _this = this;

return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
    let iconPath = _this.platformSpecificBuildOptions.icon || _this.config.icon;
    if (iconPath != null &amp;&amp; !iconPath.endsWith(".icns")) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.appx" id="apidoc.module.electron-builder.appx">module electron-builder.appx</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.appx.default" id="apidoc.element.electron-builder.appx.default">
        function <span class="apidocSignatureSpan">electron-builder.appx.</span>default
        <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AppXTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
    constructor(packager, outDir) {
        super("appx");
        this.packager = packager;
        this.outDir = outDir;
        this.options = Object.assign({}, this.packager.platformSpecificBuildOptions, this.packager.config.appx);
        const osVersion = (0, (_os || _load_os()).release)();
        if (process.platform !== "win32" || parseInt(osVersion.substring(0, osVersion.indexOf(".")), 10) &lt; 10) {
            throw new Error("AppX is supported only on Windows 10");
        }
    }
    // no flatten - use asar or npm 3 or yarn
    build(appOutDir, arch) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = _this.packager;
            if ((yield packager.cscInfo) == null) {
                throw new Error("AppX package must be signed, but certificate is not set, please see https://github.com/electron
-userland/electron-builder/wiki/Code-Signing");
            }
            let publisher = _this.options.publisher;
            if (publisher == null) {
                const computed = yield packager.computedPublisherName.value;
                if (computed != null) {
                    publisher = `CN=${computed[0]}`;
                }
                if (publisher == null) {
                    throw new Error("Please specify appx.publisher");
                }
            }
            const appInfo = packager.appInfo;
            const preAppx = _path.join(_this.outDir, `pre-appx-${(0, (_electronBuilderCore || _load_electronBuilderCore()).getArchSuffix
)(arch)}`);
            yield (0, (_fsExtraP || _load_fsExtraP()).emptyDir)(preAppx);
            const vendorPath = yield (0, (_windowsCodeSign || _load_windowsCodeSign()).getSignVendorPath)();
            const templatePath = _path.join(__dirname, "..", "..", "templates", "appx");
            const safeName = (0, (_sanitizeFilename || _load_sanitizeFilename()).default)(appInfo.name);
            const resourceList = yield packager.resourceList;
            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([(_bluebirdLst2 || _load_bluebirdLst2()).default.map(["44x44
", "50x50", "150x150", "310x150"], function (size) {
                const target = _path.join(preAppx, "assets", `${safeName}.${size}.png`);
                if (resourceList.indexOf(`${size}.png`) !== -1) {
                    return (0, (_fsExtraP || _load_fsExtraP()).copy)(_path.join(packager.buildResourcesDir, `${size}.png`), target
);
                }
                return (0, (_fsExtraP || _load_fsExtraP()).copy)(_path.join(vendorPath, "appxAssets", `SampleAppx.${size}.png`),
target);
            }), (0, (_fs || _load_fs()).copyDir)(appOutDir, _path.join(preAppx, "app")), _this.writeManifest(templatePath, preAppx
, safeName, arch, publisher)]);
            const destination = _path.join(_this.outDir, packager.generateName("appx", arch, false));
            const args = ["pack", "/o", "/d", preAppx, "/p", destination];
            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(_this.options.makeappxArgs, function (it) {
                return args.push.apply(args, _toConsumableArray(it));
            });
            // wine supports only ia32 binary in any case makeappx crashed on wine
            // await execWine(path.join(await getSignVendorPath(), "windows-10", process.platform === "win32" ? process.arch : "
ia32", "makeappx.exe"), args)
            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).spawn)(_path.join(vendorPath, "windows-10", arch === (
_electronBuilderCore || _load_electronBuilderCore()).Arch.ia32 ? "ia32" : "x64", "makeappx.exe"), args);
            yield packager.sign(destination);
            packager.dispatchArtifactCreated(destination, _this, arch, packager.generateName("appx", arch, true));
        })();
    }
    writeManifest(templatePath, preAppx, safeName, arch, publisher) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLs ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
headerPickle.writeString(JSON.stringify(this.fs.header));
const headerBuf = headerPickle.toBuffer();
const sizePickle = pickle.createEmpty();
sizePickle.writeUInt32(headerBuf.length);
const sizeBuf = sizePickle.toBuffer();
const transformedFiles = this.transformedFiles;
const writeStream = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(this.outFile);
return new (_bluebirdLst2 || _load_bluebirdLst2()).<span class="apidocCodeKeywordSpan">default</span>((resolve, reject) =&gt; {
    writeStream.on("error", reject);
    writeStream.on("close", resolve);
    writeStream.write(sizeBuf);
    const w = index =&gt; {
        let data;
        while (true) {
            if (index &gt;= files.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.asar" id="apidoc.module.electron-builder.asar">module electron-builder.asar</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.asar.AsarFilesystem" id="apidoc.element.electron-builder.asar.AsarFilesystem">
        function <span class="apidocSignatureSpan">electron-builder.asar.</span>AsarFilesystem
        <span class="apidocSignatureSpan">(src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AsarFilesystem {
    constructor(src) {
        let header = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : new Node();
        let headerSize = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : -1;

        this.src = src;
        this.header = header;
        this.headerSize = headerSize;
        this.offset = UINT64(0);
        if (this.header.files == null) {
            this.header.files = {};
        }
    }
    searchNodeFromDirectory(p) {
        let node = this.header;
        for (const dir of p.split(_path.sep)) {
            if (dir !== ".") {
                node = node.files[dir];
            }
        }
        return node;
    }
    getOrCreateNode(p) {
        p = _path.relative(this.src, p);
        if (p == null || p.length === 0) {
            return this.header;
        }
        const name = _path.basename(p);
        const dirNode = this.searchNodeFromDirectory(_path.dirname(p));
        if (dirNode.files == null) {
            dirNode.files = {};
        }
        let result = dirNode.files[name];
        if (result == null) {
            result = new Node();
            dirNode.files[name] = result;
        }
        return result;
    }
    insertDirectory(p) {
        let unpacked = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : false;

        const node = this.getOrCreateNode(p);
        node.files = {};
        if (unpacked) {
            node.unpacked = unpacked;
        }
        return node.files;
    }
    insertFileNode(node, stat, file) {
        if (node.size &gt; 4294967295) {
            throw new Error(`${file}: file size can not be larger than 4.2GB`);
        }
        node.offset = this.offset.toString();
        if (process.platform !== "win32" &amp;&amp; stat.mode &amp; 0o100) {
            node.executable = true;
        }
        this.offset.add(UINT64(node.size));
    }
    getNode(p) {
        const node = this.searchNodeFromDirectory(_path.dirname(p));
        return node.files[_path.basename(p)];
    }
    getFile(p) {
        let followLinks = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : true;

        const info = this.getNode(p);
        // if followLinks is false we don't resolve symlinks
        return followLinks &amp;&amp; info.link != null ? this.getFile(info.link) : info;
    }
    readJson(file) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            return JSON.parse((yield _this.readFile(file)).toString());
        })();
    }
    readFile(file) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            return yield readFileFromAsar(_this2, file, _this2.getFile(file));
        })();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
class AsarPackager {
constructor(src, destination, options, unpackPattern, transformer) {
    this.src = src;
    this.options = options;
    this.unpackPattern = unpackPattern;
    this.transformer = transformer;
    this.fs = new (_asar || _load_asar()).<span class="apidocCodeKeywordSpan">AsarFilesystem</span>(this.src);
    this.metadata = new Map();
    this.outFile = _path.join(destination, "app.asar");
}
// sort files to minimize file change (i.e. asar file is not changed dramatically on small change)
pack(filter, isElectronCompile) {
    var _this = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.asar.Node" id="apidoc.element.electron-builder.asar.Node">
        function <span class="apidocSignatureSpan">electron-builder.asar.</span>Node
        <span class="apidocSignatureSpan">{{signature}}</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Node {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.asar.readAsar" id="apidoc.element.electron-builder.asar.readAsar">
        function <span class="apidocSignatureSpan">electron-builder.asar.</span>readAsar
        <span class="apidocSignatureSpan">(_x5)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readAsar(_x5) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.asar.readAsarJson" id="apidoc.element.electron-builder.asar.readAsarJson">
        function <span class="apidocSignatureSpan">electron-builder.asar.</span>readAsarJson
        <span class="apidocSignatureSpan">(_x6, _x7)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readAsarJson(_x6, _x7) {
    return _ref2.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.asarUtil" id="apidoc.module.electron-builder.asarUtil">module electron-builder.asarUtil</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.asarUtil.AsarPackager" id="apidoc.element.electron-builder.asarUtil.AsarPackager">
        function <span class="apidocSignatureSpan">electron-builder.asarUtil.</span>AsarPackager
        <span class="apidocSignatureSpan">(src, destination, options, unpackPattern, transformer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AsarPackager {
    constructor(src, destination, options, unpackPattern, transformer) {
        this.src = src;
        this.options = options;
        this.unpackPattern = unpackPattern;
        this.transformer = transformer;
        this.fs = new (_asar || _load_asar()).AsarFilesystem(this.src);
        this.metadata = new Map();
        this.outFile = _path.join(destination, "app.asar");
    }
    // sort files to minimize file change (i.e. asar file is not changed dramatically on small change)
    pack(filter, isElectronCompile) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const metadata = _this.metadata;
            let files = yield (0, (_fs || _load_fs()).walk)(_this.src, filter, function (file, fileStat) {
                metadata.set(file, fileStat);
                if (fileStat.isSymbolicLink()) {
                    return (0, (_fsExtraP || _load_fsExtraP()).readlink)(file).then(function (linkTarget) {
                        // http://unix.stackexchange.com/questions/105637/is-symlinks-target-relative-to-the-destinations-parent
-directory-and-if-so-wh
                        const resolved = _path.resolve(_path.dirname(file), linkTarget);
                        const link = _path.relative(_this.src, linkTarget);
                        if (link.startsWith("..")) {
                            // outside of project, linked module (https://github.com/electron-userland/electron-builder/issues/675
)
                            return (0, (_fsExtraP || _load_fsExtraP()).stat)(resolved).then(function (targetFileStat) {
                                metadata.set(file, targetFileStat);
                                return targetFileStat;
                            });
                        } else {
                            fileStat.relativeLink = link;
                        }
                        return null;
                    });
                }
                return null;
            });
            // transform before electron-compile to avoid filtering (cache files in any case should be not transformed)
            const transformer = _this.transformer;
            _this.transformedFiles = yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(files, function (it) {
                return metadata.get(it).isFile() ? transformer(it) : null;
            }, (_fs || _load_fs()).CONCURRENCY);
            if (isElectronCompile) {
                files = yield _this.compileUsingElectronCompile(files);
            }
            yield _this.createPackageFromFiles(_this.options.ordering == null ? files : yield _this.order(files));
        })();
    }
    compileUsingElectronCompile(files) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            (0, (_log || _load_log()).log)("Compiling using electron-compile");
            const metadata = _this2.metadata;
            const cacheDir = _path.join(_this2.src, ".cache");
            // clear and create cache dir
            yield (0, (_fsExtraP || _load_fsExtraP()).emptyDir)(cacheDir);
            const compilerHost = yield (0, (_fileTransformer || _load_fileTransformer()).createElectronCompilerHost)(_this2.src,
cacheDir);
            const nextSlashIndex = _this2.src.length + 1;
            // pre-compute electron-compile to cache dir - we need to process only subdirectories, not direct files of app dir
            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(files, function (file) {
                if (file.indexOf("/node_modules/") !== -1 || file.indexOf("/bower_components/") !== -1 || !(file.indexOf("/", nextSlashIndex
) !== -1) // ignore not root files
                || !metadata.get(file).isFile()) {
                    return null;
                }
                return compilerHost.compile(file).then(function (it) {
                    return null;
                });
            }, (_fs || _load_fs()).CONCURRENCY);
            yield compilerHost.saveConfiguration(); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (_this2.info.isPrepackedAppAsar) {
    promise = (0, (_fs || _load_fs()).copyDir)(appDir, _path.join(resourcesPath), filter, transformer);
} else if (asarOptions == null) {
    promise = (0, (_fs || _load_fs()).copyDir)(appDir, _path.join(resourcesPath, "app"), filter, transformer);
} else {
    const unpackPattern = (0, (_fileMatcher || _load_fileMatcher()).getFileMatchers)(_this2.config, "asarUnpack", appDir
, _path.join(resourcesPath, "app"), false, macroExpander, platformSpecificBuildOptions);
    const fileMatcher = unpackPattern == null ? null : unpackPattern[0];
    promise = new (_asarUtil || _load_asarUtil()).<span class="apidocCodeKeywordSpan">AsarPackager</span>(appDir, resourcesPath,
asarOptions, fileMatcher == null ? null : fileMatcher.createFilter(), transformer).pack(filter, isElectronCompile);
}
//noinspection ES6MissingAwait
const promises = [promise, (0, (_fs || _load_fs()).unlinkIfExists)(_path.join(resourcesPath, "default_app.asar")), (0, (
_fs || _load_fs()).unlinkIfExists)(_path.join(appOutDir, "version")), _this2.postInitApp(appOutDir)];
if (_this2.platform !== (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC) {
    promises.push((0, (_fsExtraP || _load_fsExtraP()).rename)(_path.join(appOutDir, "LICENSE"), _path.join(appOutDir, &amp;#
x22;LICENSE.electron.txt")).catch(function () {}));
}
yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all(promises);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.asarUtil.checkFileInArchive" id="apidoc.element.electron-builder.asarUtil.checkFileInArchive">
        function <span class="apidocSignatureSpan">electron-builder.asarUtil.</span>checkFileInArchive
        <span class="apidocSignatureSpan">(_x2, _x3, _x4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkFileInArchive(_x2, _x3, _x4) {
    return _ref2.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.builder" id="apidoc.module.electron-builder.builder">module electron-builder.builder</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.builder.build" id="apidoc.element.electron-builder.builder.build">
        function <span class="apidocSignatureSpan">electron-builder.builder.</span>build
        <span class="apidocSignatureSpan">(_x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function build(_x) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
"use strict"

const builder = require("electron-builder")
const Platform = builder.Platform

// Promise is returned
builder.<span class="apidocCodeKeywordSpan">build</span>({
targets: Platform.MAC.createTarget(),
config: {
 "//": "build options, see https://goo.gl/ZhRfla"
}
})
.then(() =&gt; {
  // handle result
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.builder.createTargets" id="apidoc.element.electron-builder.builder.createTargets">
        function <span class="apidocSignatureSpan">electron-builder.builder.</span>createTargets
        <span class="apidocSignatureSpan">(platforms, type, arch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTargets(platforms, type, arch) {
    const targets = new Map();
    for (const platform of platforms) {
        const archs = platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC ? [(_electronBuilderCore ||
_load_electronBuilderCore()).Arch.x64] : arch === "all" ? [(_electronBuilderCore || _load_electronBuilderCore()).Arch.x64, (_electronBuilderCore
 || _load_electronBuilderCore()).Arch.ia32] : [(0, (_electronBuilderCore || _load_electronBuilderCore()).archFromString)(arch ==
null ? process.arch : arch)];
        const archToType = new Map();
        targets.set(platform, archToType);
        for (const arch of archs) {
            archToType.set(arch, type == null ? [] : [type]);
        }
    }
    return targets;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (target == null) {
        target = factory(outDir);
        nameToTarget.set(name, target);
    }
    result.push(target);
};
const targets = normalizeTargets(rawList, packager.defaultTarget);
packager.<span class="apidocCodeKeywordSpan">createTargets</span>(targets, mapper, cleanupTasks);
return result;
}
function normalizeTargets(targets, defaultTarget) {
const list = [];
for (const t of targets) {
    const name = t.toLowerCase().trim();
    if (name === (_electronBuilderCore || _load_electronBuilderCore()).DEFAULT_TARGET) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.builder.normalizeOptions" id="apidoc.element.electron-builder.builder.normalizeOptions">
        function <span class="apidocSignatureSpan">electron-builder.builder.</span>normalizeOptions
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalizeOptions(args) {
    if (args.targets != null) {
        return args;
    }
    let targets = new Map();
    function processTargets(platform, types) {
        function commonArch(currentIfNotSpecified) {
            if (platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC) {
                return args.x64 || currentIfNotSpecified ? [(_electronBuilderCore || _load_electronBuilderCore()).Arch.x64] : [];
            }
            const result = Array();
            if (args.x64) {
                result.push((_electronBuilderCore || _load_electronBuilderCore()).Arch.x64);
            }
            if (args.armv7l) {
                result.push((_electronBuilderCore || _load_electronBuilderCore()).Arch.armv7l);
            }
            if (args.ia32) {
                result.push((_electronBuilderCore || _load_electronBuilderCore()).Arch.ia32);
            }
            return result.length === 0 &amp;&amp; currentIfNotSpecified ? [(0, (_electronBuilderCore || _load_electronBuilderCore()).archFromString
)(process.arch)] : result;
        }
        if (args.platform != null) {
            throw new Error(`--platform cannot be used if --${platform.buildConfigurationKey} is passed`);
        }
        if (args.arch != null) {
            throw new Error(`--arch cannot be used if --${platform.buildConfigurationKey} is passed`);
        }
        let archToType = targets.get(platform);
        if (archToType == null) {
            archToType = new Map();
            targets.set(platform, archToType);
        }
        if (types.length === 0) {
            const defaultTargetValue = args.dir ? [(_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET] : [];
            for (const arch of commonArch(args.dir === true)) {
                archToType.set(arch, defaultTargetValue);
            }
            return;
        }
        for (const type of types) {
            const suffixPos = type.lastIndexOf(":");
            if (suffixPos &gt; 0) {
                (0, (_electronBuilderUtil || _load_electronBuilderUtil()).addValue)(archToType, (0, (_electronBuilderCore || _load_electronBuilderCore
()).archFromString)(type.substring(suffixPos + 1)), type.substring(0, suffixPos));
            } else {
                for (const arch of commonArch(true)) {
                    (0, (_electronBuilderUtil || _load_electronBuilderUtil()).addValue)(archToType, arch, type);
                }
            }
        }
    }
    if (args.mac != null) {
        processTargets((_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC, args.mac);
    }
    if (args.linux != null) {
        processTargets((_electronBuilderCore || _load_electronBuilderCore()).Platform.LINUX, args.linux);
    }
    if (args.win != null) {
        processTargets((_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS, args.win);
    }
    if (targets.size === 0) {
        if (args.platform == null &amp;&amp; args.arch == null) {
            processTargets((_electronBuilderCore || _load_electronBuilderCore()).Platform.current(), []);
        } else {
            targets = createTargets((0, (_packager || _load_packager()).normalizePlatforms)(args.platform), args.dir ? (_electronBuilderCore
 || _load_electronBuilderCore()).DIR_TARGET : null, args.arch);
        }
    }
    const result = Object.assign({}, args);
    result.targets = targets;
    delete result.dir;
    delete result.mac;
    delete result.linux;
    delete result.win;
    delete result.platform;
    delete result.arch;
    const r = result;
    delete r.em;
    delete r.m;
    delete r.o;
    delete r.l;
    delete r.w;
    delete r.windows;
    delete r.macos;
    delete r.$0;
    delete r._;
    delete r.version;
    delete r.help;
    delete result.ia32;
    delete result.x64;
    delete result.armv7l;
    if (result.project != null &amp;&amp; result.projectDir == null) {
        result.projectDir = result.project;
    }
    delete result.project;
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.cliOptions" id="apidoc.module.electron-builder.cliOptions">module electron-builder.cliOptions</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.cliOptions.createYargs" id="apidoc.element.electron-builder.cliOptions.createYargs">
        function <span class="apidocSignatureSpan">electron-builder.cliOptions.</span>createYargs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createYargs() {
    //noinspection ReservedWordAsName
    return (_yargs || _load_yargs()).default.example("build -mwl", "build for macOS, Windows and Linux").example("build --linux
deb tar.xz", "build deb and tar.xz for Linux").example("build --win --ia32", "build for Windows ia32").example("build --em.foo=bar
", "set package.json property `foo` to `bar`").example("build --config.nsis.unicode=false", "configure unicode options for NSIS").
option("mac", {
        group: buildGroup,
        alias: ["m", "o", "macos"],
        describe: `Build for macOS, accepts target list (see ${(0, (_chalk || _load_chalk()).underline)("https://goo.gl/HAnnq8")}).`,
        type: "array"
    }).option("linux", {
        group: buildGroup,
        alias: "l",
        describe: `Build for Linux, accepts target list (see ${(0, (_chalk || _load_chalk()).underline)("https://goo.gl/O80IL2")})`,
        type: "array"
    }).option("win", {
        group: buildGroup,
        alias: ["w", "windows"],
        describe: `Build for Windows, accepts target list (see ${(0, (_chalk || _load_chalk()).underline)("https://goo.gl/dL4i8i
")})`,
        type: "array"
    }).option("x64", {
        group: buildGroup,
        describe: "Build for x64",
        type: "boolean"
    }).option("ia32", {
        group: buildGroup,
        describe: "Build for ia32",
        type: "boolean"
    }).option("armv7l", {
        group: buildGroup,
        describe: "Build for armv7l",
        type: "boolean"
    }).option("dir", {
        group: buildGroup,
        describe: "Build unpacked dir. Useful to test.",
        type: "boolean"
    }).option("publish", {
        group: publishGroup,
        alias: "p",
        describe: `Publish artifacts (to GitHub Releases), see ${(0, (_chalk || _load_chalk()).underline)("https://goo.gl/WMlr4n
")}`,
        choices: ["onTag", "onTagOrDraft", "always", "never"]
    }).option("draft", {
        group: publishGroup,
        describe: "Create a draft (unpublished) release",
        type: "boolean",
        default: undefined
    }).option("prerelease", {
        group: publishGroup,
        describe: "Identify the release as a prerelease",
        type: "boolean",
        default: undefined
    }).option("platform", {
        group: deprecated,
        describe: "The target platform (preferred to use --mac, --win or --linux)",
        choices: ["mac", "win", "linux", "darwin", "win32", "all"]
    }).option("arch", {
        group: deprecated,
        describe: "The target arch (preferred to use --x64 or --ia32)",
        choices: ["ia32", "x64", "all"]
    }).option("extraMetadata", {
        alias: ["em"],
        group: buildGroup,
        describe: "Inject properties to package.json (asar only)"
    }).option("prepackaged", {
        alias: ["pd"],
        group: buildGroup,
        describe: "The path to prepackaged app (to pack in a distributable format)"
    }).option("projectDir", {
        alias: ["project"],
        group: buildGroup,
        describe: "The path to project directory. Defaults to current working directory."
    }).option("config", {
        alias: ["c"],
        group: buildGroup,
        describe: "The path to an electron-builder config. Defaults to `electron-builder.yml` (or `json`, or `json5`), see " + (
0, (_chalk || _load_chalk()).underline)("https://goo.gl/YFRJOM")
    }).strict().group(["help", "version"], "Other:").help().version().epilog(`See the Wiki (${(0, (_chalk || _load_chalk()).underline
)("https://github.com/electron-userland/electron-builder/wiki")}) for more documentation.`);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.codeSign" id="apidoc.module.electron-builder.codeSign">module electron-builder.codeSign</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.codeSign.createKeychain" id="apidoc.element.electron-builder.codeSign.createKeychain">
        function <span class="apidocSignatureSpan">electron-builder.codeSign.</span>createKeychain
        <span class="apidocSignatureSpan">(_x3, _x4, _x5, _x6, _x7)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createKeychain(_x3, _x4, _x5, _x6, _x7) {
    return _ref3.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.codeSign.downloadCertificate" id="apidoc.element.electron-builder.codeSign.downloadCertificate">
        function <span class="apidocSignatureSpan">electron-builder.codeSign.</span>downloadCertificate
        <span class="apidocSignatureSpan">(_x, _x2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function downloadCertificate(_x, _x2) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.codeSign.findIdentity" id="apidoc.element.electron-builder.codeSign.findIdentity">
        function <span class="apidocSignatureSpan">electron-builder.codeSign.</span>findIdentity
        <span class="apidocSignatureSpan">(certType, qualifier, keychain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findIdentity(certType, qualifier, keychain) {
    let identity = qualifier || process.env.CSC_NAME;
    if ((0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(identity)) {
        if (keychain == null &amp;&amp; !(_isCi || _load_isCi()).default &amp;&amp; process.env.CSC_IDENTITY_AUTO_DISCOVERY === "false") {
            return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(null);
        } else {
            return _findIdentity(certType, null, keychain);
        }
    } else {
        identity = identity.trim();
        for (const prefix of appleCertificatePrefixes) {
            checkPrefix(identity, prefix);
        }
        return _findIdentity(certType, identity, keychain);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.codeSign.sign" id="apidoc.element.electron-builder.codeSign.sign">
        function <span class="apidocSignatureSpan">electron-builder.codeSign.</span>sign
        <span class="apidocSignatureSpan">(path, name, keychain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sign(path, name, keychain) {
    const args = ["--deep", "--force", "--sign", name, path];
    if (keychain != null) {
        args.push("--keychain", keychain);
    }
    return (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)("codesign", args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const hasMas = targets.length !== 0 &amp;&amp; targets.some(function (it) {
    return it.name === "mas" || it.name === "mas-dev";
});
const prepackaged = _this2.info.prepackaged;
if (!hasMas || targets.length &gt; 1) {
    const appPath = prepackaged == null ? _path.join(_this2.computeAppOutDir(outDir, arch), `${_this2.appInfo.productFilename}.app
`) : prepackaged;
    nonMasPromise = (prepackaged ? (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve() : _this2.doPack(outDir, _path.dirname
(appPath), _this2.platform.nodeName, arch, _this2.platformSpecificBuildOptions, targets)).then(function () {
        return _this2.<span class="apidocCodeKeywordSpan">sign</span>(appPath, null, null);
    }).then(function () {
        return _this2.packageInDistributableFormat(appPath, (_electronBuilderCore || _load_electronBuilderCore()).Arch.x64, targets
, postAsyncTasks);
    });
}
for (const target of targets) {
    const targetName = target.name;
    if (!(targetName === "mas" || targetName === "mas-dev")) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.dmg" id="apidoc.module.electron-builder.dmg">module electron-builder.dmg</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.dmg.DmgTarget" id="apidoc.element.electron-builder.dmg.DmgTarget">
        function <span class="apidocSignatureSpan">electron-builder.dmg.</span>DmgTarget
        <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class DmgTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
    constructor(packager, outDir) {
        super("dmg");
        this.packager = packager;
        this.outDir = outDir;
        this.options = this.packager.config.dmg;
        this.helperDir = _path.join(__dirname, "..", "..", "templates", "dmg");
    }
    build(appPath, arch) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = _this.packager;
            const appInfo = packager.appInfo;
            (0, (_log || _load_log()).log)("Building DMG");
            const specification = yield _this.computeDmgOptions();
            const tempDir = yield packager.getTempFile("dmg");
            const tempDmg = _path.join(tempDir, "temp.dmg");
            const backgroundDir = _path.join(tempDir, ".background");
            const backgroundFilename = specification.background == null ? null : _path.basename(specification.background);
            if (backgroundFilename != null) {
                yield (0, (_fsExtraP || _load_fsExtraP()).copy)(_path.resolve(packager.info.projectDir, specification.background
), _path.join(backgroundDir, backgroundFilename));
            }
            let preallocatedSize = 32 * 1024;
            if (specification.icon != null) {
                const stat = yield (0, (_fs || _load_fs()).statOrNull)(specification.icon);
                if (stat != null) {
                    preallocatedSize += stat.size;
                }
            }
            // allocate space for .DS_Store
            yield (0, (_fsExtraP || _load_fsExtraP()).outputFile)(_path.join(backgroundDir, "DSStorePlaceHolder"), new Buffer(preallocatedSize
));
            const volumeName = (0, (_sanitizeFilename || _load_sanitizeFilename()).default)(_this.computeVolumeName(specification
.title));
            //noinspection SpellCheckingInspection
            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).spawn)("hdiutil", addVerboseIfNeed(["create", "-srcfolder
", backgroundDir, "-srcfolder", appPath, "-volname", volumeName, "-anyowners", "-nospotlight", "-fs", "HFS+", "-fsargs", "-c c=64
,a=16,e=16", "-format", "UDRW"]).concat(tempDmg));
            const volumePath = _path.join("/Volumes", volumeName);
            if (yield (0, (_fs || _load_fs()).exists)(volumePath)) {
                (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)("Unmounting previous disk image");
                yield detach(volumePath);
            }
            const isContinue = yield attachAndExecute(tempDmg, true, (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function
* () {
                const promises = [specification.background == null ? (0, (_fsExtraP || _load_fsExtraP()).remove)(`${volumePath}/.
background`) : (0, (_fsExtraP || _load_fsExtraP()).unlink)(`${volumePath}/.background/DSStorePlaceHolder`)];
                let contents = specification.contents;
                if (contents == null) {
                    contents = [{
                        "x": 130, "y": 220
                    }, {
                        "x": 410, "y": 220, "type": "link", "path": "/Applications"
                    }];
                }
                const window = specification.window;
                const env = Object.assign({}, process.env, {
                    volumePath: volumePath,
                    appFileName: `${packager.appInfo.productFilename}.app`,
                    iconSize: specification.iconSize || 80,
                    iconTextSize: specification.iconTextSize || 12,
                    windowX: window.x,
                    windowY: window.y,
                    VERSIONER_PERL_PREFER_32_BIT: "true"
                });
                if (specification.icon == null) {
                    delete env.volumeIcon;
                } else {
                    const volumeIcon = `${volumePath}/.VolumeIcon.icns`;
                    promises.push((0, (_fsExtraP || _load_fsExtraP()).copy)((yield packager.getResource(specification.icon)) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
createTargets(targets, mapper, cleanupTasks) {
    for (const name of targets) {
        switch (name) {
            case (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET:
                break;
            case "dmg":
                mapper("dmg", outDir =&gt; new (_dmg || _load_dmg()).<span class="apidocCodeKeywordSpan">DmgTarget<!--
span-->(this, outDir));
                break;
            case "pkg":
                mapper("pkg", outDir =&gt; new (_pkg || _load_pkg()).PkgTarget(this, outDir));
                break;
            default:
                mapper(name, outDir =&gt; name === "mas" || name === "mas-dev" ? new (_targetFactory || _load_targetFactory
()).NoOpTarget(name) : (0, (_targetFactory || _load_targetFactory()).createCommonTarget)(name, outDir, this));
                break;
...</span></pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.dmg.attachAndExecute" id="apidoc.element.electron-builder.dmg.attachAndExecute">
        function <span class="apidocSignatureSpan">electron-builder.dmg.</span>attachAndExecute
        <span class="apidocSignatureSpan">(_x2, _x3, _x4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attachAndExecute(_x2, _x3, _x4) {
    return _ref3.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.fileMatcher" id="apidoc.module.electron-builder.fileMatcher">module electron-builder.fileMatcher</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.fileMatcher.FileMatcher" id="apidoc.element.electron-builder.fileMatcher.FileMatcher">
        function <span class="apidocSignatureSpan">electron-builder.fileMatcher.</span>FileMatcher
        <span class="apidocSignatureSpan">(from, to, macroExpander, patterns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class FileMatcher {
    constructor(from, to, macroExpander, patterns) {
        this.macroExpander = macroExpander;
        this.from = macroExpander(from);
        this.to = macroExpander(to);
        this.patterns = (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(patterns).map(it =&gt; _path.posix.normalize
(macroExpander(it)));
    }
    addPattern(pattern) {
        this.patterns.push(_path.posix.normalize(this.macroExpander(pattern)));
    }
    addAllPattern() {
        // must be first, see minimatchAll implementation
        this.patterns.unshift("**/*");
    }
    isEmpty() {
        return this.patterns.length === 0;
    }
    containsOnlyIgnore() {
        return !this.isEmpty() &amp;&amp; this.patterns.find(it =&gt; !it.startsWith("!")) == null;
    }
    computeParsedPatterns(result, fromDir) {
        // https://github.com/electron-userland/electron-builder/issues/733
        const minimatchOptions = { dot: true };
        const relativeFrom = fromDir == null ? null : _path.relative(fromDir, this.from);
        if (this.patterns.length === 0 &amp;&amp; relativeFrom != null) {
            // file mappings, from here is a file
            result.push(new (_minimatch || _load_minimatch()).Minimatch(relativeFrom, minimatchOptions));
            return;
        }
        for (let pattern of this.patterns) {
            if (relativeFrom != null) {
                pattern = _path.join(relativeFrom, pattern);
            }
            const parsedPattern = new (_minimatch || _load_minimatch()).Minimatch(pattern, minimatchOptions);
            result.push(parsedPattern);
            if (!(0, (_filter || _load_filter()).hasMagic)(parsedPattern)) {
                // https://github.com/electron-userland/electron-builder/issues/545
                // add **/*
                result.push(new (_minimatch || _load_minimatch()).Minimatch(`${pattern}/**/*`, minimatchOptions));
            }
        }
    }
    createFilter(ignoreFiles, rawFilter, excludePatterns) {
        const parsedPatterns = [];
        this.computeParsedPatterns(parsedPatterns);
        return (0, (_filter || _load_filter()).createFilter)(this.from, parsedPatterns, ignoreFiles, rawFilter, excludePatterns);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.fileMatcher.copyFiles" id="apidoc.element.electron-builder.fileMatcher.copyFiles">
        function <span class="apidocSignatureSpan">electron-builder.fileMatcher.</span>copyFiles
        <span class="apidocSignatureSpan">(patterns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function copyFiles(patterns) {
    if (patterns == null || patterns.length === 0) {
        return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve();
    }
    return (_bluebirdLst2 || _load_bluebirdLst2()).default.map(patterns, (() =&gt; {
        var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (pattern) {
            const fromStat = yield (0, (_fs || _load_fs()).statOrNull)(pattern.from);
            if (fromStat == null) {
                (0, (_log || _load_log()).warn)(`File source ${pattern.from} doesn't exist`);
                return;
            }
            if (fromStat.isFile()) {
                const toStat = yield (0, (_fs || _load_fs()).statOrNull)(pattern.to);
                // https://github.com/electron-userland/electron-builder/issues/1245
                if (toStat != null &amp;&amp; toStat.isDirectory()) {
                    return yield (0, (_fs || _load_fs()).copyFile)(pattern.from, _path.join(pattern.to, _path.basename(pattern.from
)), fromStat);
                }
                yield (0, (_fsExtraP || _load_fsExtraP()).mkdirs)(_path.dirname(pattern.to));
                return yield (0, (_fs || _load_fs()).copyFile)(pattern.from, pattern.to, fromStat);
            }
            if (pattern.isEmpty() || pattern.containsOnlyIgnore()) {
                pattern.addAllPattern();
            }
            return yield (0, (_fs || _load_fs()).copyDir)(pattern.from, pattern.to, pattern.createFilter());
        });

        return function (_x) {
            return _ref.apply(this, arguments);
        };
    })());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.fileMatcher.createFileMatcher" id="apidoc.element.electron-builder.fileMatcher.createFileMatcher">
        function <span class="apidocSignatureSpan">electron-builder.fileMatcher.</span>createFileMatcher
        <span class="apidocSignatureSpan">(info, appDir, resourcesPath, macroExpander, platformSpecificBuildOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFileMatcher(info, appDir, resourcesPath, macroExpander, platformSpecificBuildOptions) {
    const patterns = info.isPrepackedAppAsar ? null : getFileMatchers(info.config, "files", appDir, _path.join(resourcesPath, "app
"), false, macroExpander, platformSpecificBuildOptions);
    const matcher = patterns == null ? new FileMatcher(appDir, _path.join(resourcesPath, "app"), macroExpander) : patterns[0];
    if (matcher.isEmpty() || matcher.containsOnlyIgnore()) {
        matcher.addAllPattern();
    } else {
        matcher.addPattern("package.json");
    }
    matcher.addPattern("!**/node_modules/*/{CHANGELOG.md,ChangeLog,changelog.md,README.md,README,readme.md,readme,test,__tests__
,tests,powered-test,example,examples,*.d.ts}");
    matcher.addPattern("!**/node_modules/.bin");
    matcher.addPattern("!**/*.{o,hprof,orig,pyc,pyo,rbc,swp}");
    matcher.addPattern("!**/._*");
    matcher.addPattern("!*.iml");
    //noinspection SpellCheckingInspection
    matcher.addPattern("!**/{.git,.hg,.svn,CVS,RCS,SCCS," + "__pycache__,.DS_Store,thumbs.db,.gitignore,.gitattributes," + ".editorconfig
,.flowconfig,.jshintrc,.eslintrc," + ".yarn-integrity,.yarn-metadata.json,yarn-error.log,yarn.lock,npm-debug.log," + ".idea," + "
appveyor.yml,.travis.yml,circle.yml," + ".nyc_output}");
    return matcher;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.fileMatcher.getFileMatchers" id="apidoc.element.electron-builder.fileMatcher.getFileMatchers">
        function <span class="apidocSignatureSpan">electron-builder.fileMatcher.</span>getFileMatchers
        <span class="apidocSignatureSpan">(config, name, defaultSrc, defaultDest, allowAdvancedMatching, macroExpander, customBuildOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFileMatchers(config, name, defaultSrc, defaultDest, allowAdvancedMatching, macroExpander, customBuildOptions) {
    const globalPatterns = config[name];
    const platformSpecificPatterns = customBuildOptions[name];
    const defaultMatcher = new FileMatcher(defaultSrc, defaultDest, macroExpander);
    const fileMatchers = [];
    function addPatterns(patterns) {
        if (patterns == null) {
            return;
        } else if (!Array.isArray(patterns)) {
            if (typeof patterns === "string") {
                defaultMatcher.addPattern(patterns);
                return;
            }
            patterns = [patterns];
        }
        for (const pattern of patterns) {
            if (typeof pattern === "string") {
                // use normalize to transform ./foo to foo
                defaultMatcher.addPattern(pattern);
            } else if (allowAdvancedMatching) {
                const from = pattern.from == null ? defaultSrc : _path.resolve(defaultSrc, pattern.from);
                const to = pattern.to == null ? defaultDest : _path.resolve(defaultDest, pattern.to);
                fileMatchers.push(new FileMatcher(from, to, macroExpander, pattern.filter));
            } else {
                throw new Error(`Advanced file copying not supported for "${name}"`);
            }
        }
    }
    addPatterns(globalPatterns);
    addPatterns(platformSpecificPatterns);
    if (!defaultMatcher.isEmpty()) {
        // default matcher should be first in the array
        fileMatchers.unshift(defaultMatcher);
    }
    return fileMatchers.length === 0 ? null : fileMatchers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.fileTransformer" id="apidoc.module.electron-builder.fileTransformer">module electron-builder.fileTransformer</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.fileTransformer.createElectronCompilerHost" id="apidoc.element.electron-builder.fileTransformer.createElectronCompilerHost">
        function <span class="apidocSignatureSpan">electron-builder.fileTransformer.</span>createElectronCompilerHost
        <span class="apidocSignatureSpan">(projectDir, cacheDir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createElectronCompilerHost(projectDir, cacheDir) {
    const electronCompilePath = _path.join(projectDir, "node_modules", "electron-compile", "lib");
    return require(_path.join(electronCompilePath, "config-parser")).createCompilerHostFromProjectRoot(projectDir, cacheDir);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.fileTransformer.createTransformer" id="apidoc.element.electron-builder.fileTransformer.createTransformer">
        function <span class="apidocSignatureSpan">electron-builder.fileTransformer.</span>createTransformer
        <span class="apidocSignatureSpan">(_x, _x2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTransformer(_x, _x2) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.fileTransformer.isElectronCompileUsed" id="apidoc.element.electron-builder.fileTransformer.isElectronCompileUsed">
        function <span class="apidocSignatureSpan">electron-builder.fileTransformer.</span>isElectronCompileUsed
        <span class="apidocSignatureSpan">(info)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isElectronCompileUsed(info) {
    if (info.config.electronCompile != null) {
        return info.config.electronCompile;
    }
    // if in devDependencies - it means that babel is used for precompilation or for some reason user decided to not use electron
-compile for production
    const deps = info.metadata.dependencies;
    return deps != null &amp;&amp; "electron-compile" in deps;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.filter" id="apidoc.module.electron-builder.filter">module electron-builder.filter</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.filter.createFilter" id="apidoc.element.electron-builder.filter.createFilter">
        function <span class="apidocSignatureSpan">electron-builder.filter.</span>createFilter
        <span class="apidocSignatureSpan">(src, patterns, ignoreFiles, rawFilter, excludePatterns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFilter(src, patterns, ignoreFiles, rawFilter, excludePatterns) {
    return function (it, stat) {
        if (src === it) {
            return true;
        }
        if (rawFilter != null &amp;&amp; !rawFilter(it)) {
            return false;
        }
        // yes, check before path sep normalization
        if (ignoreFiles != null &amp;&amp; ignoreFiles.has(it)) {
            return false;
        }
        let relative = it.substring(src.length + 1);
        if (_path.sep === "\\") {
            relative = relative.replace(/\\/g, "/");
        }
        return minimatchAll(relative, patterns, stat) &amp;&amp; (excludePatterns == null || !minimatchAll(relative, excludePatterns, stat
));
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                }
                yield (0, (_fsExtraP || _load_fsExtraP()).mkdirs)(_path.dirname(pattern.to));
                return yield (0, (_fs || _load_fs()).copyFile)(pattern.from, pattern.to, fromStat);
            }
            if (pattern.isEmpty() || pattern.containsOnlyIgnore()) {
                pattern.addAllPattern();
            }
            return yield (0, (_fs || _load_fs()).copyDir)(pattern.from, pattern.to, pattern.<span class="apidocCodeKeywordSpan">
createFilter</span>());
        });

        return function (_x) {
            return _ref.apply(this, arguments);
        };
    })());
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.filter.hasMagic" id="apidoc.element.electron-builder.filter.hasMagic">
        function <span class="apidocSignatureSpan">electron-builder.filter.</span>hasMagic
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasMagic(pattern) {
    const set = pattern.set;
    if (set.length &gt; 1) {
        return true;
    }
    for (const i of set[0]) {
        if (typeof i !== "string") {
            return true;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.forge_maker" id="apidoc.module.electron-builder.forge_maker">module electron-builder.forge_maker</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.forge_maker.buildForge" id="apidoc.element.electron-builder.forge_maker.buildForge">
        function <span class="apidocSignatureSpan">electron-builder.forge_maker.</span>buildForge
        <span class="apidocSignatureSpan">(appDir, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buildForge(appDir, options) {
    return (0, (_builder || _load_builder()).build)(Object.assign({
        prepackaged: appDir,
        config: {
            directories: {
                // https://github.com/electron-userland/electron-forge/blob/master/src/makers/generic/zip.js
                output: _path.resolve(appDir, "..", "make")
            }
        }
    }, options));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.fpm" id="apidoc.module.electron-builder.fpm">module electron-builder.fpm</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.fpm.default" id="apidoc.element.electron-builder.fpm.default">
        function <span class="apidocSignatureSpan">electron-builder.fpm.</span>default
        <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class FpmTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
    constructor(name, packager, helper, outDir) {
        super(name, false);
        this.packager = packager;
        this.helper = helper;
        this.outDir = outDir;
        this.options = Object.assign({}, this.packager.platformSpecificBuildOptions, this.packager.config[this.name]);
        this.scriptFiles = this.createScripts();
    }
    createScripts() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const defaultTemplatesDir = _path.join(__dirname, "..", "..", "templates", "linux");
            const packager = _this.packager;
            const templateOptions = Object.assign({
                // old API compatibility
                executable: packager.executableName,
                productFilename: packager.appInfo.productFilename
            }, packager.platformSpecificBuildOptions);
            function getResource(value, defaultFile) {
                if (value == null) {
                    return _path.join(defaultTemplatesDir, defaultFile);
                }
                return _path.resolve(packager.projectDir, value);
            }
            //noinspection ES6MissingAwait
            return yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([writeConfigFile(packager.info.tempDirManager, getResource
(_this.options.afterInstall, "after-install.tpl"), templateOptions), writeConfigFile(packager.info.tempDirManager, getResource(_this
.options.afterRemove, "after-remove.tpl"), templateOptions)]);
        })();
    }
    build(appOutDir, arch) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const target = _this2.name;
            (0, (_log || _load_log()).log)(`Building ${target}`);
            const destination = _path.join(_this2.outDir, _this2.packager.generateName(target, arch, true /* on Linux we use safe
 name â€” without space */));
            yield (0, (_fs || _load_fs()).unlinkIfExists)(destination);
            if (_this2.packager.info.prepackaged != null) {
                yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(_this2.outDir);
            }
            const scripts = yield _this2.scriptFiles;
            const packager = _this2.packager;
            const appInfo = packager.appInfo;
            const projectUrl = yield appInfo.computePackageUrl();
            if (projectUrl == null) {
                throw new Error("Please specify project homepage, see https://github.com/electron-userland/electron-builder/wiki
/Options#AppMetadata-homepage");
            }
            const options = _this2.options;
            let author = options.maintainer;
            if (author == null) {
                const a = appInfo.metadata.author;
                if (a.email == null) {
                    throw new Error((_errorMessages || _load_errorMessages()).authorEmailIsMissed);
                }
                author = `${a.name} &lt;${a.email}&gt;`;
            }
            const synopsis = options.synopsis;
            const args = ["-s", "dir", "-t", target, "--architecture", target === "pacman" &amp;&amp; arch === (_electronBuilderCore ||
_load_electronBuilderCore()).Arch.ia32 ? "i686" : (0, (_electronBuilderCore || _load_electronBuilderCore()).toLinuxArchString)(arch
), "--name", appInfo.name, "--force", "--after-install", scripts[0], "--after-remove", scripts[1], "--description", (0, (_electronBuilderUtil
 || _load_electronBuilderUtil()).smarten)(target === "rpm" ? _this2.helper.getDescription(options) : `${synopsis || ""}\n ${_this2.helper.getDescription(options)}`), "--maintainer", author, "--vendor", options.vendor || author, "--version", appInfo.version, "--package", destination, "--url", projectUrl];
            const packageCategory = options.packageCategory;
            if (packageCategory != null &amp;&amp; packageCategory !== null) {
                args.push("--category", packageCategory);
            }
            if (target === "deb") { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
headerPickle.writeString(JSON.stringify(this.fs.header));
const headerBuf = headerPickle.toBuffer();
const sizePickle = pickle.createEmpty();
sizePickle.writeUInt32(headerBuf.length);
const sizeBuf = sizePickle.toBuffer();
const transformedFiles = this.transformedFiles;
const writeStream = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(this.outFile);
return new (_bluebirdLst2 || _load_bluebirdLst2()).<span class="apidocCodeKeywordSpan">default</span>((resolve, reject) =&gt; {
    writeStream.on("error", reject);
    writeStream.on("close", resolve);
    writeStream.write(sizeBuf);
    const w = index =&gt; {
        let data;
        while (true) {
            if (index &gt;= files.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.linuxPackager" id="apidoc.module.electron-builder.linuxPackager">module electron-builder.linuxPackager</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.linuxPackager.LinuxPackager" id="apidoc.element.electron-builder.linuxPackager.LinuxPackager">
        function <span class="apidocSignatureSpan">electron-builder.linuxPackager.</span>LinuxPackager
        <span class="apidocSignatureSpan">(_platformPackager || _load_platformPackager()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class LinuxPackager extends (_platformPackager || _load_platformPackager()).PlatformPackager {
    constructor(info) {
        super(info);
        const executableName = this.platformSpecificBuildOptions.executableName;
        this.executableName = (0, (_sanitizeFilename || _load_sanitizeFilename()).default)(executableName == null ? this.appInfo
.name.toLowerCase() : executableName);
    }
    get defaultTarget() {
        return ["appimage"];
    }
    createTargets(targets, mapper, cleanupTasks) {
        let helper;
        const getHelper = () =&gt; {
            if (helper == null) {
                helper = new (_LinuxTargetHelper || _load_LinuxTargetHelper()).LinuxTargetHelper(this);
            }
            return helper;
        };
        for (const name of targets) {
            if (name === (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET) {
                continue;
            }
            const targetClass = (() =&gt; {
                switch (name) {
                    case "appimage":
                        return require("./targets/appImage").default;
                    case "snap":
                        return require("./targets/snap").default;
                    case "deb":
                    case "rpm":
                    case "sh":
                    case "freebsd":
                    case "pacman":
                    case "apk":
                    case "p5p":
                        return require("./targets/fpm").default;
                    default:
                        return null;
                }
            })();
            mapper(name, outDir =&gt; targetClass === null ? (0, (_targetFactory || _load_targetFactory()).createCommonTarget)(name
, outDir, this) : new targetClass(name, this, getHelper(), outDir));
        }
    }
    get platform() {
        return (_electronBuilderCore || _load_electronBuilderCore()).Platform.LINUX;
    }
    postInitApp(appOutDir) {
        return (0, (_fsExtraP || _load_fsExtraP()).rename)(_path.join(appOutDir, this.electronDistExecutableName), _path.join(appOutDir
, this.executableName));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.mac" id="apidoc.module.electron-builder.mac">module electron-builder.mac</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.mac.createApp" id="apidoc.element.electron-builder.mac.createApp">
        function <span class="apidocSignatureSpan">electron-builder.mac.</span>createApp
        <span class="apidocSignatureSpan">(_x, _x2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createApp(_x, _x2) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//noinspection ES6MissingAwait
const promises = [promise, (0, (_fs || _load_fs()).unlinkIfExists)(_path.join(resourcesPath, "default_app.asar")), (0, (
_fs || _load_fs()).unlinkIfExists)(_path.join(appOutDir, "version")), _this2.postInitApp(appOutDir)];
if (_this2.platform !== (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC) {
    promises.push((0, (_fsExtraP || _load_fsExtraP()).rename)(_path.join(appOutDir, "LICENSE"), _path.join(appOutDir, &amp;#
x22;LICENSE.electron.txt")).catch(function () {}));
}
yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all(promises);
if (platformName === "darwin" || platformName === "mas") {
    yield require("./packager/mac").<span class="apidocCodeKeywordSpan">createApp</span>(_this2, appOutDir);
}
yield (0, (_fileMatcher || _load_fileMatcher()).copyFiles)(extraResourceMatchers);
yield (0, (_fileMatcher || _load_fileMatcher()).copyFiles)(extraFileMatchers);
if (_this2.info.cancellationToken.cancelled) {
    return;
}
yield _this2.info.afterPack({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.mac.filterCFBundleIdentifier" id="apidoc.element.electron-builder.mac.filterCFBundleIdentifier">
        function <span class="apidocSignatureSpan">electron-builder.mac.</span>filterCFBundleIdentifier
        <span class="apidocSignatureSpan">(identifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filterCFBundleIdentifier(identifier) {
    // Remove special characters and allow only alphanumeric (A-Z,a-z,0-9), hyphen (-), and period (.)
    // Apple documentation: https://developer.apple.com/library/mac/documentation/General/Reference/InfoPlistKeyReference/Articles
/CoreFoundationKeys.html#//apple_ref/doc/uid/20001431-102070
    return identifier.replace(/ /g, "-").replace(/[^a-zA-Z0-9.-]/g, "");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.macPackager" id="apidoc.module.electron-builder.macPackager">module electron-builder.macPackager</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.macPackager.default" id="apidoc.element.electron-builder.macPackager.default">
        function <span class="apidocSignatureSpan">electron-builder.macPackager.</span>default
        <span class="apidocSignatureSpan">(_platformPackager || _load_platformPackager()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class MacPackager extends (_platformPackager || _load_platformPackager()).PlatformPackager {
    constructor(info) {
        super(info);
        if (this.packagerOptions.cscLink == null || process.platform !== "darwin") {
            this.codeSigningInfo = (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(Object.create(null));
        } else {
            this.codeSigningInfo = (0, (_codeSign || _load_codeSign()).createKeychain)(info.tempDirManager, this.packagerOptions
.cscLink, this.getCscPassword(), this.packagerOptions.cscInstallerLink, this.packagerOptions.cscInstallerKeyPassword);
        }
    }
    get defaultTarget() {
        return ["zip", "dmg"];
    }
    prepareAppInfo(appInfo) {
        return new (_appInfo || _load_appInfo()).AppInfo(appInfo.metadata, this.info, this.platformSpecificBuildOptions.bundleVersion
);
    }
    getIconPath() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            let iconPath = _this.platformSpecificBuildOptions.icon || _this.config.icon;
            if (iconPath != null &amp;&amp; !iconPath.endsWith(".icns")) {
                iconPath += ".icns";
            }
            return iconPath == null ? yield _this.getDefaultIcon("icns") : yield _this.getResource(iconPath);
        })();
    }
    createTargets(targets, mapper, cleanupTasks) {
        for (const name of targets) {
            switch (name) {
                case (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET:
                    break;
                case "dmg":
                    mapper("dmg", outDir =&gt; new (_dmg || _load_dmg()).DmgTarget(this, outDir));
                    break;
                case "pkg":
                    mapper("pkg", outDir =&gt; new (_pkg || _load_pkg()).PkgTarget(this, outDir));
                    break;
                default:
                    mapper(name, outDir =&gt; name === "mas" || name === "mas-dev" ? new (_targetFactory || _load_targetFactory()).
NoOpTarget(name) : (0, (_targetFactory || _load_targetFactory()).createCommonTarget)(name, outDir, this));
                    break;
            }
        }
    }
    get platform() {
        return (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC;
    }
    pack(outDir, arch, targets, postAsyncTasks) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            let nonMasPromise = null;
            const hasMas = targets.length !== 0 &amp;&amp; targets.some(function (it) {
                return it.name === "mas" || it.name === "mas-dev";
            });
            const prepackaged = _this2.info.prepackaged;
            if (!hasMas || targets.length &gt; 1) {
                const appPath = prepackaged == null ? _path.join(_this2.computeAppOutDir(outDir, arch), `${_this2.appInfo.productFilename
}.app`) : prepackaged;
                nonMasPromise = (prepackaged ? (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve() : _this2.doPack(outDir,
_path.dirname(appPath), _this2.platform.nodeName, arch, _this2.platformSpecificBuildOptions, targets)).then(function () {
                    return _this2.sign(appPath, null, null);
                }).then(function () {
                    return _this2.packageInDistributableFormat(appPath, (_electronBuilderCore || _load_electronBuilderCore()).Arch
.x64, targets, postAsyncTasks);
                });
            }
            for (const target of targets) {
                const targetName = target.name;
                if (!(targetName === "mas" || targetName === "mas-dev")) {
                    continue;
                }
                const masBuildOptions = (0, (_deepAssign || _load_deepAssign()).deepAssign)({}, _this2.platformSpecificBuildOptions
, _this2.config.mas);
                if (targetName === "mas-dev") {
                    (0, (_deepAssign || _load_deepAssign()).deepAssign)(masBuildOptions, _this2.config[targetName]);
                    masBuildOptions.type = "development";
                }
                const target ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
headerPickle.writeString(JSON.stringify(this.fs.header));
const headerBuf = headerPickle.toBuffer();
const sizePickle = pickle.createEmpty();
sizePickle.writeUInt32(headerBuf.length);
const sizeBuf = sizePickle.toBuffer();
const transformedFiles = this.transformedFiles;
const writeStream = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(this.outFile);
return new (_bluebirdLst2 || _load_bluebirdLst2()).<span class="apidocCodeKeywordSpan">default</span>((resolve, reject) =&gt; {
    writeStream.on("error", reject);
    writeStream.on("close", resolve);
    writeStream.write(sizeBuf);
    const w = index =&gt; {
        let data;
        while (true) {
            if (index &gt;= files.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.nsis" id="apidoc.module.electron-builder.nsis">module electron-builder.nsis</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.nsis.AppPackageHelper" id="apidoc.element.electron-builder.nsis.AppPackageHelper">
        function <span class="apidocSignatureSpan">electron-builder.nsis.</span>AppPackageHelper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AppPackageHelper {
    constructor() {
        this.archToFileInfo = new Map();
        this.infoToIsDelete = new Map();
<span class="apidocCodeCommentSpan">        /** @private */
</span>        this.refCount = 0;
    }
    packArch(arch, target) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            let infoPromise = _this.archToFileInfo.get(arch);
            if (infoPromise == null) {
                infoPromise = (0, (_log || _load_log()).subTask)(`Packaging NSIS installer for arch ${(_electronBuilderCore || _load_electronBuilderCore
()).Arch[arch]}`, target.buildAppPackage(target.archs.get(arch), arch)).then(function (it) {
                    return { file: it };
                });
                _this.archToFileInfo.set(arch, infoPromise);
            }
            const info = yield infoPromise;
            if (target.isWebInstaller) {
                _this.infoToIsDelete.set(info, false);
            } else if (!_this.infoToIsDelete.has(info)) {
                _this.infoToIsDelete.set(info, true);
            }
            return info.file;
        })();
    }
    finishBuild() {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (--_this2.refCount &gt; 0) {
                return;
            }
            const filesToDelete = [];
            for (let _ref of _this2.infoToIsDelete.entries()) {
                var _ref2 = _slicedToArray(_ref, 2);

                let info = _ref2[0];
                let isDelete = _ref2[1];

                if (isDelete) {
                    filesToDelete.push(info.file);
                }
            }
            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(filesToDelete, function (it) {
                return (0, (_fsExtraP || _load_fsExtraP()).unlink)(it);
            });
        })();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
doGetCscPassword() {
    return this.platformSpecificBuildOptions.certificatePassword || process.env.WIN_CSC_KEY_PASSWORD || super.doGetCscPassword();
}
createTargets(targets, mapper, cleanupTasks) {
    let helper;
    const getHelper = () =&gt; {
        if (helper == null) {
            helper = new (_nsis || _load_nsis()).<span class="apidocCodeKeywordSpan">AppPackageHelper</span>();
        }
        return helper;
    };
    for (const name of targets) {
        if (name === (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET) {
            continue;
        }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.nsis.NsisTarget" id="apidoc.element.electron-builder.nsis.NsisTarget">
        function <span class="apidocSignatureSpan">electron-builder.nsis.</span>NsisTarget
        <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class NsisTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
    constructor(packager, outDir, targetName, packageHelper) {
        super(targetName);
        this.packager = packager;
        this.outDir = outDir;
        this.packageHelper = packageHelper;
<span class="apidocCodeCommentSpan">        /** @private */
</span>        this.archs = new Map();
        this.nsisTemplatesDir = _path.join(__dirname, "..", "..", "templates", "nsis");
        this.packageHelper.refCount++;
        let options = this.packager.config.nsis || Object.create(null);
        if (targetName !== "nsis") {
            options = Object.assign(options, this.packager.config[targetName === "nsis-web" ? "nsisWeb" : targetName]);
        }
        this.options = options;
        const deps = packager.info.metadata.dependencies;
        if (deps != null &amp;&amp; deps["electron-squirrel-startup"] != null) {
            (0, (_log || _load_log()).warn)('"electron-squirrel-startup" dependency is not required for NSIS');
        }
    }
    build(appOutDir, arch) {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            _this3.archs.set(arch, appOutDir);
        })();
    }
    /** @private */
    buildAppPackage(appOutDir, arch) {
        var _this4 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([(0, (_fs || _load_fs()).copyFile)(_path.join((yield nsisPathPromise
), "elevate.exe"), _path.join(appOutDir, "resources", "elevate.exe"), null, false), (0, (_fs || _load_fs()).copyFile)(_path.join
((yield (0, (_windowsCodeSign || _load_windowsCodeSign()).getSignVendorPath)()), "windows-10", (_electronBuilderCore || _load_electronBuilderCore
()).Arch[arch], "signtool.exe"), _path.join(appOutDir, "resources", "signtool.exe"), null, false)]);
            const packager = _this4.packager;
            const format = _this4.options.useZip ? "zip" : "7z";
            const archiveFile = _path.join(_this4.outDir, `${packager.appInfo.name}-${packager.appInfo.version}-${(_electronBuilderCore
 || _load_electronBuilderCore()).Arch[arch]}.nsis.${format}`);
            return yield (0, (_archive || _load_archive()).archive)(packager.config.compression, format, archiveFile, appOutDir,
true);
        })();
    }
    // noinspection JSUnusedGlobalSymbols
    finishBuild() {
        var _this5 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            (0, (_log || _load_log()).log)("Building NSIS installer");
            try {
                yield _this5.buildInstaller();
            } finally {
                yield _this5.packageHelper.finishBuild();
            }
        })();
    }
    get installerFilenamePattern() {
        return "${productName} " + (this.isPortable ? "" : "Setup ") + "${version}.${ext}";
    }
    get isPortable() {
        return this.name === "portable";
    }
    buildInstaller() {
        var _this6 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const isPortable = _this6.isPortable;
            const packager = _this6.packager;
            const appInfo = packager.appInfo;
            const version = appInfo.version;
            const options = _this6.options;
            const installerFilename = packager.expandArtifactNamePattern(options, "exe", null, _this6.installerFilenamePattern);
            const iconPath = (isPortable ? null : yield packager.getResource(options.installerIcon, "installerIcon.ico")) || (yield
 packager.getIconPath());
            const oneClick = options.oneClick !== false;
            const installerPath = _path.join(_this6.outDir, installerFilename);
            const guid = options.guid || (yield (_bluebirdLst2 || _load_bluebirdLst2()).default.promisify((_uuid || _load_uuid()).
v5)({ namespace: ELECTRON_BUILDER_NS_UUID, name: appInfo.id }));
            const defines = {
                APP_ID: appInfo.id,
                APP_GUID: guid,
                PRODUCT_N ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return helper;
};
for (const name of targets) {
    if (name === (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET) {
        continue;
    }
    if (name === "nsis" || name === "portable") {
        mapper(name, outDir =&gt; new (_nsis || _load_nsis()).<span class="apidocCodeKeywordSpan">NsisTarget</span>(this, outDir
, name, getHelper()));
    } else if (name === "nsis-web") {
        mapper(name, outDir =&gt; new (_WebInstallerTarget || _load_WebInstallerTarget()).WebInstallerTarget(this, outDir, name
, getHelper()));
    } else {
        const targetClass = (() =&gt; {
            switch (name) {
                case "squirrel":
                    try {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.packager" id="apidoc.module.electron-builder.packager">module electron-builder.packager</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.packager.Packager" id="apidoc.element.electron-builder.packager.Packager">
        function <span class="apidocSignatureSpan">electron-builder.packager.</span>Packager
        <span class="apidocSignatureSpan">(options, cancellationToken)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Packager {
    //noinspection JSUnusedGlobalSymbols
    constructor(options, cancellationToken) {
        this.options = options;
        this.cancellationToken = cancellationToken;
        this.isTwoPackageJsonProjectLayoutUsed = true;
        this.eventEmitter = new (_events || _load_events()).EventEmitter();
        this.tempDirManager = new (_tmp || _load_tmp()).TmpDir();
        this._repositoryInfo = new (_electronBuilderUtil || _load_electronBuilderUtil()).Lazy(() =&gt; (0, (_repositoryInfo || _load_repositoryInfo
()).getRepositoryInfo)(this.projectDir, this.metadata, this.devMetadata));
        this.afterPackHandlers = [];
        this.projectDir = options.projectDir == null ? process.cwd() : _path.resolve(options.projectDir);
        this.prepackaged = options.prepackaged == null ? null : _path.resolve(this.projectDir, options.prepackaged);
    }
    get isPrepackedAppAsar() {
        return this._isPrepackedAppAsar;
    }
    get config() {
        return this._config;
    }
    get repositoryInfo() {
        return this._repositoryInfo.value;
    }
    addAfterPackHandler(handler) {
        this.afterPackHandlers.push(handler);
    }
    artifactCreated(handler) {
        addHandler(this.eventEmitter, "artifactCreated", handler);
        return this;
    }
    dispatchArtifactCreated(event) {
        this.eventEmitter.emit("artifactCreated", event);
    }
    build() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            //noinspection JSDeprecatedSymbols
            const devMetadataFromOptions = _this.options.devMetadata;
            if (devMetadataFromOptions != null) {
                (0, (_log || _load_log()).warn)("devMetadata is deprecated, please use config instead");
            }
            let configPath = null;
            let configFromOptions = _this.options.config;
            if (typeof configFromOptions === "string") {
                // it is a path to config file
                configPath = configFromOptions;
                configFromOptions = null;
            }
            if (devMetadataFromOptions != null) {
                if (configFromOptions != null) {
                    throw new Error("devMetadata and config cannot be used in conjunction");
                }
                configFromOptions = devMetadataFromOptions.build;
            }
            const projectDir = _this.projectDir;
            const fileOrPackageConfig = yield configPath == null ? (0, (_readPackageJson || _load_readPackageJson()).loadConfig)(
projectDir) : (0, (_readPackageJson || _load_readPackageJson()).doLoadConfig)(_path.resolve(projectDir, configPath), projectDir);
            const config = (0, (_deepAssign || _load_deepAssign()).deepAssign)({}, fileOrPackageConfig, configFromOptions);
            const extraMetadata = _this.options.extraMetadata;
            if (extraMetadata != null) {
                const extraBuildMetadata = extraMetadata.build;
                if (extraBuildMetadata != null) {
                    (0, (_deepAssign || _load_deepAssign()).deepAssign)(config, extraBuildMetadata);
                    delete extraMetadata.build;
                }
                if (extraMetadata.directories != null) {
                    (0, (_log || _load_log()).warn)(`--em.directories is deprecated, please specify as --em.build.directories"`);
                    (0, (_deepAssign || _load_deepAssign()).deepAssign)(config, { directories: extraMetadata.directories });
                    delete extraMetadata.directories;
                }
            }
            yield (0, (_readPackageJson || _load_readPackageJson()).validateConfig)(config);
            _this._config = config;
            _this.appDir = yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).computeDefaultAppDirectory)(projectDir
, (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(config.directories, function (it) {
                return it.app;
            }));
            _this.isTwoPackageJsonProjectLayoutUsed = _this.appDir !== projectD ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (options.draft === undefined &amp;&amp; !(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process
.env.EP_DRAFT)) {
    options.draft = process.env.EP_DRAFT.toLowerCase() === "true";
}
if (options.prerelease === undefined &amp;&amp; !(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process
.env.EP_PRELEASE)) {
    options.prerelease = process.env.EP_PRELEASE.toLowerCase() === "true";
}
const cancellationToken = new (_CancellationToken || _load_CancellationToken()).CancellationToken();
const packager = new (_packager || _load_packager()).<span class="apidocCodeKeywordSpan">Packager</span>(options, cancellationToken
);
// because artifact event maybe dispatched several times for different publish providers
const artifactPaths = new Set();
packager.artifactCreated(function (event) {
    if (event.file != null) {
        artifactPaths.add(event.file);
    }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.packager.checkWineVersion" id="apidoc.element.electron-builder.packager.checkWineVersion">
        function <span class="apidocSignatureSpan">electron-builder.packager.</span>checkWineVersion
        <span class="apidocSignatureSpan">(_x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkWineVersion(_x) {
    return _ref5.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.packager.normalizePlatforms" id="apidoc.element.electron-builder.packager.normalizePlatforms">
        function <span class="apidocSignatureSpan">electron-builder.packager.</span>normalizePlatforms
        <span class="apidocSignatureSpan">(rawPlatforms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalizePlatforms(rawPlatforms) {
    const platforms = rawPlatforms == null || Array.isArray(rawPlatforms) ? rawPlatforms : [rawPlatforms];
    if (platforms == null || platforms.length === 0) {
        return [(_electronBuilderCore || _load_electronBuilderCore()).Platform.fromString(process.platform)];
    } else if (platforms[0] === "all") {
        if (process.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC.nodeName) {
            return [(_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC, (_electronBuilderCore || _load_electronBuilderCore
()).Platform.LINUX, (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS];
        } else if (process.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.LINUX.nodeName) {
            // macOS code sign works only on macOS
            return [(_electronBuilderCore || _load_electronBuilderCore()).Platform.LINUX, (_electronBuilderCore || _load_electronBuilderCore
()).Platform.WINDOWS];
        } else {
            return [(_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS];
        }
    } else {
        return platforms.map(it =&gt; it instanceof (_electronBuilderCore || _load_electronBuilderCore()).Platform ? it : (_electronBuilderCore
 || _load_electronBuilderCore()).Platform.fromString(it));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.pkg" id="apidoc.module.electron-builder.pkg">module electron-builder.pkg</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.pkg.PkgTarget" id="apidoc.element.electron-builder.pkg.PkgTarget">
        function <span class="apidocSignatureSpan">electron-builder.pkg.</span>PkgTarget
        <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PkgTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
    constructor(packager, outDir) {
        super("pkg");
        this.packager = packager;
        this.outDir = outDir;
        this.options = this.packager.config.pkg || Object.create(null);
        this.installLocation = this.options.installLocation || "/Applications";
    }
    build(appPath, arch) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = _this.packager;
            const options = _this.options;
            const appInfo = packager.appInfo;
            const keychainName = (yield packager.codeSigningInfo).keychainName;
            const certType = "Developer ID Installer";
            const identity = yield (0, (_codeSign || _load_codeSign()).findIdentity)(certType, options.identity || packager.platformSpecificBuildOptions
.identity, keychainName);
            if (identity == null &amp;&amp; packager.forceCodeSigning) {
                throw new Error(`Cannot find valid "${certType}" to sign standalone installer, please see https://github.com/electron
-userland/electron-builder/wiki/Code-Signing`);
            }
            const appOutDir = _this.outDir;
            const distInfo = _path.join(appOutDir, "distribution.xml");
            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)("productbuild", ["--synthesize", "--component",
appPath, _this.installLocation, distInfo], {
                cwd: appOutDir
            });
            // to use --scripts, we must build .app bundle separately using pkgbuild
            // productbuild --scripts doesn't work (because scripts in this case not added to our package)
            // https://github.com/electron-userland/electron-osx-sign/issues/96#issuecomment-274986942
            const innerPackageFile = _path.join(appOutDir, `${(0, (_mac || _load_mac()).filterCFBundleIdentifier)(appInfo.id)}.pkg
`);
            yield _this.buildComponentPackage(appPath, innerPackageFile);
            const outFile = _path.join(appOutDir, packager.expandArtifactNamePattern(options, "pkg"));
            const args = prepareProductBuildArgs(identity, keychainName);
            args.push("--distribution", distInfo);
            args.push(outFile);
            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(options.productbuild, function (it) {
                return args.push.apply(args, _toConsumableArray(it));
            });
            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)("productbuild", args, {
                cwd: appOutDir
            });
            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([(0, (_fsExtraP || _load_fsExtraP()).unlink)(innerPackageFile
), (0, (_fsExtraP || _load_fsExtraP()).unlink)(distInfo)]);
            packager.dispatchArtifactCreated(outFile, _this, arch, `${appInfo.name}-${appInfo.version}.pkg`);
        })();
    }
    buildComponentPackage(appPath, outFile) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const options = _this2.options;
            const args = ["--component", appPath, "--install-location", _this2.installLocation];
            if (options.scripts != null) {
                args.push("--scripts", _path.resolve(_this2.packager.buildResourcesDir, options.scripts));
            } else if (options.scripts !== null) {
                const dir = _path.join(_this2.packager.buildResourcesDir, "pkg-scripts");
                const stat = yield (0, (_fs || _load_fs()).statOrNull)(dir);
                if (stat != null &amp;&amp; stat.isDirectory()) {
                    args.push("--scripts", dir);
                }
            }
            args.push(outFile);
            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)("pkgbuild", args);
        })();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        switch (name) {
            case (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET:
                break;
            case "dmg":
                mapper("dmg", outDir =&gt; new (_dmg || _load_dmg()).DmgTarget(this, outDir));
                break;
            case "pkg":
                mapper("pkg", outDir =&gt; new (_pkg || _load_pkg()).<span class="apidocCodeKeywordSpan">PkgTarget<!--
span-->(this, outDir));
                break;
            default:
                mapper(name, outDir =&gt; name === "mas" || name === "mas-dev" ? new (_targetFactory || _load_targetFactory
()).NoOpTarget(name) : (0, (_targetFactory || _load_targetFactory()).createCommonTarget)(name, outDir, this));
                break;
        }
    }
}
...</span></pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.pkg.prepareProductBuildArgs" id="apidoc.element.electron-builder.pkg.prepareProductBuildArgs">
        function <span class="apidocSignatureSpan">electron-builder.pkg.</span>prepareProductBuildArgs
        <span class="apidocSignatureSpan">(identity, keychain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prepareProductBuildArgs(identity, keychain) {
    const args = [];
    if (identity != null) {
        args.push("--sign", identity);
        if (keychain != null) {
            args.push("--keychain", keychain);
        }
    }
    return args;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.platformPackager" id="apidoc.module.electron-builder.platformPackager">module electron-builder.platformPackager</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.platformPackager.PlatformPackager" id="apidoc.element.electron-builder.platformPackager.PlatformPackager">
        function <span class="apidocSignatureSpan">electron-builder.platformPackager.</span>PlatformPackager
        <span class="apidocSignatureSpan">(info)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PlatformPackager {
    constructor(info) {
        this.info = info;
        this._resourceList = new (_electronBuilderUtil || _load_electronBuilderUtil()).Lazy(() =&gt; {
            return (0, (_fsExtraP || _load_fsExtraP()).readdir)(this.buildResourcesDir).catch(e =&gt; {
                if (e.code !== "ENOENT") {
                    throw e;
                }
                return [];
            });
        });
        this.config = info.config;
        this.platformSpecificBuildOptions = PlatformPackager.normalizePlatformSpecificBuildOptions(this.config[this.platform.buildConfigurationKey
]);
        this.appInfo = this.prepareAppInfo(info.appInfo);
        this.packagerOptions = info.options;
        this.projectDir = info.projectDir;
        this.buildResourcesDir = _path.resolve(this.projectDir, this.relativeBuildResourcesDirname);
    }
    get resourceList() {
        return this._resourceList.value;
    }
    prepareAppInfo(appInfo) {
        return appInfo;
    }
    static normalizePlatformSpecificBuildOptions(options) {
        return options == null ? Object.create(null) : options;
    }
    getCscPassword() {
        const password = this.doGetCscPassword();
        if ((0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(password)) {
            (0, (_log || _load_log()).log)("CSC_KEY_PASSWORD is not defined, empty password will be used");
            return "";
        } else {
            return password.trim();
        }
    }
    doGetCscPassword() {
        return this.packagerOptions.cscKeyPassword || process.env.CSC_KEY_PASSWORD;
    }
    get relativeBuildResourcesDirname() {
        return (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(this.config.directories, it =&gt; it.buildResources) || "
build";
    }
    computeAppOutDir(outDir, arch) {
        return this.info.prepackaged || _path.join(outDir, `${this.platform.buildConfigurationKey}${(0, (_electronBuilderCore ||
_load_electronBuilderCore()).getArchSuffix)(arch)}${this.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform
.MAC ? "" : "-unpacked"}`);
    }
    dispatchArtifactCreated(file, target, arch, safeArtifactName) {
        this.info.dispatchArtifactCreated({
            file, safeArtifactName, target, arch,
            packager: this
        });
    }
    pack(outDir, arch, targets, postAsyncTasks) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const appOutDir = _this.computeAppOutDir(outDir, arch);
            yield _this.doPack(outDir, appOutDir, _this.platform.nodeName, arch, _this.platformSpecificBuildOptions, targets);
            _this.packageInDistributableFormat(appOutDir, arch, targets, postAsyncTasks);
        })();
    }
    packageInDistributableFormat(appOutDir, arch, targets, postAsyncTasks) {
        postAsyncTasks.push((_bluebirdLst2 || _load_bluebirdLst2()).default.map(targets, it =&gt; it.isAsyncSupported ? it.build(appOutDir
, arch) : null).then(() =&gt; (_bluebirdLst2 || _load_bluebirdLst2()).default.each(targets, it =&gt; it.isAsyncSupported ? null : it.build
(appOutDir, arch))));
    }
    getExtraFileMatchers(isResources, appOutDir, macroExpander, customBuildOptions) {
        const base = isResources ? this.getResourcesDir(appOutDir) : this.platform === (_electronBuilderCore || _load_electronBuilderCore
()).Platform.MAC ? _path.join(appOutDir, `${this.appInfo.productFilename}.app`, "Contents") : appOutDir;
        return (0, (_fileMatcher || _load_fileMatcher()).getFileMatchers)(this.config, isResources ? "extraResources" : "extraFiles
", this.projectDir, base, true, macroExpander, customBuildOptions);
    }
    get electronDistMacOsAppName() {
        return this.info.muonVersion == null ? "Electron.app" : "Brave.app";
    }
    get electronDistExecutableName() {
        return this.info.muonVersion == null ? "electron" : "brave";
    }
    get electronDistMacOsExecutableName() {
        return this.info.muonVersion == null ? "Electron" : "Brave";
    }
    doPack(outDir, appOutDir, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.platformPackager.normalizeExt" id="apidoc.element.electron-builder.platformPackager.normalizeExt">
        function <span class="apidocSignatureSpan">electron-builder.platformPackager.</span>normalizeExt
        <span class="apidocSignatureSpan">(ext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalizeExt(ext) {
    return ext.startsWith(".") ? ext.substring(1) : ext;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.readInstalled" id="apidoc.module.electron-builder.readInstalled">module electron-builder.readInstalled</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.readInstalled.readInstalled" id="apidoc.element.electron-builder.readInstalled.readInstalled">
        function <span class="apidocSignatureSpan">electron-builder.</span>readInstalled
        <span class="apidocSignatureSpan">(_x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readInstalled(_x) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.readPackageJson" id="apidoc.module.electron-builder.readPackageJson">module electron-builder.readPackageJson</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.readPackageJson.readPackageJson" id="apidoc.element.electron-builder.readPackageJson.readPackageJson">
        function <span class="apidocSignatureSpan">electron-builder.</span>readPackageJson
        <span class="apidocSignatureSpan">(_x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readPackageJson(_x) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.readPackageJson.doLoadConfig" id="apidoc.element.electron-builder.readPackageJson.doLoadConfig">
        function <span class="apidocSignatureSpan">electron-builder.readPackageJson.</span>doLoadConfig
        <span class="apidocSignatureSpan">(_x4, _x5)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doLoadConfig(_x4, _x5) {
    return _ref3.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.readPackageJson.getElectronVersion" id="apidoc.element.electron-builder.readPackageJson.getElectronVersion">
        function <span class="apidocSignatureSpan">electron-builder.readPackageJson.</span>getElectronVersion
        <span class="apidocSignatureSpan">(_x7, _x8, _x9)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getElectronVersion(_x7, _x8, _x9) {
    return _ref5.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.readPackageJson.loadConfig" id="apidoc.element.electron-builder.readPackageJson.loadConfig">
        function <span class="apidocSignatureSpan">electron-builder.readPackageJson.</span>loadConfig
        <span class="apidocSignatureSpan">(_x6)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadConfig(_x6) {
    return _ref4.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.readPackageJson.validateConfig" id="apidoc.element.electron-builder.readPackageJson.validateConfig">
        function <span class="apidocSignatureSpan">electron-builder.readPackageJson.</span>validateConfig
        <span class="apidocSignatureSpan">(_x10)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateConfig(_x10) {
    return _ref7.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.repositoryInfo" id="apidoc.module.electron-builder.repositoryInfo">module electron-builder.repositoryInfo</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.repositoryInfo.getRepositoryInfo" id="apidoc.element.electron-builder.repositoryInfo.getRepositoryInfo">
        function <span class="apidocSignatureSpan">electron-builder.repositoryInfo.</span>getRepositoryInfo
        <span class="apidocSignatureSpan">(projectDir, metadata, devMetadata)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRepositoryInfo(projectDir, metadata, devMetadata) {
    return _getInfo(projectDir, (devMetadata == null ? null : devMetadata.repository) || (metadata == null ? null : metadata.repository
));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.snap" id="apidoc.module.electron-builder.snap">module electron-builder.snap</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.snap.default" id="apidoc.element.electron-builder.snap.default">
        function <span class="apidocSignatureSpan">electron-builder.snap.</span>default
        <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SnapTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
    constructor(name, packager, helper, outDir) {
        super(name);
        this.packager = packager;
        this.helper = helper;
        this.outDir = outDir;
        this.options = Object.assign({}, this.packager.platformSpecificBuildOptions, this.packager.config[this.name]);
    }
    build(appOutDir, arch) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            (0, (_log || _load_log()).log)(`Building Snap for arch ${(_electronBuilderCore || _load_electronBuilderCore()).Arch[
arch]}`);
            const packager = _this.packager;
            const appInfo = packager.appInfo;
            const options = _this.options;
            const stageDir = `${appOutDir}-snap`;
            const snapDir = _path.join(stageDir, "snap");
            yield (0, (_fsExtraP || _load_fsExtraP()).emptyDir)(stageDir);
            const extraSnapSourceDir = _path.join(stageDir, "extra");
            const isUseUbuntuPlatform = options.ubuntuAppPlatformContent != null;
            if (isUseUbuntuPlatform) {
                // ubuntu-app-platform requires empty directory
                yield (0, (_fsExtraP || _load_fsExtraP()).emptyDir)(_path.join(extraSnapSourceDir, "ubuntu-app-platform"));
            }
            const snap = {};
            snap.name = packager.executableName.toLowerCase();
            snap.version = appInfo.version;
            snap.summary = options.summary || appInfo.productName;
            snap.description = _this.helper.getDescription(options);
            snap.confinement = options.confinement || "strict";
            snap.grade = options.grade || "stable";
            yield _this.helper.icons;
            if (_this.helper.maxIconPath != null) {
                snap.icon = "snap/gui/icon.png";
                yield (0, (_fsExtraP || _load_fsExtraP()).copy)(_this.helper.maxIconPath, _path.join(snapDir, "gui", "icon.png"));
            }
            const desktopFile = yield _this.helper.computeDesktopEntry(_this.options, `${packager.executableName}`, _path.join(snapDir
, "gui", `${snap.name}.desktop`), {
                "Icon": "${SNAP}/meta/gui/icon.png"
            });
            if (options.assumes != null) {
                if (!Array.isArray(options.assumes)) {
                    throw new Error("snap.assumes must be an array of strings");
                }
                snap.assumes = options.assumes;
            }
            snap.apps = {
                [snap.name]: {
                    command: `env TMPDIR=$XDG_RUNTIME_DIR desktop-launch $SNAP/${packager.executableName}`,
                    plugs: (0, (_electronBuilderUtil || _load_electronBuilderUtil()).replaceDefault)(options.plugs, ["home", "x11
", "unity7", "browser-support", "network", "gsettings", "pulseaudio", "opengl"])
                }
            };
            if (isUseUbuntuPlatform) {
                snap.apps[snap.name].plugs.push("platform");
                snap.plugs = {
                    platform: {
                        interface: "content",
                        content: "ubuntu-app-platform1",
                        target: "ubuntu-app-platform",
                        "default-provider": "ubuntu-app-platform"
                    }
                };
            }
            // libxss1, libasound2, gconf2 - was "error while loading shared libraries: libXss.so.1" on Xubuntu 16.04
            const isUseDocker = process.platform !== "linux";
            const defaultStagePackages = isUseUbuntuPlatform ? ["libnss3"] : ["libnotify4", "libappindicator1", "libxtst6", "libnss3
", "libxss1", "fontconfig-config", "gconf2", "libasound2", "pulseaudio"];
            snap.parts = {
                app: {
                    plugin: "dump",
                    "stage-packages": (0, (_electronBuilderUtil || _load_electronBuilderUtil()).replaceDefault)(options.stagePackages
, defaultStagePackages),
                    source: isUseDocker ? `/out/${_path.basename(appOutDir)}` ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
headerPickle.writeString(JSON.stringify(this.fs.header));
const headerBuf = headerPickle.toBuffer();
const sizePickle = pickle.createEmpty();
sizePickle.writeUInt32(headerBuf.length);
const sizeBuf = sizePickle.toBuffer();
const transformedFiles = this.transformedFiles;
const writeStream = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(this.outFile);
return new (_bluebirdLst2 || _load_bluebirdLst2()).<span class="apidocCodeKeywordSpan">default</span>((resolve, reject) =&gt; {
    writeStream.on("error", reject);
    writeStream.on("close", resolve);
    writeStream.write(sizeBuf);
    const w = index =&gt; {
        let data;
        while (true) {
            if (index &gt;= files.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.targetFactory" id="apidoc.module.electron-builder.targetFactory">module electron-builder.targetFactory</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.targetFactory.NoOpTarget" id="apidoc.element.electron-builder.targetFactory.NoOpTarget">
        function <span class="apidocSignatureSpan">electron-builder.targetFactory.</span>NoOpTarget
        <span class="apidocSignatureSpan">(_electronBuilderCore || _load_electronBuilderCore()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class NoOpTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {
    constructor(name) {
        super(name);
        this.options = null;
    }
    get outDir() {
        throw new Error("NoOpTarget");
    }
    build(appOutDir, arch) {
        // no build

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {})();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            case "dmg":
                mapper("dmg", outDir =&gt; new (_dmg || _load_dmg()).DmgTarget(this, outDir));
                break;
            case "pkg":
                mapper("pkg", outDir =&gt; new (_pkg || _load_pkg()).PkgTarget(this, outDir));
                break;
            default:
                mapper(name, outDir =&gt; name === "mas" || name === "mas-dev" ? new (_targetFactory || _load_targetFactory
()).<span class="apidocCodeKeywordSpan">NoOpTarget</span>(name) : (0, (_targetFactory || _load_targetFactory()).createCommonTarget
)(name, outDir, this));
                break;
        }
    }
}
get platform() {
    return (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.targetFactory.computeArchToTargetNamesMap" id="apidoc.element.electron-builder.targetFactory.computeArchToTargetNamesMap">
        function <span class="apidocSignatureSpan">electron-builder.targetFactory.</span>computeArchToTargetNamesMap
        <span class="apidocSignatureSpan">(raw, options, platform)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function computeArchToTargetNamesMap(raw, options, platform) {
    for (const targetNames of raw.values()) {
        if (targetNames.length &gt; 0) {
            // https://github.com/electron-userland/electron-builder/issues/1355
            return raw;
        }
    }
    const defaultArchs = raw.size === 0 ? [platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC ? "x64
" : process.arch] : Array.from(raw.keys()).map(it =&gt; (_electronBuilderCore || _load_electronBuilderCore()).Arch[it]);
    const result = new Map(raw);
    for (const target of (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(options.target).map(it =&gt; typeof it === "
string" ? { target: it } : it)) {
        let name = target.target;
        let archs = target.arch;
        const suffixPos = name.lastIndexOf(":");
        if (suffixPos &gt; 0) {
            name = target.target.substring(0, suffixPos);
            if (archs == null) {
                archs = target.target.substring(suffixPos + 1);
            }
        }
        for (const arch of archs == null ? defaultArchs : (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(archs
)) {
            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).addValue)(result, (0, (_electronBuilderCore || _load_electronBuilderCore
()).archFromString)(arch), name);
        }
    }
    if (result.size === 0) {
        for (const arch of defaultArchs) {
            result.set((0, (_electronBuilderCore || _load_electronBuilderCore()).archFromString)(arch), []);
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.targetFactory.createCommonTarget" id="apidoc.element.electron-builder.targetFactory.createCommonTarget">
        function <span class="apidocSignatureSpan">electron-builder.targetFactory.</span>createCommonTarget
        <span class="apidocSignatureSpan">(target, outDir, packager)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createCommonTarget(target, outDir, packager) {
    if (archiveTargets.has(target)) {
        return new (_ArchiveTarget || _load_ArchiveTarget()).ArchiveTarget(target, outDir, packager);
    } else if (target === (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET) {
        return new NoOpTarget((_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET);
    } else {
        throw new Error(`Unknown target: ${target}`);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.targetFactory.createTargets" id="apidoc.element.electron-builder.targetFactory.createTargets">
        function <span class="apidocSignatureSpan">electron-builder.targetFactory.</span>createTargets
        <span class="apidocSignatureSpan">(nameToTarget, rawList, outDir, packager, cleanupTasks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTargets(nameToTarget, rawList, outDir, packager, cleanupTasks) {
    const result = [];
    const mapper = (name, factory) =&gt; {
        let target = nameToTarget.get(name);
        if (target == null) {
            target = factory(outDir);
            nameToTarget.set(name, target);
        }
        result.push(target);
    };
    const targets = normalizeTargets(rawList, packager.defaultTarget);
    packager.createTargets(targets, mapper, cleanupTasks);
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (target == null) {
        target = factory(outDir);
        nameToTarget.set(name, target);
    }
    result.push(target);
};
const targets = normalizeTargets(rawList, packager.defaultTarget);
packager.<span class="apidocCodeKeywordSpan">createTargets</span>(targets, mapper, cleanupTasks);
return result;
}
function normalizeTargets(targets, defaultTarget) {
const list = [];
for (const t of targets) {
    const name = t.toLowerCase().trim();
    if (name === (_electronBuilderCore || _load_electronBuilderCore()).DEFAULT_TARGET) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.winPackager" id="apidoc.module.electron-builder.winPackager">module electron-builder.winPackager</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.winPackager.WinPackager" id="apidoc.element.electron-builder.winPackager.WinPackager">
        function <span class="apidocSignatureSpan">electron-builder.winPackager.</span>WinPackager
        <span class="apidocSignatureSpan">(_platformPackager || _load_platformPackager()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WinPackager extends (_platformPackager || _load_platformPackager()).PlatformPackager {
    constructor(info) {
        var _this;

        _this = super(info);
        this.cscInfo = new (_electronBuilderUtil || _load_electronBuilderUtil()).Lazy(() =&gt; {
            const platformSpecificBuildOptions = this.platformSpecificBuildOptions;
            const subjectName = platformSpecificBuildOptions.certificateSubjectName;
            if (subjectName != null) {
                return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve({ subjectName });
            }
            const certificateSha1 = platformSpecificBuildOptions.certificateSha1;
            if (certificateSha1 != null) {
                return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve({ certificateSha1 });
            }
            const certificateFile = platformSpecificBuildOptions.certificateFile;
            if (certificateFile != null) {
                const certificatePassword = this.getCscPassword();
                return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve({
                    file: certificateFile,
                    password: certificatePassword == null ? null : certificatePassword.trim()
                });
            } else {
                const cscLink = process.env.WIN_CSC_LINK || this.packagerOptions.cscLink;
                if (cscLink != null) {
                    return (0, (_codeSign || _load_codeSign()).downloadCertificate)(cscLink, this.info.tempDirManager).then(path
 =&gt; {
                        return {
                            file: path,
                            password: this.getCscPassword()
                        };
                    });
                } else {
                    return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(null);
                }
            }
        });
        this.computedPublisherName = new (_electronBuilderUtil || _load_electronBuilderUtil()).Lazy((0, (_bluebirdLst || _load_bluebirdLst
()).coroutine)(function* () {
            let publisherName = _this.platformSpecificBuildOptions.publisherName;
            if (publisherName === null) {
                return null;
            }
            const cscInfo = yield _this.cscInfo.value;
            if (cscInfo == null) {
                return null;
            }
            if (publisherName == null &amp;&amp; cscInfo.file != null) {
                try {
                    // https://github.com/digitalbazaar/forge/issues/338#issuecomment-164831585
                    const p12Asn1 = (_nodeForge || _load_nodeForge()).asn1.fromDer((yield (0, (_fsExtraP || _load_fsExtraP()).readFile
)(cscInfo.file, "binary")), false);
                    const p12 = (_nodeForge || _load_nodeForge()).pkcs12.pkcs12FromAsn1(p12Asn1, false, cscInfo.password);
                    const bagType = (_nodeForge || _load_nodeForge()).pki.oids.certBag;
                    publisherName = p12.getBags({ bagType: bagType })[bagType][0].cert.subject.getField("CN").value;
                } catch (e) {
                    throw new Error(`Cannot extract publisher name from code signing certificate, please file issue. As workaround
, set win.publisherName: ${e.stack || e}`);
                }
            }
            return publisherName == null ? null : (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(publisherName
);
        }));
    }
    get defaultTarget() {
        return ["nsis"];
    }
    doGetCscPassword() {
        return this.platformSpecificBuildOptions.certificatePassword || process.env.WIN_CSC_KEY_PASSWORD || super.doGetCscPassword
();
    }
    createTargets(targets, mapper, cleanupTasks) {
        let helper;
        const getHelper = () =&gt; {
            if (helper == null) {
                helper = new (_nsis || _load_nsis()).AppPackageHelper();
            }
            return helper;
        };
        for (const name of targets) {
            if (name === (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET) {
                continue;
            }
            if (name ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.windowsCodeSign" id="apidoc.module.electron-builder.windowsCodeSign">module electron-builder.windowsCodeSign</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.windowsCodeSign.getSignVendorPath" id="apidoc.element.electron-builder.windowsCodeSign.getSignVendorPath">
        function <span class="apidocSignatureSpan">electron-builder.windowsCodeSign.</span>getSignVendorPath
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSignVendorPath() {
    //noinspection SpellCheckingInspection
    return (0, (_binDownload || _load_binDownload()).getBinFromBintray)("winCodeSign", TOOLS_VERSION, "a34a60e74d02b81d0303e498f03c70ce0133f908b671f62ec32896db5cd0a716
");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.windowsCodeSign.getToolPath" id="apidoc.element.electron-builder.windowsCodeSign.getToolPath">
        function <span class="apidocSignatureSpan">electron-builder.windowsCodeSign.</span>getToolPath
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getToolPath() {
    return _ref3.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.windowsCodeSign.sign" id="apidoc.element.electron-builder.windowsCodeSign.sign">
        function <span class="apidocSignatureSpan">electron-builder.windowsCodeSign.</span>sign
        <span class="apidocSignatureSpan">(_x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sign(_x) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const hasMas = targets.length !== 0 &amp;&amp; targets.some(function (it) {
    return it.name === "mas" || it.name === "mas-dev";
});
const prepackaged = _this2.info.prepackaged;
if (!hasMas || targets.length &gt; 1) {
    const appPath = prepackaged == null ? _path.join(_this2.computeAppOutDir(outDir, arch), `${_this2.appInfo.productFilename}.app
`) : prepackaged;
    nonMasPromise = (prepackaged ? (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve() : _this2.doPack(outDir, _path.dirname
(appPath), _this2.platform.nodeName, arch, _this2.platformSpecificBuildOptions, targets)).then(function () {
        return _this2.<span class="apidocCodeKeywordSpan">sign</span>(appPath, null, null);
    }).then(function () {
        return _this2.packageInDistributableFormat(appPath, (_electronBuilderCore || _load_electronBuilderCore()).Arch.x64, targets
, postAsyncTasks);
    });
}
for (const target of targets) {
    const targetName = target.name;
    if (!(targetName === "mas" || targetName === "mas-dev")) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-builder.yarn" id="apidoc.module.electron-builder.yarn">module electron-builder.yarn</a></h1>


    <h2>
        <a href="#apidoc.element.electron-builder.yarn.getGypEnv" id="apidoc.element.electron-builder.yarn.getGypEnv">
        function <span class="apidocSignatureSpan">electron-builder.yarn.</span>getGypEnv
        <span class="apidocSignatureSpan">(frameworkInfo, platform, arch, buildFromSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getGypEnv(frameworkInfo, platform, arch, buildFromSource) {
    if (!frameworkInfo.useCustomDist) {
        return Object.assign({}, process.env, {
            npm_config_arch: arch,
            npm_config_target_arch: arch,
            npm_config_platform: platform,
            npm_config_build_from_source: buildFromSource
        });
    }
    const gypHome = _path.join((0, (_os || _load_os()).homedir)(), ".electron-gyp");
    return Object.assign({}, process.env, {
        npm_config_disturl: "https://atom.io/download/electron",
        npm_config_target: frameworkInfo.version,
        npm_config_runtime: "electron",
        npm_config_arch: arch,
        npm_config_target_arch: arch,
        npm_config_platform: platform,
        npm_config_build_from_source: buildFromSource,
        HOME: gypHome,
        USERPROFILE: gypHome
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.yarn.installOrRebuild" id="apidoc.element.electron-builder.yarn.installOrRebuild">
        function <span class="apidocSignatureSpan">electron-builder.yarn.</span>installOrRebuild
        <span class="apidocSignatureSpan">(_x, _x2, _x3, _x4, _x5)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function installOrRebuild(_x, _x2, _x3, _x4, _x5) {
    return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-builder.yarn.rebuild" id="apidoc.element.electron-builder.yarn.rebuild">
        function <span class="apidocSignatureSpan">electron-builder.yarn.</span>rebuild
        <span class="apidocSignatureSpan">(_x9, _x10)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rebuild(_x9, _x10) {
    return _ref2.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>